<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},819:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return cI},load:function(){return lI}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return Ee},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],E=r[2],D=Math.hypot(R,M,E);return D<a?null:(R*=D=1/D,M*=D,E*=D,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,P=M*E*s-R*o,O=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),D(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,E=(1-(p+v))*C,D=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=D,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+E*I+L*w),e[14]=n[2]+w-(R*A+D*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],E=t[12],D=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-D)<=a*Math.max(1,Math.abs(h),Math.abs(D))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=Ee,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Et(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Dt(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Et,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Dt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:xt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Et,newInstance:Dt,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>{if(!t._parent)return null;return t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null)},e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=t=>{if(t&&t.length)for(let n=0;n<t.length;++n){const r=t[n];e.addMissingNode(r)}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function En(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Dn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Er=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Dr(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Dr((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Dr((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Er):kr:t instanceof dr?Er:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Eo,ceil:Do,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Ea(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Da=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Eo,ceil:Do,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Ea,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Da,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};function Wa(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{jt.vtkErrorMacro("not implemented")}}const Ha={};function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ha,n),jt.obj(e,t),jt.setGet(e,t,["transform"]),Wa(e,t)}var Ka={newInstance:jt.newInstance(ja,"vtkImplicitFunction"),extend:ja};const $a=1e-6,qa="coincide",Xa="disjoint";function Ya(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Za(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function Qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Ja(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function ei(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*$a:s*$a,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function ti(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<$a){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=qa:o.error=Xa,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const ni={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ya,projectPoint:Za,projectVector:Qa,generalizedProjectPoint:Ja,intersectWithLine:ei,intersectWithPlane:ti,DISJOINT:Xa,COINCIDE:qa};function ri(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ya(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Za(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>Qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Ja(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>ei(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>ti(e,n,t.origin,t.normal)}const oi={normal:[0,0,1],origin:[0,0,0]};function ai(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oi,n),Ka.extend(e,t,n),jt.setGetArray(e,t,["normal","origin"],3),ri(e,t)}var ii={newInstance:jt.newInstance(ai,"vtkPlane"),extend:ai,...ni};const si=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function li(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ci(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ui(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function di(e){return ui(e,si)}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function fi(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)pi(e,...t[n]);else for(let n=0;n<t.length;n+=3)pi(e,...t.slice(n,n+3));return e}function gi(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function mi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function hi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function vi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function yi(e,t,n,r){return!!ci(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function Ti(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function bi(e,t){return e[2*t+1]-e[2*t]}function xi(e){return[bi(e,0),bi(e,1),bi(e,2)]}function Ci(e){return e.slice(0,2)}function Si(e){return e.slice(2,4)}function Ai(e){return e.slice(4,6)}function Ii(e){const t=xi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function wi(e){if(ci(e)){const t=xi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Pi(e){return[e[0],e[2],e[4]]}function Oi(e){return[e[1],e[3],e[5]]}function Ri(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Mi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Ei(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Di(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Mi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return di(n),fi(n,r)}function Vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Li(e,t,n,r){const o=[].concat(si),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Bi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ni(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ii.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function _i(e,t){if(!ci(e)||!ci(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Fi(e,t){if(!ci(e)||!ci(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function ki(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Gi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ii.evaluate(n,t,l)}let i=2;for(;i--&&!(Ri(o[r[i][0]],o[r[i][4]])&&Ri(o[r[i][1]],o[r[i][5]])&&Ri(o[r[i][2]],o[r[i][6]])&&Ri(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ui{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(si))}getBounds(){return this.bounds}equals(e){return li(this.bounds,e)}isValid(){return ci(this.bounds)}setBounds(e){return ui(this.bounds,e)}reset(){return di(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return pi(this.bounds,...t)}addPoints(e){return fi(this.bounds,e)}addBounds(e,t,n,r,o,a){return gi(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return mi(this.bounds,e,t,n)}setMaxPoint(e,t,n){return hi(this.bounds,e,t,n)}inflate(e){return vi(this.bounds,e)}scale(e,t,n){return yi(this.bounds,e,t,n)}getCenter(){return Ti(this.bounds)}getLength(e){return bi(this.bounds,e)}getLengths(){return xi(this.bounds)}getMaxLength(){return Ii(this.bounds)}getDiagonalLength(){return wi(this.bounds)}getMinPoint(){return Pi(this.bounds)}getMaxPoint(){return Oi(this.bounds)}getXRange(){return Ci(this.bounds)}getYRange(){return Si(this.bounds)}getZRange(){return Ai(this.bounds)}getCorners(e){return Mi(this.bounds,e)}computeCornerPoints(e,t){return Ei(this.bounds,e,t)}computeLocalBounds(e,t,n){return Li(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Di(this.bounds,e,t)}computeScale3(e){return Vi(this.bounds,e)}cutWithPlane(e,t){return Gi(this.bounds,e,t)}intersectBox(e,t,n,r){return Bi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ni(this.bounds,e,t)}intersect(e){return _i(this.bounds,e)}intersects(e){return Fi(this.bounds,e)}containsPoint(e,t,n){return ki(this.bounds,e,t,n)}contains(e){return Fi(this.bounds,e)}}var zi,Wi={newInstance:function(e){const t=e&&e.bounds;return new Ui(t)},equals:li,isValid:ci,setBounds:ui,reset:di,addPoint:pi,addPoints:fi,addBounds:gi,setMinPoint:mi,setMaxPoint:hi,inflate:vi,scale:yi,scaleAboutCenter:function(e,t,n,r){if(!ci(e))return!1;const o=Ti(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],yi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:Ti,getLength:bi,getLengths:xi,getMaxLength:Ii,getDiagonalLength:wi,getMinPoint:Pi,getMaxPoint:Oi,getXRange:Ci,getYRange:Si,getZRange:Ai,getCorners:Mi,computeCornerPoints:Ei,computeLocalBounds:Li,transformBounds:Di,computeScale3:Vi,cutWithPlane:Gi,intersectBox:Bi,intersectPlane:Ni,intersect:_i,intersects:Fi,containsPoint:ki,contains:function(e,t){return!!Fi(e,t)&&!!ki(e,...Pi(t))&&!!ki(e,...Oi(t))},INIT_BOUNDS:si};function Hi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function ji(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Ki(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function $i(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}zi=new i(4),i!=Float32Array&&(zi[0]=0,zi[1]=0,zi[2]=0,zi[3]=0);var qi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),ji(),ji(),ie();var Xi={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Yi}=Xi;function Zi(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function Qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Zi("pick"),e.hasKey=Zi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Yi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Yi.DISPLAY)}const Ji={allocatedRenderTime:10,coordinateSystem:Yi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp"),extend:es,...Xi};function ns(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=ji();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return N(e,t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=ji();Ki(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);T(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>Wi.getCenter(t.bounds),e.getLength=()=>Wi.getLength(t.bounds),e.getXRange=()=>Wi.getXRange(t.bounds),e.getYRange=()=>Wi.getYRange(t.bounds),e.getZRange=()=>Wi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const rs={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function os(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rs,n),ts.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,ns(e,t)}var as={newInstance:jt.newInstance(os,"vtkProp3D"),extend:os};const is={FLAT:0,GOURAUD:1,PHONG:2},ss={POINTS:0,WIREFRAME:1,SURFACE:2};var ls={Shading:is,Representation:ss,Interpolation:is};const{Representation:cs,Interpolation:us}=ls;function ds(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ps(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ds("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ds("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(us.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(us.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(us.PHONG),e.getInterpolationAsString=()=>jt.enumToString(us,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(cs.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(cs.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(cs.POINTS),e.getRepresentationAsString=()=>jt.enumToString(cs,t.representation)}const fs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:us.GOURAUD,representation:cs.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ps(e,t)}var ms={newInstance:jt.newInstance(gs,"vtkProperty"),extend:gs,...ls};const{vtkDebugMacro:hs}=jt;function vs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ms.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){hs("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const ys={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Ts(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),vs(e,t)}var bs={newInstance:jt.newInstance(Ts,"vtkActor"),extend:Ts};const xs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},Cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ss={DefaultDataType:Cs.FLOAT,DataTypeByteSize:xs,VtkDataTypes:Cs};const{vtkErrorMacro:As}=Kt,{DefaultDataType:Is}=Ss,ws=1e-6;function Ps(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function Os(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ps(r,0,1)}return Ps(e,t<0?0:t,n)}function Rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function Ms(e){return Object.prototype.toString.call(e).slice(8,-1)}const Es={computeRange:Os,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ps,getDataType:Ms,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Ds(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=Os(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ws;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=Ms(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||As("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Vs={name:"",numberOfComponents:1,dataType:Is,rangeTuple:[0,0]};function Ls(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Vs,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=Ms(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Ds(e,t)}const Bs=Dt(Ls,"vtkDataArray");var Ns={newInstance:Bs,extend:Ls,...Es,...Ss};function _s(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Fs={clippingPlanes:[]};var ks=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fs,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),_s(e,t)};function Gs(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Wi.isValid(n)?Wi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Wi.getDiagonalLength(t)}}const Us=e=>({bounds:[...Wi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var zs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Us(n)),ks(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Gs(e,t)};const{vtkErrorMacro:Ws,vtkWarningMacro:Hs}=jt;function js(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Ws("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ns.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Hs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Ws("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ns.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const Ks={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function $s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ks,n),jt.obj(e,t),js(e,t)}var qs={newInstance:jt.newInstance($s,"vtkFieldData"),extend:$s};const Xs={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ys={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Xs,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Zs,AttributeCopyOperations:Qs}=Ys,{vtkWarningMacro:Js}=jt;function el(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Zs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Qs[e]]=Object.keys(Zs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Zs[t]]=!0,e)),[])})),t.copyAttributeFlags[Qs.COPYTUPLE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.INTERPOLATE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.COPYTUPLE][Zs.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ns.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const tl={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tl,n),qs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),el(e,t)}var rl={newInstance:jt.newInstance(nl,"vtkDataSetAttributes"),extend:nl,...Ys};const ol=["pointData","cellData","fieldData"];function al(e,t){t.classHierarchy.push("vtkDataSet"),ol.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=rl.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),ol.forEach((n=>{t[n]=rl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const il={};function sl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,il,n),jt.obj(e,t),jt.setGet(e,t,ol),al(e,t)}var ll={newInstance:jt.newInstance(sl,"vtkDataSet"),extend:sl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const cl={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ul={StructuredType:cl};const{StructuredType:dl}=ul;var pl={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?dl.EMPTY:3===t?dl.XYZ_GRID:2===t?e[0]===e[1]?dl.YZ_PLANE:e[2]===e[3]?dl.XZ_PLANE:dl.XY_PLANE:1===t?e[0]<e[1]?dl.X_LINE:e[2]<e[3]?dl.Y_LINE:dl.Z_LINE:dl.SINGLE_POINT},...ul};const{vtkErrorMacro:fl}=jt;function gl(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return fl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=pl.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)fl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void fl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return fl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case cl.EMPTY:return null;case cl.SINGLE_POINT:break;case cl.X_LINE:o[0]=n;break;case cl.Y_LINE:o[1]=n;break;case cl.Z_LINE:o[2]=n;break;case cl.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case cl.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case cl.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case cl.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:fl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Wi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Wi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Wi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Wi.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Ea(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ea(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return fl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return fl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const ml={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:cl.EMPTY};function hl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ml,n),ll.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),gl(e,t)}var vl={newInstance:jt.newInstance(hl,"vtkImageData"),extend:hl};const yl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Tl={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:yl},bl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:xl,VectorMode:Cl}=Tl,{VtkDataTypes:Sl}=Ns,{ColorMode:Al}=bl,{vtkErrorMacro:Il}=jt;function wl(e){return e}function Pl(e){return Math.floor(255*e+.5)}function Ol(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Cl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Cl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Cl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)Il("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===Al.DEFAULT&&(t.getDataType()===Sl.UNSIGNED_CHAR||t.getDataType()===Sl.UNSIGNED_CHAR_CLAMPED)||n===Al.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Sl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ns.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,xl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,xl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Cl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Cl.MAGNITUDE||1!==c&&1!==s||(i=Cl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Cl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Cl.RGBCOLORS:break;case Cl.MAGNITUDE:default:{const o=Ns.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Pl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Sl.UNSIGNED_CHAR)return n;const i=Ns.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Sl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=wl;switch(n.getDataType()!==Sl.FLOAT&&n.getDataType()!==Sl.DOUBLE||(s=Pl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return Il("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==Al.DEFAULT||n.getDataType()!==Sl.UNSIGNED_CHAR)&&r!==Al.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Rl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Cl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Ml(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rl,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Ol(e,t)}var El={newInstance:jt.newInstance(Ml,"vtkScalarsToColors"),extend:Ml,...Tl};const{vtkErrorMacro:Dl}=jt;function Vl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Dl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==Cs.UNSIGNED_CHAR)return Dl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Bl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ll,n),El.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Vl(e,t)}var Nl={newInstance:jt.newInstance(Bl,"vtkLookupTable"),extend:Bl};const _l={Off:0,PolygonOffset:1};let Fl=_l.PolygonOffset,kl=_l.Off;const Gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Ul(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=kl===e;return kl=e,t}var zl={Resolve:_l,getResolveCoincidentTopologyAsString:function(){return Gl[kl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Fl},getResolveCoincidentTopology:function(){return kl},setResolveCoincidentTopology:Ul,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=Fl===e;return Fl=e,t},setResolveCoincidentTopologyToDefault:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToOff:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Ul(_l.PolygonOffset)}};function Wl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=jt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Hl=["Polygon","Line","Point"],jl={modified:()=>{}};Wl(jl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Hl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Kl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(zl).forEach((t=>{e[t]=zl[t]})),Object.keys(jl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=jl[t]})),Wl(e,t.topologyOffset,Hl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=jl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:jl,otherStaticMethods:zl,CATEGORIES:Hl,Resolve:_l};const $l={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ql={PassTypes:$l};const{FieldAssociations:Xl}=ll,{staticOffsetAPI:Yl,otherStaticMethods:Zl}=Kl,{ColorMode:Ql,ScalarMode:Jl,GetArray:ec}=bl,{VectorMode:tc}=Tl,{VtkDataTypes:nc}=Ns;function rc(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function oc(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function ac(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const ic=new WeakMap;function sc(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(Ql,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(Jl,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Jl.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Jl.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Jl.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Jl.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_FIELD_DATA){const t=e.getFieldData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale();i&&Nl.getLogRange(a,a);const s=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,u=n**3-3,d=4094,p=2,f=r?u:d;t.numberOfColorsInRange=Math.min(Math.max(e,p),f);const g=t.numberOfColorsInRange+3,m=t.numberOfColorsInRange+2,h=r?[Math.min(Math.ceil(g/n**0),n),Math.min(Math.ceil(g/n**1),n),Math.min(Math.ceil(g/n**2),n)]:[m,2,1],v=h[0]*h[1]*h[2],y=new Float64Array(v);y.fill(NaN);const T=t.numberOfColorsInRange,b=T+2,x=[0,0,0],C=a[0],S=a[1]-a[0];for(let e=0;e<b;++e){const t=C+S*(e-1)/(T-1);y[(c=h,(l=x)[0]+c[0]*(l[1]+c[1]*l[2]))]=i?10**t:t,oc(x,h)}const A=Ns.newInstance({numberOfComponents:1,values:y}),I=t.lookupTable.mapScalars(A,t.colorMode,0);t.colorTextureMap=vl.newInstance(),t.colorTextureMap.setDimensions(h),t.colorTextureMap.getPointData().setScalars(I),t.lookupTable.setAlpha(s)}var l,c;const u=t.lookupTable.getVectorMode()===tc.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=ic.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(r-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(r+1)/(p-d),v=e.getData(),y=e.getNumberOfTuples(),T=e.getNumberOfComponents(),b=t<0||t>=T,x=o[2]<=1?2:3,C=Ns.newInstance({numberOfComponents:x,values:new Float32Array(y*x)}),S=C.getData(),A=[0,0,0];ac(A,r+2,o);let I=0,w=0;const P=[.5,.5,.5];for(let e=0;e<y;++e){let e;if(b){let t=0;for(let e=0;e<T;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(I+=T,a&&(e=Nl.applyLogScale(e,n,n)),_a(e))P[0]=A[0],P[1]=A[1],P[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>r&&(t=r+1),ac(P,t,o)}else{P[1]=.49;const t=(e-f)*g;P[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=P[e]}return ic.set(e,{stringHash:l,textureCoordinates:C}),C}(n,u,a,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),i,r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Ql.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Ql.DEFAULT&&e.getDataType()===nc.UNSIGNED_CHAR||t.colorMode===Ql.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=rc("AcquireInvertibleLookupTable"),e.valueToColor=rc("ValueToColor"),e.colorToValue=rc("ColorToValue"),e.useInvertibleColorFor=rc("UseInvertibleColorFor"),e.clearInvertibleColor=rc("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer($l.ID_LOW24),o=e.getRawPixelBuffer($l.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Xl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Xl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===$l.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer($l.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===$l.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer($l.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const lc={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lc,n),zs(e,t,n),jt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Kl.implementCoincidentTopologyMethods(e,t),sc(e,t)}var uc={newInstance:jt.newInstance(cc,"vtkMapper"),extend:cc,...Yl,...Zl,...bl};function dc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function pc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const fc={extractCellSizes:dc,getNumberOfCells:pc};function gc(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=pc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=dc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function mc(e){return{empty:!0,numberOfComponents:1,dataType:Cs.UNSIGNED_INT,...e}}function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ns.extend(e,t,mc(n)),gc(e,t)}var vc={newInstance:jt.newInstance(hc,"vtkCellArray"),extend:hc,...fc};const{vtkErrorMacro:yc}=jt,Tc=[1,-1,1,-1,1,-1];function bc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return yc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Tc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const xc={empty:!0,numberOfComponents:3,dataType:Cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),Ns.extend(e,t,n),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkPoints"),extend:Cc};function Ac(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const Ic={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),jt.obj(e,t),t.points||(t.points=Sc.newInstance()),jt.get(e,t,["points","pointsIds"]),Ac(e,t)}var Pc={newInstance:jt.newInstance(wc,"vtkCell"),extend:wc};function Oc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Pc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Pc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const Rc={array:null,maxId:0,extend:0};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),jt.obj(e,t),Oc(e,t)}var Ec={newInstance:jt.newInstance(Mc,"vtkCellLinks"),extend:Mc};const Dc=0,Vc=1,Lc=2,Bc=3,Nc=4,_c=5,Fc=6,kc=7,Gc=9,Uc=21,zc=41,Wc=42,Hc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],jc={getClassNameFromTypeId:function(e){return e<Hc.length?Hc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Hc.findIndex(e)},isLinear:function(e){return e<Uc||e===zc||e===Wc},hasSubCells:function(e){return e===Fc||e===Nc||e===Lc}};function Kc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Dc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const $c={size:0,maxId:-1,extend:1e3};function qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$c,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Kc(e,t)}var Xc={newInstance:jt.newInstance(qc,"vtkCellTypes"),extend:qc,...jc},Yc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Zc}=Yc;function Qc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function Jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Qc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Zc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Zc.YES_INTERSECTION:Zc.NO_INTERSECTION}const eu={distanceToLine:Qc,intersection:Jc};function tu(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Zc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Qc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Qc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Qc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Qc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const nu={orientations:null};function ru(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nu,n),Pc.extend(e,t,n),jt.setGet(e,t,["orientations"]),tu(e,t)}var ou={newInstance:jt.newInstance(ru,"vtkLine"),extend:ru,...eu,...Yc};function au(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=Sc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=Sc.newInstance(),t.points.shallowCopy(e.getPoints())}}const iu={};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),ll.extend(e,t,n),jt.setGet(e,t,["points"]),au(e,t)}var lu={newInstance:jt.newInstance(su,"vtkPointSet"),extend:su};function cu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function uu(e,t,n,r){cu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const du={computeNormalDirection:cu,computeNormal:uu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];uu(e,t,n,d),uu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ii.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ii.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[E],P[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function pu(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(uu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ii.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=ou.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),cu(l,c,u,d),ii.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=ou.distanceToLine(e,c,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=ou.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=ou.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=ou.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const fu={};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Pc.extend(e,t,n),pu(e,t)}var mu={newInstance:jt.newInstance(gu,"vtkTriangle"),extend:gu,...du};const hu=["verts","lines","polys","strips"],{vtkWarningMacro:vu}=jt,yu={[Bc]:ou,[Nc]:ou,[_c]:mu};function Tu(e,t){t.classHierarchy.push("vtkPolyData"),hu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=vc.newInstance()})),e.getNumberOfCells=()=>hu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),hu.forEach((n=>{t[n]=vc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?Lc:Vc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Nc:Bc,1===t&&vu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=_c;break;case 4:l[n]=Gc;break;default:l[n]=kc}t<3&&vu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Fc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Xc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Vc:case Lc:o=t.verts;break;case Bc:case Nc:o=t.lines;break;case _c:case Gc:case kc:o=t.polys;break;case Fc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||yu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const bu={};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),lu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),Tu(e,t)}var Cu={newInstance:jt.newInstance(xu,"vtkPolyData"),extend:xu};function Su(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const Au={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),Su(e,t)}const wu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Pu={newInstance:jt.newInstance(Iu,"vtkTexture"),extend:Iu,...wu};const Ou=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Ru=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Mu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Eu=[0,1,0,1,0,1,0,1,2,2,2,2],Du=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Vu=new Float64Array(3),Lu=new Float64Array(3),Bu=new Float64Array(3),Nu=new Float64Array(3),_u=new Float64Array(3),Fu=new Float64Array(3),ku=new Float64Array(16);function Gu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Uu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=go().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}function zu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],Vn(Bu,Vu,r),Bu[0]+=.1,Vn(Lu,Bu,o),Pn(_u,Lu,Vu),Bu[0]-=.1,Bu[1]+=.1,Vn(Lu,Bu,o),Pn(Fu,Lu,Vu);for(let e=0;e<3;e++)_u[e]/=.05*u[0],Fu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],a[0]<-.5?On(Bu,_u,a[0]*i-l.width):a[0]>.5?On(Bu,_u,a[0]*i):On(Bu,_u,a[0]*i-l.width/2),wn(Vu,Vu,Bu),On(Bu,Fu,a[1]*i-l.height/2),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Bu,_u,l.width),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Bu,Fu,l.height),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Bu,_u,l.width),Pn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(ku,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Vu[0]=f[3*u],Vu[1]=f[3*u+1],Vu[2]=f[3*u+2],Vn(Bu,Vu,n),Vu[0]=f[3*u+3],Vu[1]=f[3*u+4],Vu[2]=f[3*u+5],Vn(Nu,Vu,n),Pn(Bu,Bu,Nu);const r=[Bu[0],Bu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Wu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],zu(e,t)}),"vtkCubeAxesActorHelper");function Hu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Wi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Vu[s]=t.dataBounds[a]-.1*r*Ou[a][s],Vu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Vu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Bu,Vu,e),Vu[s]=t.dataBounds[a],Vn(Nu,Vu,e),Pn(Bu,Nu,Bu),Mn(Bu,Bu),i=Bu[2]>o,t.camera.getParallelProjection()||(Mn(Nu,Nu),i=En(Nu,Bu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Du[t][0]].length+2*r[Du[t][1]].length,a+=r[Du[t][0]].length+r[Du[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Mu[e][0],l[3*u+2]=Mu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Du[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Du[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Eu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Ru[a][e];if(1===n[d]){const e=Eu[d],n=3*Mu[d][0],p=3*Mu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Du[a][0]]=.5*(t.dataBounds[2*Du[a][0]]+t.dataBounds[2*Du[a][0]+1]),s[3*l+Du[a][1]]=.5*(t.dataBounds[2*Du[a][1]]+t.dataBounds[2*Du[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Ru[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Gu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Gu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Gu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Wi.setBounds(t.bounds,t.gridActor.getBounds()),Wi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function ju(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Wi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Uu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,ju(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=uc.newInstance(),t.polyData=Cu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=bs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Cu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Hu(e,t)}var $u={newInstance:jt.newInstance(Ku,"vtkCubeAxesActor"),extend:Ku,newCubeAxesActorHelper:Wu,defaultGenerateTicks:Uu};function qu(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Xu={};const Yu=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=$u.newCubeAxesActorHelper(),qu(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Yu);const Zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Qu={ObjectType:Zu};const{ObjectType:Ju}=Qu;function ed(e,t){function n(e){switch(e){case Ju.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Ju.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Ju.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const td={objectType:Ju.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,td,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ed(e,t)}var rd={newInstance:jt.newInstance(nd),extend:nd,...Qu};const{vtkErrorMacro:od}=jt;function ad(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=rd.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===ss.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===ss.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,E=0,D=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];E+=n*n;const r=.5*(t[1]+t[0]);D+=r*r}const V=E>0&&(Math.abs(D)/E>1e6||Math.abs(Math.log10(E))>3||0===E&&D>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,T++)C(A[e],A,e+1,T+a.cellOffset);return t.elementCount=w,e.upload(O,Zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,Zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,ji(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):od("Wrong type for coordScale, expected vec3 or null"):od("Wrong type for coordShift, expected vec3 or null")}}const id={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),rd.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),ad(e,t)}var ld={newInstance:jt.newInstance(sd),extend:sd};const{vtkErrorMacro:cd}=jt;function ud(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return cd(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const dd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkShader"),extend:pd};const{vtkErrorMacro:gd}=jt;function md(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(gd(`Links failed: ${t.error}`),0):(gd(t.error),0):(gd(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.fragmentShader.getError()),0):(gd(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return gd(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(gd("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return gd("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const hd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=fd.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=fd.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=fd.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),md(e,t)}var yd={newInstance:jt.newInstance(vd,"vtkShaderProgram"),extend:vd,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function Td(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const bd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function xd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),Td(e,t)}var Cd={newInstance:jt.newInstance(xd,"vtkOpenGLVertexArrayObject"),extend:xd};const Sd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function Ad(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===ss.POINTS||n===Sd.Points?t.context.POINTS:e===ss.WIREFRAME||n===Sd.Lines||n===Sd.TrisEdges||n===Sd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Sd.Points||r.getProperty().getRepresentation()===ss.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Sd.Points?2:t.primitiveType===Sd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const Id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=yd.newInstance(),t.VAO=Cd.newInstance(),t.CABO=ld.newInstance(),Ad(e,t)}var Pd={newInstance:jt.newInstance(wd),extend:wd,primTypes:Sd};const Od={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Rd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Md={Wrap:Od,Filter:Rd};const Ed=new Float32Array(1),Dd=new Int32Array(Ed.buffer);var Vd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Ed[0]=e;const t=Dd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Ld;const{Wrap:Bd,Filter:Nd}=Md,{VtkDataTypes:_d}=Ns,{vtkDebugMacro:Fd,vtkErrorMacro:kd,vtkWarningMacro:Gd}=Kt,{toHalf:Ud}=Vd;function zd(e,t){t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Nd.LINEAR),e.setMagnificationFilter(Nd.LINEAR)):(e.setMinificationFilter(Nd.NEAREST),e.setMagnificationFilter(Nd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Bd.REPEAT),e.setWrapS(Bd.REPEAT),e.setWrapT(Bd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const n=()=>{if(t.minificationFilter!==Nd.LINEAR&&t.magnificationFilter!==Nd.LINEAR||(void 0===Ld&&(Ld=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,y=i.getExtension("WEBGL_lose_context");return y&&y.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Ld))return t.oglNorm16Ext};function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Vd.toHalf(Vd.fromHalf(e[u][l+s+t])*h*(1-v)+Vd.fromHalf(e[u][l+p+t])*h*v+Vd.fromHalf(e[u][c+s+t])*m*(1-v)+Vd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&n())||e!==_d.UNSIGNED_SHORT&&e!==_d.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Gd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Fd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Gd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(r,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(r,o,n(),e.useHalfFloat()),a||(a||(Fd("Unsupported internal texture type!"),Fd(`Unable to find suitable internal format for T=${r} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=r=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case n()&&!o&&_d.SHORT:return t.context.SHORT;case n()&&!o&&_d.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&_d.SHORT:case o&&_d.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case _d.FLOAT:case _d.VOID:default:return t.context.FLOAT}switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case _d.FLOAT:case _d.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Nd.NEAREST:return t.context.NEAREST;case Nd.LINEAR:return t.context.LINEAR;case Nd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Nd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Nd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Nd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Bd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Bd.REPEAT:return t.context.REPEAT;case Bd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==_d.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==_d.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Ud(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=e.updateArrayDataTypeForGL(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(e.updateArrayDataTypeForGL(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=(r,a,i,s)=>(e.getOpenGLDataType(i),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?i===_d.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=r,t.height=a,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(i,n(),e.useHalfFloat()),e.deactivate(),!0):(kd("Failed to determine texture parameters."),!1)),e.create2DFromImage=r=>{if(e.getOpenGLDataType(_d.UNSIGNED_CHAR),e.getInternalFormat(_d.UNSIGNED_CHAR,4),e.getFormat(_d.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const a=!(t._openGLRenderWindow.getWebgl2()||Fo(r.width)&&Fo(r.height)),i=document.createElement("canvas");i.width=a?_o(r.width):r.width,i.height=a?_o(r.height):r.height,t.width=i.width,t.height=i.height;const s=i.getContext("2d");s.translate(0,i.height),s.scale(1,-1),s.drawImage(r,0,0,r.width,r.height,0,0,i.width,i.height);const l=i;return o(_d.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=l&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,l)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,l),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(_d.UNSIGNED_CHAR,n(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Ns.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.updateVolumeInfoForGL=(r,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(n()&&!i&&r===_d.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(n()&&!i&&r===_d.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(r===_d.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(r===_d.FLOAT||i&&(r===_d.SHORT||r===_d.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=(a,i,s,l,c,u)=>{let d=c,p=u;if(!e.updateVolumeInfoForGL(d,l)&&p){const e=a*i*s,n=structuredClone(t.volumeInfo),r=new Float32Array(e*l);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const c=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<l;e++)r[o]=(p[o]-n.offset[e])*c[e],o++;d=_d.FLOAT,p=r}if(e.getOpenGLDataType(d),e.getInternalFormat(d,l),e.getFormat(d,l),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const f=[p],g=r(e.updateArrayDataTypeForGL(d,f,!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(d)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=g[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,g[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,g[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(d,n(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Ns.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=[],g=[];for(let e=0;e<c;++e)f[e]=0,g[e]=1;if(t.volumeInfo={scale:g,offset:f,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw(n,r,i,c,u,d);const m=n*r*i,h=structuredClone(p);let v=(e,t,n,r,o)=>{e[t]=n},y=_d.UNSIGNED_CHAR;if(u===_d.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=_d.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=_d.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===_d.FLOAT||c>=3)&&(T=4096);let b=1,x=1;m>T*T&&(b=Math.ceil(Math.sqrt(m/(T*T))),x=b);let C=Math.sqrt(m)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===_d.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Wd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Bd.CLAMP_TO_EDGE,wrapT:Bd.CLAMP_TO_EDGE,wrapR:Bd.CLAMP_TO_EDGE,minificationFilter:Nd.NEAREST,magnificationFilter:Nd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),zd(e,t)}const jd=Dt(Hd,"vtkOpenGLTexture");var Kd={newInstance:jd,extend:Hd,...Md};rn("vtkTexture",jd);var $d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",qd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Xd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=yd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Yd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=yd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Zd}=ll,{primTypes:Qd}=Pd,{Representation:Jd,Shading:ep}=ms,{ScalarMode:tp}=uc,{Filter:np,Wrap:rp}=Kd,{vtkErrorMacro:op}=Kt,ap={type:"StartEvent"},ip={type:"EndEvent"},{CoordinateSystem:sp}=ts;function lp(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=yd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=yd.substitute(i,"//VTK::Color::Impl",c).result):i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=yd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=yd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=yd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:op("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=yd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=yd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=yd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=yd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=yd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=yd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=yd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Jd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Qd.Points||o.getRepresentation()===Jd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Qd.Lines||o.getRepresentation()===Jd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Qd.Tris&&e!==Qd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Qd.TrisEdges&&e!==Qd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=yd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==$l.ID_LOW24&&t.lastSelectionState!==$l.ID_HIGH24||(a=yd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=yd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=yd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=yd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case $l.ID_LOW24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case $l.ID_HIGH24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=yd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===ep.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||op(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||op("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||op("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===sp.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():$l.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Jd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===$l.ID_LOW24||t.lastSelectionState===$l.ID_HIGH24);for(let i=Qd.Start;i<Qd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Qd.TrisEdges||i===Qd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ip),!t.currentInput)return void op("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==tp.USE_CELL_DATA&&a!==tp.USE_CELL_FIELD_DATA&&a!==tp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===tp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==ep.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Kd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(np.NEAREST),e.setMagnificationFilter(np.NEAREST),e.setWrapS(rp.CLAMP_TO_EDGE),e.setWrapT(rp.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Jd.SURFACE;for(let n=Qd.Start;n<Qd.End;n++)n!==Qd.TrisEdges&&n!==Qd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Jd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const cp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:$l.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=Qd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),lp(e,t)}const dp=Dt(up,"vtkOpenGLPolyDataMapper");var pp={newInstance:dp,extend:up};rn("vtkMapper",dp);const{ColorMode:fp,ScalarMode:gp,GetArray:mp}=bl;function hp(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(fp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(gp,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===gp.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===gp.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===gp.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===gp.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_FIELD_DATA){const t=e.getFieldData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const vp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),ks(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),hp(e,t)}var Tp={newInstance:jt.newInstance(yp,"vtkMapper2D"),extend:yp};const bp=1,{primTypes:xp}=Pd,{ScalarMode:Cp}=Tp,{vtkErrorMacro:Sp}=Kt,Ap={type:"StartEvent"},Ip={type:"EndEvent"};function wp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=xp.Start;e<xp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Ip),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Sp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Cp.USE_CELL_DATA&&a!==Cp.USE_CELL_FIELD_DATA&&a!==Cp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Cp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Sc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[xp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[xp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[xp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[xp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=xp.Start;a<xp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=yd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=yd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=yd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=yd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=yd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=yd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=yd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=yd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=yd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Sp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Sp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Sp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===bp?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Pp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Op=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=xp,t.tmpMat4=g(new Float64Array(16));for(let e=xp.Start;e<xp.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),wp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",Op);const{VectorMode:Rp}=El;function Mp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Ep(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Vp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Mp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Mp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Mp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Rp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ns.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Lp=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=uc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Cu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=bs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Vp(e,t)}),"vtkScalarBarActorHelper");function Bp(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Ep(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dp())}}function Np(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Np(n)),t.autoLayout||(t.autoLayout=Ep(0,t)),t.generateTicks||(t.generateTicks=Dp()),bs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Bp(e,t)}var Fp={newInstance:jt.newInstance(_p,"vtkScalarBarActor"),extend:_p,newScalarBarActorHelper:Lp};function kp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gp={};const Up=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Fp.newScalarBarActorHelper(),kp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Up);const{vtkErrorMacro:zp}=Kt;function Wp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ns.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Hp={context:null};const jp=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Zt.extend(e,t,n),t.openGLTexture=Kd.newInstance(),t.tris=Pd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Wp(e,t)}));rn("vtkSkybox",jp);const{FieldAssociations:Kp}=ll;function $p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const qp={fieldAssociation:Kp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),$p(e,t)}var Yp={newInstance:jt.newInstance(Xp,"vtkHardwareSelector"),extend:Xp};function Zp(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Kd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Rd.LINEAR),r.setMagnificationFilter(Rd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,Cs.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const Qp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Zp(e,t)}var ef={newInstance:Dt(Jp,"vtkFramebuffer"),extend:Jp};function tf(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const nf={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function rf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nf,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),tf(e,t)}var of={newInstance:jt.newInstance(rf,"vtkSelectionNode"),extend:rf,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:af}=ql,{SelectionContent:sf,SelectionField:lf}=of,{FieldAssociations:cf}=ll,{vtkErrorMacro:uf}=jt;function df(e){return`${e.propID} ${e.compositeID}`}function pf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ff(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function gf(e,t){let n=t;return n<<=24,n|=e,n}function mf(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ff(n[0],n[1],e.pixBuffer[af.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ff(n[0],n[1],e.pixBuffer[af.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[af.ID_LOW24]&&0===pf(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area))return a;const s=ff(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area),l=ff(n[0],n[1],e.pixBuffer[af.ID_HIGH24],e.area);return a.attributeID=gf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=mf(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=mf(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=mf(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function hf(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=of.newInstance();switch(l.setContentType(sf.INDICES),e){case cf.FIELD_ASSOCIATION_CELLS:l.setFieldType(lf.CELL);break;case cf.FIELD_ASSOCIATION_POINTS:l.setFieldType(lf.POINT);break;default:uf("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function vf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=mf(e,[n,t],0,u);if(r&&r.valid){const t=df(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return hf(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function yf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return vf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return uf("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=af.MIN_KNOWN_PASS;t.currentPass<=af.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===af.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=af.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===af.ID_HIGH24){if(t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===cf.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===af.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ff(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===af.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===af.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(af,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ff(e[0],e[1],t.pixBuffer[af.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ff(e[0],e[1],t.pixBuffer[af.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[af.ID_LOW24]&&0===pf(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area))return a;const s=ff(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area),l=ff(e[0],e[1],t.pixBuffer[af.ID_HIGH24],t.area);return a.attributeID=gf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=df(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return hf(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const Tf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Yp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),yf(e,t)}var xf={newInstance:jt.newInstance(bf,"vtkOpenGLHardwareSelector"),extend:bf,...ql};const{vtkErrorMacro:Cf}=Kt,{Representation:Sf}=ms,{ObjectType:Af}=rd,{PassTypes:If}=xf,wf={type:"StartEvent"},Pf={type:"EndEvent"};function Of(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(wf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Pf),!t.currentInput)return void Cf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=yd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=yd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=yd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=yd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=yd.substitute(o,"//VTK::Color::Impl",s).result,o=yd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=yd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=yd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=yd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=yd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===Sf.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===If.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Cf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Cf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=rd.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=rd.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=rd.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=rd.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,Af.ARRAY_BUFFER),t.normalBuffer.upload(n,Af.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),Af.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Af.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Rf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Mf=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),pp.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),Of(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",Mf);const{vtkErrorMacro:Ef}=jt;class Df{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Vf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Ef("Invalid or missing input");const r=Cu.newInstance();r.shallowCopy(n);const o=new Df,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(vc.newInstance({values:c,name:"faces"})),t[0]=r}}const Lf={};function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),jt.obj(e,t),jt.algo(e,t,1,1),Vf(e,t)}var Nf={newInstance:jt.newInstance(Bf,"vtkClosedPolyLineToSurfaceFilter"),extend:Bf};const{vtkErrorMacro:_f}=Kt;function Ff(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void _f("Invalid or missing input");if(!t.cutFunction)return void _f("Missing cut function");const o=Cu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const kf={cutFunction:null,cutScalars:null,cutValue:0};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Ff(e,t)}var Uf={newInstance:Dt(Gf,"vtkCutter"),extend:Gf};const zf=e=>e,Wf=1e-6;class Hf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:zf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=En(n,r);return a>=1||(Dn(this.tmp,n,r),Sn(this.tmp)<Wf&&(Dn(this.tmp,[1,0,0],e),Sn(this.tmp)<Wf&&Dn(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var jf=function(){return new Hf(!0)},Kf=function(){return new Hf(!1)};const $f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],qf=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Xf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Cu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Ns.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Ns.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&jf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Kf().translate(...t.center).apply(o),t.matrix){Kf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Kf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Yf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=vc.newInstance({values:Uint16Array.from(qf)}),t._lineCells=vc.newInstance({values:Uint16Array.from($f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),Xf(e,t)}var Qf={newInstance:jt.newInstance(Zf,"vtkCubeSource"),extend:Zf};const{vtkErrorMacro:Jf}=jt;function eg(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Jf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Jf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const tg={};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=Qf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),eg(e,t)}var rg={newInstance:jt.newInstance(ng,"vtkImageDataOutlineFilter"),extend:ng};let og;function ag(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>og({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const ig={preMultiplyFlag:!1,matrix:[...vo]};function sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),ag(e,t)}og=jt.newInstance(sg,"vtkTransform");var lg={newInstance:og,extend:sg};function cg(e,t,n){return e?`${e.getMTime()}-${t}-${n}`:"0"}function ug(e,t){return`${e.getMTime()}A${t.getMTime()}`}const dg={NEAREST:0,LINEAR:1};var pg={InterpolationType:dg};const{vtkErrorMacro:fg}=Kt;function gg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function mg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera());const o=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),o&&!o.isDeleted()&&o!==t._openGLRenderWindow&&n(o),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):fg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.openGLTexture.setMinificationFilter(Rd.LINEAR),t.openGLTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()?.getScalars();if(!a)return;const i=a.getNumberOfComponents();let s=ug(o,a);const l=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(l?.oglObject?.getHandle()&&l?.hash===s)t.openGLTexture=l.oglObject;else{t.openGLTexture=Kd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a),t._openGLRenderWindow.setGraphicsResourceForObject(a,t.openGLTexture,s),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a}const c=r.getProperty(),u=c.getIndependentComponents(),d=u?i:1,p=u?2*d:1,f=c.getRGBTransferFunction();s=cg(f,u,d);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===s)t.colorTexture=g.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*p*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=c.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,s),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const m=c.getPiecewiseFunction();s=cg(m,u,d);const h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===s)t.pwfTexture=h.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),m){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=c.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.pwfTexture,s),m!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=m)}const v=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==v){const e=Ns.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ns.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:fg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",ss.SURFACE,r)}t.VBOBuildString=v,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",gg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",gg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=yd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:fg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=yd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:fg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=yd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=yd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=yd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ii.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();za.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ns.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Cu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ns.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else fg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const hg={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};const vg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=rg.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Cu.newInstance(),t.cutter=Uf.newInstance(),t.lineToSurfaceFilter=Nf.newInstance(),t.transform=lg.newInstance(),bt(e,t,["openGLTexture"]),mg(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",vg);var yg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Tg}=Kt,{SlicingMode:bg}=yg;function xg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function Cg(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=yd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=yd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Tg("Unsupported number of independent coordinates.")}}if(i=yd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=yd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=yd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Tg("Unsupported number of independent coordinates.")}i=yd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=yd.substitute(i,"//VTK::TCoord::Impl",[...xg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Tg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Tg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===bg.NONE&&(i=bg.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Tg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=cg(f,u,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.oglObject?.getHandle()&&m?.hash===g)t.colorTexture=m.oglObject;else{t.colorTexture=Kd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(n*p*3);if(c===dg.NEAREST?(t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST)):(t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR)),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,g),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const h=l.getPiecewiseFunction(),v=cg(h,u,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.oglObject?.getHandle()&&y?.hash===v)t.pwfTexture=y.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===dg.NEAREST?(t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),h){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);h&&(t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,v),h!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(h,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=h)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===bg.I&&(S=x-C[0]),T===bg.J&&(S=x-C[2]),T!==bg.K&&T!==bg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Kd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===dg.NEAREST?(new Set([1,3,4]).has(s)&&i===Cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.NEAREST)):t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST)):(4!==s||i!==Cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Rd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Rd.LINEAR)),t.openGLTexture.setWrapS(Od.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Od.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[bg.X,bg.Y,bg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===bg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===bg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===bg.K||T===bg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Tg("Reformat slicing not yet supported.");t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const m=Ns.newInstance({numberOfComponents:3,values:r});m.setName("points");const h=Ns.newInstance({numberOfComponents:2,values:l});h.setName("tcoords");const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const y=Ns.newInstance({numberOfComponents:1,values:v});t.tris.getCABO().createVBO(y,"polys",ss.SURFACE,{points:m,tcoords:h,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Kd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Sg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const Ag=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),Cg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",Ag);const Ig=0,wg=1,Pg=2,{vtkErrorMacro:Og}=jt;function Rg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.volumeTexture.setMinificationFilter(Rd.NEAREST),t.volumeTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.volumeTexture.setMinificationFilter(Rd.LINEAR),t.volumeTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=o?.getPointData()?.getScalars();if(!i)return;const s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=ug(o,i);if(s?.oglObject?.getHandle()&&s?.hash===l)t.volumeTexture=s.oglObject;else{t.volumeTexture=Kd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],i,t.renderable.getPreferSizeOverAccuracy()),t._openGLRenderWindow.setGraphicsResourceForObject(i,t.volumeTexture,l),i!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(i,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=i}const c=i.getNumberOfComponents(),u=r.getProperty(),d=u.getIndependentComponents(),p=d?c:1,f=d?2*p:1,g=u.getRGBTransferFunction(),m=cg(g,d,p),h=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(h?.oglObject?.getHandle()&&h?.hash===m)t.colorTexture=h.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*f*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),g){const e=new Float32Array(3*n);for(let t=0;t<p;t++){const o=u.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),d)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,f,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}g&&(t._openGLRenderWindow.setGraphicsResourceForObject(g,t.colorTexture,m),g!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(g,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=g)}const v=u.getPiecewiseFunction(),y=cg(v,d,p),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===y)t.pwfTexture=T.oglObject;else{const n=1024,r=n*f,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),v){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<p;++t){const r=u.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),d)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,f,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);v&&(t._openGLRenderWindow.setGraphicsResourceForObject(v,t.pwfTexture,y),v!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(v,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=v)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ns.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ns.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ns.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Ns.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ns.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ns.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",ss.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Og("Unsupported number of independent coordinates.")}}i=yd.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===wg?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Ig:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case wg:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===Pg&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Og("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Og("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Og(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),Rn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),T(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=jt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Mg={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Eg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mg,n),Zt.extend(e,t,n),Xd(e,t,n),jt.algo(e,t,2,0),t.tris=Pd.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),Rg(e,t)}),"vtkOpenGLImageCPRMapper");function Dg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Eg);const Vg={context:null,keyMatrixTime:null,keyMatrices:null};const Lg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),Dg(e,t)}),"vtkOpenGLImageSlice");function Bg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Lg);const Ng={};const _g=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Bg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",_g);const Fg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},kg={FRACTIONAL:0,PROPORTIONAL:1},Gg={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var Ug={InterpolationType:Fg,OpacityMode:kg,ColorMixPreset:Gg};const zg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Wg={BlendMode:zg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Hg,vtkErrorMacro:jg}=Kt;function Kg(e,t){function n(n){[t._scalars,t._scalarOpacityFunc,t._colorTransferFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(r,o)=>{if(r){const r=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const o=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const a=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(a.getActiveCamera()),e.renderPiece(a,o)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.useIndependentComponents=e=>{const n=e.getIndependentComponents(),r=t.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(),o=e.getColorMixPreset();return n&&r>=2||!!o},e.replaceShaderValues=(n,r,o)=>{const a=o.getProperty();let i=n.Fragment;a.getInterpolationType()===Fg.LINEAR&&(i=yd.substitute(i,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===e.isLabelmapOutlineRequired(o)&&(i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),t.renderable.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND&&(i=yd.substitute(i,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const s=t.scalarTexture.getComponents();i=yd.substitute(i,"//VTK::NumComponents",`#define vtkNumComponents ${s}`).result;const l=e.useIndependentComponents(a);l&&(i=yd.substitute(i,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const c=[],u=[];for(let e=0;e<s;e++)a.getOpacityMode(e)===kg.PROPORTIONAL&&c.push(`#define vtkComponent${e}Proportional`),a.getForceNearestInterpolation(e)&&u.push(`#define vtkComponent${e}ForceNearest`);i=yd.substitute(i,"//VTK::vtkProportionalComponents",c.join("\n")).result,i=yd.substitute(i,"//VTK::vtkForceNearestComponents",u.join("\n")).result;const d=function(e){switch(e){case Gg.CUSTOM:return"//VTK::CustomColorMix";case Gg.ADDITIVE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n\n          vec3 scalarInterp1[2];\n          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);\n          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;\n          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;\n          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n          vec4 normalLight1 = normalMat[1];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        float opacity1 = pwfValue1;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          opacity1 *= gof1;\n        #endif\n        float opacitySum = opacity0 + opacity1;\n        if (opacitySum <= 0.0) {\n          return vec4(0.0);\n        }\n\n        // mix the colors and opacities\n        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);\n        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);\n        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;\n        return vec4(mixedColor, min(1.0, opacitySum));\n";case Gg.COLORIZE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n        #endif\n\n        // mix the colors and opacities\n        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);\n        color = applyAllLightning(color, opacity0, posIS, normalLight0);\n        return vec4(color, opacity0);\n";default:return null}}(a.getColorMixPreset());d&&(i=yd.substitute(i,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,i=yd.substitute(i,"//VTK::CustomComponentsColorMix::Impl",d).result);const p=t.currentInput.getSpatialExtent(),f=t.currentInput.getSpacing(),g=new Float64Array(3);In(g,(p[1]-p[0])*f[0],(p[3]-p[2])*f[1],(p[5]-p[4])*f[2]);const m=Sn(g)/e.getCurrentSampleDistance(r);i=yd.substitute(i,"//VTK::MaximumSamplesValue",`${Math.ceil(m)}`).result,i=yd.substitute(i,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lightComplexity}`).result,t.lightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(i=yd.substitute(i,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(i=yd.substitute(i,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&a.getAmbient()>0&&(i=yd.substitute(i,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const h=l?s:1;t.gopacity=!1;for(let e=0;!t.gopacity&&e<h;++e)t.gopacity||=a.getUseGradientOpacity(e);t.gopacity&&(i=yd.substitute(i,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(i=yd.substitute(i,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),i=yd.substitute(i,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=i,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=yd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lightComplexity&&(o=yd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=yd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=yd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=yd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=yd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{const a=o.getProperty();((n,r)=>{let o=0;n.getProperty().getShade()&&t.renderable.getBlendMode()===zg.COMPOSITE_BLEND&&(o=0,t.numberOfLights=0,r.forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===o&&(o=1)),1===o&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(o=2),o<3&&e.getPositional()&&(o=3)}))),o!==t.lightComplexity&&(t.lightComplexity=o,e.modified())})(o,r.getLights());const i=t.scalarTexture.getComponents(),s=[],l=[];for(let e=0;e<i;e++)s.push(a.getOpacityMode(e)),l.push(a.getForceNearestInterpolation(e));const c=t.currentInput.getSpatialExtent(),u=t.currentInput.getSpacing(),d=new Float64Array(3);In(d,(c[1]-c[0])*u[0],(c[3]-c[2])*u[1],(c[5]-c[4])*u[2]);const p=Sn(d)/e.getCurrentSampleDistance(r),f=!!t.zBufferTexture,g={iComps:a.getIndependentComponents(),colorMixPreset:a.getColorMixPreset(),interpolationType:a.getInterpolationType(),useLabelOutline:e.isLabelmapOutlineRequired(o),numComp:i,maxSamples:p,useGradientOpacity:a.getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),hasZBufferTexture:f,opacityModes:s,forceNearestInterps:l};return(0===n.getProgram()?.getHandle()||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime()||!t.previousState||!ke()(t.previousState,g))&&(t.previousState=g,!0)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange();if(i?.dataComputedScale?.length){const e=[],t=[];for(let n=0;n<4;n++)e[n]=s[0]*i.dataComputedScale[n]+i.dataComputedOffset[n],t[n]=s[1]*i.dataComputedScale[n]+i.dataComputedOffset[n],e[n]=(e[n]-i.offset[n])/i.scale[n],t[n]=(t[n]-i.offset[n])/i.scale[n];a.setUniform4f("ipScalarRangeMin",e[0],e[1],e[2],e[3]),a.setUniform4f("ipScalarRangeMax",t[0],t[1],t[2],t[3])}if(null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Hg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),s.setUniform3f("volumeSpacings",x[0],x[1],x[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*En(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(e.isLabelmapOutlineRequired(o)){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lightComplexity)return;let O=0;const R=[],M=[],E=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],E[0+3*O]=-.5*w[0],E[1+3*O]=-.5*w[1],E[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",E),3===t.lightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(n,r,o)=>{const a=n.getProgram();a.setUniformi("ctexture",t.colorTexture.getTextureUnit()),a.setUniformi("otexture",t.opacityTexture.getTextureUnit()),a.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),a.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const i=t.scalarTexture.getVolumeInfo(),s=o.getProperty(),l=t.scalarTexture.getComponents(),c=e.useIndependentComponents(s);if(c)for(let e=0;e<l;e++)a.setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));for(let e=0;e<l;e++){const t=c?e:0,n=i.scale[e],r=s.getScalarOpacity(t).getRange(),o=n/(r[1]-r[0]),l=(i.offset[e]-r[0])/(r[1]-r[0]);a.setUniformf(`oshift${e}`,l),a.setUniformf(`oscale${e}`,o);const u=s.getRGBTransferFunction(t).getRange(),d=(i.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);a.setUniformf(`cshift${e}`,d),a.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(c)for(let e=0;e<l;++e){const t=i.scale[e];if(s.getUseGradientOpacity(e)){const n=s.getGradientOpacityMinimumOpacity(e),r=s.getGradientOpacityMaximumOpacity(e);a.setUniformf(`gomin${e}`,n),a.setUniformf(`gomax${e}`,r);const o=[s.getGradientOpacityMinimumValue(e),s.getGradientOpacityMaximumValue(e)];a.setUniformf(`goscale${e}`,t*(r-n)/(o[1]-o[0])),a.setUniformf(`goshift${e}`,-o[0]*(r-n)/(o[1]-o[0])+n)}else a.setUniformf(`gomin${e}`,1),a.setUniformf(`gomax${e}`,1),a.setUniformf(`goscale${e}`,0),a.setUniformf(`goshift${e}`,1)}else{const e=i.scale[l-1],t=s.getGradientOpacityMinimumOpacity(0),n=s.getGradientOpacityMaximumOpacity(0);a.setUniformf("gomin0",t),a.setUniformf("gomax0",n);const r=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];a.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),a.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===e.isLabelmapOutlineRequired(o)){const e=o.getProperty().getLabelOutlineOpacity();a.setUniformf("outlineOpacity",e)}t.lightComplexity>0&&(a.setUniformf("vAmbient",s.getAmbient()),a.setUniformf("vDiffuse",s.getDiffuse()),a.setUniformf("vSpecular",s.getSpecular()),a.setUniformf("vSpecularPower",s.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*En(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Fg.NEAREST?(t.scalarTexture.setMinificationFilter(Rd.NEAREST),t.scalarTexture.setMagnificationFilter(Rd.NEAREST)):(t.scalarTexture.setMinificationFilter(Rd.LINEAR),t.scalarTexture.setMagnificationFilter(Rd.LINEAR)),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):jg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.scalarTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(Rd.LINEAR),t.jitterTexture.setMagnificationFilter(Rd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,Cs.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=e.useIndependentComponents(i),c=l?s:1,u=i.getScalarOpacity(),d=t._openGLRenderWindow.getGraphicsResourceForObject(u);let p=cg(u,l,c);if(d?.oglObject&&d.hash===p)t.opacityTexture=d.oglObject;else{t.opacityTexture=Kd.newInstance(),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const r=1024,o=2*r*c,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<c;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(Rd.LINEAR),t.opacityTexture.setMagnificationFilter(Rd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.UNSIGNED_CHAR,e)}u&&(t._openGLRenderWindow.setGraphicsResourceForObject(u,t.opacityTexture,p),u!==t._scalarOpacityFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(u,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalarOpacityFunc,e)),t._scalarOpacityFunc=u)}const f=i.getRGBTransferFunction();p=cg(f,l,c);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===p)t.colorTexture=g.oglObject;else{t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(2*n*c*3),o=new Float32Array(3*n);for(let e=0;e<c;++e){const t=i.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.create2DFromRaw(n,2*c,3,Cs.UNSIGNED_CHAR,r),f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,p),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}e.updateLabelOutlineThicknessTexture(r);const m=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(p=ug(o,a),m?.oglObject?.getHandle()&&m?.hash===p)t.scalarTexture=m.oglObject;else{t.scalarTexture=Kd.newInstance(),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a,t.renderable.getPreferSizeOverAccuracy()),a&&(t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,p),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ns.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ns.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThickness(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{t.labelOutlineThicknessTexture=Kd.newInstance(),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.isLabelmapOutlineRequired=e=>{const n=e.getProperty(),r=t.renderable;return n.getUseLabelOutline()||r.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND}}const $g={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$g,n),Zt.extend(e,t,n),Yd(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),t.jitterTexture=Kd.newInstance(),t.jitterTexture.setWrapS(Od.REPEAT),t.jitterTexture.setWrapT(Od.REPEAT),t.framebuffer=ef.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Kg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",qg);const{vtkDebugMacro:Xg}=Kt;function Yg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Xg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const Zg={};const Qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zg,n),Zt.extend(e,t,n),Yg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Qg);var Jg="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:em}=ms;function tm(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Kd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function nm(e,t){return tm(e,t,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE)}function rm(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",em.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=nm(t._openGLRenderWindow,t.size),t.seedTexture0=nm(t._openGLRenderWindow,t.size),t.licTexture1=nm(t._openGLRenderWindow,t.size),t.seedTexture1=nm(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?tm(t._openGLRenderWindow,t.size,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return tm(e,t,Kd.Filter.LINEAR,Kd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const om={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,om,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),rm(e,t)}var im={newInstance:jt.newInstance(am,"vtkLICPingPongBufferManager"),extend:am};const sm=0,lm=1,cm=2,um=3,dm=1;function pm(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=ef.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=ef.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=im.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],y=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;y.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:T}=t;y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",0),T.setUniformf("uMaskThreshold",t.maskThreshold),T.setUniform2f("uNoiseBoundsPt1",...m),T.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),T.setUniformi("texLIC",t.bufs.getLICTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,T);const{LICIShaderProgram:b}=t;y.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",1),n(T,t.bufs),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;y.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)y.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),y.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const fm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),pm(e,t)}var mm={newInstance:jt.newInstance(gm,"vtkLineIntegralConvolution2D"),extend:gm};function hm(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const vm={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:sm,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:dm,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vm,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),hm(0,t)}var Tm={newInstance:jt.newInstance(ym,"vtkSurfaceLICInterface"),extend:ym};const{Representation:bm}=ms;function xm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===dm?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Kd.newInstance({wrapS:Kd.Wrap.REPEAT,wrapT:Kd.Wrap.REPEAT,minificationFilter:Kd.Filter.NEAREST,magnificationFilter:Kd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.allocateTextures=()=>{const n=Kd.Filter.NEAREST,r=Kd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Kd.newInstance({wrapS:Kd.Wrap.CLAMP_TO_EDGE,wrapT:Kd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Kd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=ef.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",bm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=mm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===cm||u===um){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const Cm={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Sm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cm,n),Tm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),xm(e,t)}var Am={newInstance:jt.newInstance(Sm,"vtkSurfaceLICInterface"),extend:Sm};const{vtkErrorMacro:Im}=Kt;function wm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=yd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=yd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=yd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=yd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=yd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Im("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Im("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Im("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Tm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Am.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Im("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const Pm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Om=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pm,n),pp.extend(e,t,n),wm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",Om);const{vtkErrorMacro:Rm}=Kt;function Mm(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Rm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,Zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Em={};const Dm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Em,n),pp.extend(e,t,n),Mm(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",Dm);const{vtkErrorMacro:Vm}=Kt;function Lm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=yd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||Vm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||Vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||Vm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():Vm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,Zu.ARRAY_BUFFER),a.getColorBO().upload(g,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Bm={};const Nm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bm,n),pp.extend(e,t,n),Lm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Nm);const _m=[];_m["-".charCodeAt(0)]=62,_m["_".charCodeAt(0)]=63;const Fm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<Fm.length;e++)_m[Fm.charCodeAt(e)]=e;function km(e){return void 0!==_m[e.charCodeAt(0)]}function Gm(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<18;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<12;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<6;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<10;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<4;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<2;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Um(e,t,n){const r=(e<<16)+(t<<8)+n;return Fm[r>>18]+Fm[r>>12&63]+Fm[r>>6&63]+Fm[63&r]}function zm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Um(t[n],t[n+1],t[n+2])}if(n>0){const e=Um(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Wm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)km(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Gm(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Hm={};function jm(e,t){Hm[e]=t}var Km=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Hm[e](t)},$m=Uint8Array,qm=Uint16Array,Xm=Uint32Array,Ym=new $m([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zm=new $m([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qm=new $m([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jm=function(e,t){for(var n=new qm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Xm(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},eh=Jm(Ym,2),th=eh[0],nh=eh[1];th[28]=258,nh[258]=28;for(var rh=Jm(Zm,0),oh=rh[0],ah=(rh[1],new qm(32768)),ih=0;ih<32768;++ih){var sh=(43690&ih)>>>1|(21845&ih)<<1;sh=(61680&(sh=(52428&sh)>>>2|(13107&sh)<<2))>>>4|(3855&sh)<<4,ah[ih]=((65280&sh)>>>8|(255&sh)<<8)>>>1}var lh=function(e,t,n){for(var r=e.length,o=0,a=new qm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new qm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new qm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[ah[d]>>>l]=c}else for(i=new qm(r),o=0;o<r;++o)e[o]&&(i[o]=ah[s[e[o]-1]++]>>>15-e[o]);return i},ch=new $m(288);for(ih=0;ih<144;++ih)ch[ih]=8;for(ih=144;ih<256;++ih)ch[ih]=9;for(ih=256;ih<280;++ih)ch[ih]=7;for(ih=280;ih<288;++ih)ch[ih]=8;var uh=new $m(32);for(ih=0;ih<32;++ih)uh[ih]=5;var dh=lh(ch,9,1),ph=lh(uh,5,1),fh=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},gh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},mh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},hh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?qm:4==e.BYTES_PER_ELEMENT?Xm:$m)(n-t);return r.set(e.subarray(t,n)),r},vh=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],yh=function(e,t,n){var r=new Error(t||vh[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,yh),!n)throw r;return r},Th=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new $m(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new $m(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new $m(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=gh(e,c,1);var h=gh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&yh(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=dh,p=ph,f=9,g=5;else if(2==h){var T=gh(e,c,31)+257,b=gh(e,c+10,15)+4,x=T+gh(e,c+5,31)+1;c+=14;for(var C=new $m(x),S=new $m(19),A=0;A<b;++A)S[Qm[A]]=gh(e,c+3*A,7);c+=3*b;var I=fh(S),w=(1<<I)-1,P=lh(S,I,1);for(A=0;A<x;){var O,R=P[gh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,E=0;for(16==O?(E=3+gh(e,c,3),c+=2,M=C[A-1]):17==O?(E=3+gh(e,c,7),c+=3):18==O&&(E=11+gh(e,c,127),c+=7);E--;)C[A++]=M}}var D=C.subarray(0,T),V=C.subarray(T);f=fh(D),g=fh(V),d=lh(D,f,1),p=lh(V,g,1)}else yh(1);if(c>m){a&&yh(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[mh(e,c)&L])>>>4;if((c+=15&M)>m){a&&yh(0);break}if(M||yh(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Ym[A=_-257];F=gh(e,c,(1<<k)-1)+th[A],c+=k}var G=p[mh(e,c)&B],U=G>>>4;if(G||yh(3),c+=15&G,V=oh[U],U>3&&(k=Zm[U],V+=mh(e,c)&(1<<k)-1,c+=k),c>m){a&&yh(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:hh(t,0,u)},bh=new $m(0),xh=function(e,t){return e[t]|e[t+1]<<8},Ch=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Sh=function(e,t){return Ch(e,t)+4294967296*Ch(e,t+4)};function Ah(e,t){return Th(e,t)}function Ih(e,t){return Th(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||yh(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new $m((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function wh(e,t){return Th(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&yh(6,"invalid zlib data"),32&n[1]&&yh(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Ph(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Ih(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Ah(e,t):wh(e,t)}var Oh="undefined"!=typeof TextEncoder&&new TextEncoder,Rh="undefined"!=typeof TextDecoder&&new TextDecoder;try{Rh.decode(bh,{stream:!0})}catch(e){}function Mh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Rh)return Rh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,hh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&yh(8),a}var Eh=function(e,t){return t+30+xh(e,t+26)+xh(e,t+28)},Dh=function(e,t,n){var r=xh(e,t+28),o=Mh(e.subarray(t+46,t+46+r),!(2048&xh(e,t+8))),a=t+46+r,i=Ch(e,t+20),s=n&&4294967295==i?Vh(e,a):[i,Ch(e,t+24),Ch(e,t+42)],l=s[0],c=s[1],u=s[2];return[xh(e,t+10),l,c,o,a+xh(e,t+30)+xh(e,t+32),u]},Vh=function(e,t){for(;1!=xh(e,t);t+=4+xh(e,t+2));return[Sh(e,t+12),Sh(e,t+4),Sh(e,t+20)]};function Lh(e,t){for(var n={},r=e.length-22;101010256!=Ch(e,r);--r)(!r||e.length-r>65558)&&yh(13);var o=xh(e,r+8);if(!o)return{};var a=Ch(e,r+16),i=4294967295==a;i&&(r=Ch(e,r-12),101075792!=Ch(e,r)&&yh(13),o=Ch(e,r+32),a=Ch(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Dh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Eh(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Ah(e.subarray(h,h+d),new $m(p)):yh(14,"unknown compression type "+u):n[f]=hh(e,h,h+d))}return n}function Bh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Nh=Bh(),_h=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:Fh,vtkDebugMacro:kh}=jt;let Gh=0;function Uh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const zh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Uh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(kh(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Fh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Mh(Ph(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Mh(Ph(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Uh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Ph(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};jm("http",(e=>zh));const{vtkDebugMacro:Wh}=jt;function Hh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Wh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Wh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Hi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Hi(o,[...t.position,1],n),Hi(a,[...t.focalPoint,1],n),Hi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=qi(e[0],e[1],e[2],e[3]),n=ji(),r=qi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],$i(r,t,r),$i(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=ji();Ki(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const jh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Kh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Hh(e,t)}var $h={newInstance:jt.newInstance(Kh,"vtkCamera"),extend:Kh};function qh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const Xh={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xh,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),qh(e,t)}var Zh={newInstance:jt.newInstance(Yh,"vtkLight"),extend:Yh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Qh}=jt;function Jh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Qh("call displayToView on your view instead"),e.viewToDisplay=()=>Qh("callviewtodisplay on your view instead"),e.getSize=()=>Qh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Qh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const ev={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function tv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ev,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Jh(e,t)}var nv={newInstance:jt.newInstance(tv,"vtkViewport"),extend:tv};const{vtkDebugMacro:rv,vtkErrorMacro:ov,vtkWarningMacro:av}=Kt;function iv(e){return()=>ov(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function sv(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(rv("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):ov("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=iv("allocateTime"),e.updateGeometry=iv("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{rv(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=$h.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Zh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ov("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ov("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Wi.INIT_BOUNDS[0],t.allBounds[1]=Wi.INIT_BOUNDS[1],t.allBounds[2]=Wi.INIT_BOUNDS[2],t.allBounds[3]=Wi.INIT_BOUNDS[3],t.allBounds[4]=Wi.INIT_BOUNDS[4],t.allBounds[5]=Wi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),rv("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return rv("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return ov("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&(av("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return rv("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ov("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const lv={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lv,n),nv.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),sv(e,t)}var uv={newInstance:Dt(cv,"vtkRenderer"),extend:cv};const dv=Object.create(null);function pv(e,t){dv[e]=t}function fv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dv[e]&&dv[e](t)}function gv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}const mv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers","childRenderWindows"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),gv(e,t)}var vv={newInstance:jt.newInstance(hv,"vtkRenderWindow"),extend:hv,registerViewConstructor:pv,listViewAPIs:function(){return Object.keys(dv)},newAPISpecificView:fv};const yv={Unknown:0,LeftController:1,RightController:2},Tv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var bv={Device:yv,Input:Tv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:xv,Input:Cv}=bv,{vtkWarningMacro:Sv,vtkErrorMacro:Av,normalizeWheel:Iv,vtkOnceErrorMacro:wv}=jt,Pv={ctrlKey:!1,altKey:!1,shiftKey:!1},Ov={"xr-standard":[Cv.Trigger,Cv.Grip,Cv.TrackPad,Cv.Thumbstick,Cv.A,Cv.B]},Rv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Mv(e){e.cancelable&&e.preventDefault()}function Ev(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function Dv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Av("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Sv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Mv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Mv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Mv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Sv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Mv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Av(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Sv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Av("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Sv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?xv.LeftController:xv.RightController,input:Ov[s.mapping]&&Ov[s.mapping][r]?Ov[s.mapping][r]:Cv.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?xv.LeftController:xv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Mv(n);const r={...Iv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Av(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);if(2===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Ev(o);e.recognizeGesture("TouchEnd",t);const a={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Rv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void wv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const Vv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),Rv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),Dv(e,t)}var Bv={newInstance:jt.newInstance(Lv,"vtkRenderWindowInteractor"),extend:Lv,handledEvents:Rv,...bv};const{vtkErrorMacro:Nv,VOID:_v}=jt;function Fv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Bv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):_v),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Nv("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const kv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorObserver"),extend:Gv,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},zv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Wv}=zv,Hv={Rotate:Wv.IS_ROTATE,Pan:Wv.IS_PAN,Spin:Wv.IS_SPIN,Dolly:Wv.IS_DOLLY,CameraPose:Wv.IS_CAMERA_POSE,WindowLevel:Wv.IS_WINDOW_LEVEL,Slice:Wv.IS_SLICE};function jv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Hv).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Wv.IS_NONE&&(t.state=Hv[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Hv[n]&&(t.state=Wv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Kv={state:Wv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Uv.extend(e,t,n),jt.setGet(e,t,["focusedRenderer"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkInteractorStyle"),extend:$v,...zv};const{States:Xv}=zv;function Yv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case Xv.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad?!n||n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad||t.state!==Xv.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===Xv.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case Xv.IS_DOLLY:e.endDolly();break;case Xv.IS_PAN:e.endPan();break;case Xv.IS_SPIN:e.endSpin();break;case Xv.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const Zv={motionFactor:10,zoomFactor:10};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),qv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Yv(e,t)}var Jv={newInstance:jt.newInstance(Qv,"vtkInteractorStyleTrackballCamera"),extend:Qv};function ey(e){return e}function ty(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>ty(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var ny=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?ty:ey,o=new URLSearchParams(t);return o.forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};function ry(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const oy={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),ry(e,t)}var iy={newInstance:jt.newInstance(ay,"vtkRenderPass"),extend:ay};const{Representation:sy}=ms,{vtkErrorMacro:ly}=jt;function cy(e){const t=yd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function uy(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ns.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ns.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",sy.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Kd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Kd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Kd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||ly("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||ly("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?cy:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const dy={framebuffer:null,copyShader:null,tris:null};function py(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dy,n),iy.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),jt.get(e,t,["framebuffer"]),uy(e,t)}var fy={newInstance:jt.newInstance(py,"vtkOpenGLOrderIndependentTranslucentPass"),extend:py};function gy(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=ef.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=fy.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const my={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),iy.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkForwardPass"),extend:hy},yy=n(594),Ty=n.n(yy);const by=["lastShaderProgramBound","context","_openGLRenderWindow"];function xy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=yd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=yd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=yd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=yd.substitute(l,"varying","out").result,o=yd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=yd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=yd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:yd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Ty().hash(o);if(!(a in t.shaderPrograms)){const o=yd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const Cy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,by),jt.moveToProtected(e,t,["openGLRenderWindow"]),xy(e,t)}var Ay={newInstance:jt.newInstance(Sy,"vtkShaderCache"),extend:Sy};const{vtkErrorMacro:Iy}=jt;function wy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&Iy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const Py={context:null,numberOfTextureUnits:0,textureUnits:0};function Oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),wy(e,t)}var Ry={newInstance:jt.newInstance(Oy,"vtkOpenGLTextureUnitManager"),extend:Oy};function My(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ey={size:void 0,selector:void 0};function Dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),My(e,t)}var Vy={newInstance:jt.newInstance(Dy,"vtkRenderWindowViewNode"),extend:Dy};const{vtkDebugMacro:Ly,vtkErrorMacro:By}=jt,Ny={position:"absolute",top:0,left:0,width:"100%",height:"100%"},_y=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Fy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ky=0;const Gy=[];function Uy(e){e.preventDefault()}function zy(e,t){let n;function r(){return n||(n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n}t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Uy,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const o=[0,0];let a;e.onModified((function(){t.renderable&&(t.size[0]===o[0]&&t.size[1]===o[1]||(o[0]=t.size[0],o[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ky++,Gy.forEach((e=>e(ky)))),t.textureUnitManager=Ry.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&By("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},n=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(n=t.canvas.getContext("webgl2",e),n&&(t.webgl2=!0,Ly("using webgl2"))),n||(Ly("using webgl1"),n=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(n,r())},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=iy.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?By("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case Cs.CHAR:case Cs.SIGNED_CHAR:case Cs.UNSIGNED_CHAR:return 1;case n:case r:case Cs.UNSIGNED_SHORT:case Cs.SHORT:case Cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case Cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&Cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&Cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ny,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=a)return a;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return a=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Fy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Fy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Fy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Fy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Fy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Fy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Fy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=xf.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((()=>{t.context&&(ky--,Gy.forEach((e=>e(ky)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Uy),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const i=e.setSize;e.setSize=(t,n)=>{const r=i(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null),t._graphicsResources.get(n)?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))};const s={...e};_y.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):s[n](...arguments)}}))}const Wy={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Hy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),Vy.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=xf.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.shaderCache=Ay.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=vy.newInstance(),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),jt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"imageReady"),jt.event(e,t,"windowResizeEvent"),zy(e,t)}),"vtkOpenGLRenderWindow");function jy(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}pv("WebGL",Hy),rn("vtkRenderWindow",Hy);const Ky={device:null,handle:null};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),jy(e,t)}var qy={newInstance:jt.newInstance($y,"vtkWebGPUShaderModule"),extend:$y};function Xy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=qy.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const Yy={shaderModules:null,device:null,window:null};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Xy(e,t)}var Qy={newInstance:jt.newInstance(Zy,"vtkWebGPUShaderCache"),extend:Zy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function Jy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const eT={device:null,handle:null,label:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),Jy(e,t)}var nT={newInstance:jt.newInstance(tT),extend:tT};function rT(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const oT={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function aT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oT,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),rT(e,t)}var iT={newInstance:Dt(aT,"vtkWebGPUPipeline"),extend:aT};function sT(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Qy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Qy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Qy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const lT={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),sT(e,t)}var uT={newInstance:jt.newInstance(cT,"vtkWebGPUShaderDescription"),extend:cT};const dT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var pT=function(e){return!e||e.length<6?0:e in dT==1?dT[e]:(et(`unknown format ${e}`),null)},fT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},gT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},mT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},hT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},vT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function yT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function TT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(yT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=mT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const bT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function xT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),TT(e,t)}var CT={newInstance:Dt(xT,"vtkWebGPUVertexInput"),extend:xT};const ST="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",AT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function IT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=uT.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=uT.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=iT.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const wT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=CT.newInstance(),t.bindGroup=nT.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||AT,t.vertexShaderTemplate=t.vertexShaderTemplate||ST,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),IT(e,t)}var OT={newInstance:jt.newInstance(PT,"vtkWebGPUSimpleMapper"),extend:PT};function RT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const MT={};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),OT.extend(e,t,n),RT(e,t)}var DT={newInstance:jt.newInstance(ET,"vtkWebGPUFullScreenQuad"),extend:ET};const VT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function LT(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<VT.length;n++)e[VT[n]]=function(){return t.handle[VT[n]](...arguments)}}const BT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),LT(e,t)}var _T={newInstance:Dt(NT,"vtkWebGPURenderEncoder"),extend:NT},FT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const kT=["getMappedRange","mapAsync","unmap"];function GT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<kT.length;n++)e[kT[n]]=function(){return t.handle[kT[n]](...arguments)}}const UT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function zT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,UT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),GT(e,t)}var WT={newInstance:jt.newInstance(zT),extend:zT,...FT};const{Representation:HT}=ms,{PrimitiveTypes:jT}=FT;class KT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function $T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function qT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=$T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=$T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=$T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=$T(n,o,t),n.ibo[n.iboId++]=a}function XT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let YT;const ZT=new Uint32Array(1),QT=new Uint32Array(2),JT=new Uint32Array(3),eb={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)ZT[0]=t[n+a],YT(ZT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)QT[0]=t[n+a],QT[1]=t[n+(a+1)%e],YT(QT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o);for(let a=0;a<e-2;a++)QT[0]=t[n+a],QT[1]=t[n+a+2],YT(QT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n],JT[1]=t[n+a+1],JT[2]=t[n+a+2],YT(JT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n+a],JT[1]=t[n+a+1+a%2],JT[2]=t[n+a+1+(a+1)%2],YT(JT,r,o)}};function tb(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case jT.Points:return"points";case jT.Lines:return"lines";case jT.Triangles:case jT.TriangleEdges:return"polys";case jT.TriangleStripEdges:case jT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new KT};let d=null;d=o===HT.POINTS||r===jT.Points?eb.anythingToPoints:o===HT.WIREFRAME||r===jT.Lines?eb[`${l}ToWireframe`]:eb[`${l}ToSurface`],YT=XT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),YT=qT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const nb={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nb,n),WT.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),tb(e,t)}var ob={newInstance:jt.newInstance(rb),extend:rb,...FT};const{BufferUsage:ab}=FT,{vtkErrorMacro:ib}=Kt,{VtkDataTypes:sb}=Ns;function lb(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function cb(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function ub(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===ab.Index&&(n=ob.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=WT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===ab.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===ab.PointArray){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=lb(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===ab.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=cb(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=lb(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===ab.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case sb.UNSIGNED_CHAR:t="uint8";break;case sb.FLOAT:t="float32";break;case sb.UNSIGNED_INT:t="uint32";break;case sb.INT:t="sint32";break;case sb.DOUBLE:t="float32";break;case sb.UNSIGNED_SHORT:t="uint16";break;case sb.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ib(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:ab.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=WT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const db={device:null,fullScreenQuadBuffer:null};function pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,db,n),yt(e,t),At(e,t,["device"]),ub(e,t)}var fb={newInstance:Dt(pb),extend:pb,...FT};function gb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const mb={device:null,handle:null,label:null,options:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),gb(e,t)}var vb={newInstance:jt.newInstance(hb),extend:hb};function yb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vb.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const Tb={texture:null,handle:null,sampler:null,label:null};function bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),yb(e,t)}var xb={newInstance:jt.newInstance(bb),extend:bb};const{BufferUsage:Cb}=fb;function Sb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=pT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Vd.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Pu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:Cb.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:Cb.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=pT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>pT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=xb.newInstance({label:n});return o.create(e,r),o}}const Ab={device:null,handle:null,buffer:null,ready:!1,label:null};function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ab,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),Sb(e,t)}var wb={newInstance:jt.newInstance(Ib),extend:Ib};function Pb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=wb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=_T.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const Ob={renderEncoder:null,colorTexture:null,depthTexture:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Pb(e,t)}var Mb={newInstance:jt.newInstance(Rb,"vtkWebGPUOpaquePass"),extend:Rb};function Eb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=wb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=wb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=DT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=_T.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=_T.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const Db={colorTextureView:null,depthTextureView:null};function Vb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Db,n),iy.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),Eb(e,t)}var Lb={newInstance:jt.newInstance(Vb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Vb};const{BufferUsage:Bb}=fb,{vtkErrorMacro:Nb}=jt;function _b(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Nb(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:hT(n),offset:-1,nativeType:vT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Bb.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Fb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),_b(e,t)}var Gb={newInstance:jt.newInstance(kb,"vtkWebGPUUniformBuffer"),extend:kb};const{BufferUsage:Ub}=fb,{vtkErrorMacro:zb}=jt;function Wb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void zb(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=hT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:vT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Ub.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Hb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Wb(e,t)}var Kb={newInstance:jt.newInstance(jb,"vtkWebGPUStorageBuffer"),extend:jb};const $b="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",qb=new Float64Array(16),Xb=new Float64Array(16);function Yb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===zg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Qy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Qy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Qy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===zg.COMPOSITE_BLEND?l=!0:n===zg.MAXIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.MINIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.AVERAGE_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.ADDITIVE_INTENSITY_BLEND&&(a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Qy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(qb),b(qb,qb,o);const p=n.getMatrix();m(Xb,p),h(Xb,Xb),T(qb,Xb,qb);const f=d.getWorldToIndex();T(qb,f,qb);const v=d.getDimensions();g(Xb),x(Xb,Xb,[1/v[0],1/v[1],1/v[2]]),T(qb,Xb,qb);for(let t=0;t<16;t++)a[16*e+t]=qb[t];h(qb,qb);for(let t=0;t<4;t++)i[16*e+4*t]=qb[4*t],i[16*e+4*t+1]=qb[4*t+1],i[16*e+4*t+2]=qb[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=pT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vb.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Zb={volumes:null,rowLength:1024,lastVolumeLength:0};function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zb,n),DT.extend(e,t,n),t.fragmentShaderTemplate=$b,t.UBO=Gb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Kb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Kb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),Yb(e,t)}var Jb={newInstance:jt.newInstance(Qb,"vtkWebGPUVolumePassFSQ"),extend:Qb};const{Representation:ex}=ms,{BufferUsage:tx,PrimitiveTypes:nx}=fb,rx=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],ox="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function ax(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=Jb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=DT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Gb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:tx.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:nx.Triangles,representation:ex.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:tx.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+rx[e][0],l[n++]=r+rx[e][1],l[n++]=r+rx[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=_T.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=wb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=wb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=wb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=_T.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=_T.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=_T.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const ix={colorTextureView:null,depthTextureView:null,volumes:null};function sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ix,n),iy.extend(e,t,n),t._mapper=OT.newInstance(),t._mapper.setFragmentShaderTemplate(ox),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Cu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),ax(e,t)}var lx={newInstance:jt.newInstance(sx,"vtkWebGPUVolumePass"),extend:sx};function cx(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Mb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Lb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=lx.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=_T.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vb.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=DT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=xb.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const ux={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ux,n),iy.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),cx(e,t)}var px={newInstance:jt.newInstance(dx,"vtkForwardPass"),extend:dx};const{VtkDataTypes:fx}=Ns;function gx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case fx.UNSIGNED_CHAR:e.format+="8unorm";break;case fx.FLOAT:case fx.UNSIGNED_INT:case fx.INT:case fx.DOUBLE:case fx.UNSIGNED_SHORT:case fx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=wb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const mx={handle:null,device:null};function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mx,n),jt.obj(e,t),jt.setGet(e,t,["device"]),gx(e,t)}var vx={newInstance:jt.newInstance(hx),extend:hx};class yx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function Tx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const bx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new yx,t.shaderCache=Qy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=fb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=vx.newInstance(),t.textureManager.setDevice(e),t.pipelines={},Tx(e,t)}var Cx={newInstance:Dt(xx,"vtkWebGPUDevice"),extend:xx};function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=wb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=_T.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const Ax={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelectionPass"),extend:Ix};const{SelectionContent:Px,SelectionField:Ox}=of,{FieldAssociations:Rx}=ll,{vtkErrorMacro:Mx}=jt;function Ex(e){return`${e.propID} ${e.compositeID}`}function Dx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Vx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Dx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Dx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Vx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Vx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Vx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Vx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Vx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Lx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Mx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=WT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=WT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Vx(e,[n,t],0,u);if(r){const t=Ex(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=of.newInstance();switch(i.setContentType(Px.INDICES),e){case Rx.FIELD_ASSOCIATION_CELLS:i.setFieldType(Ox.CELL);break;case Rx.FIELD_ASSOCIATION_POINTS:i.setFieldType(Ox.POINT);break;default:Mx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Bx={};function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),Yp.extend(e,t,n),t._selectionPass=wx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Lx(e,t)}var _x={newInstance:jt.newInstance(Nx,"vtkWebGPUHardwareSelector"),extend:Nx};const Fx=Object.create(null);function kx(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Gx={};function Ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gx,n),t.overrides=Fx,tn.extend(e,t,n),kx(0,t)}var zx={newInstance:jt.newInstance(Ux,"vtkWebGPUViewNodeFactory"),extend:Ux};const{vtkErrorMacro:Wx}=jt,Hx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function jx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Wx("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Wx("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=Cx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=iy.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Hx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=WT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Vd.fromHalf(r.colorValues[o]),s[n+1]=255*Vd.fromHalf(r.colorValues[o+1]),s[n+2]=255*Vd.fromHalf(r.colorValues[o+2]),s[n+3]=255*Vd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=_x.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Kx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const $x=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Vy.extend(e,t,n),t.myFactory=zx.newInstance(),t.renderPasses[0]=px.newInstance(),t.selector||(t.selector=_x.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),jx(e,t)}),"vtkWebGPURenderWindow");var qx;pv("WebGPU",$x),qx=$x,Fx.vtkRenderWindow=qx;const Xx=ny(),Yx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Zx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Qx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Jx(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Qx(t.container,t.containerStyle||Yx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=vv.newInstance(),t.renderer=uv.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Xx.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Bv.newInstance(),t.interactor.setInteractorStyle(Jv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Qx(t.controlContainer,t.controlPanelStyle||Zx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const eC={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function tC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eC,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Jx(e,t)}var nC={newInstance:jt.newInstance(tC),extend:tC},rC={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:oC,Scale:aC}=rC,{ScalarMappingTarget:iC}=El,{vtkDebugMacro:sC,vtkErrorMacro:lC,vtkWarningMacro:cC}=jt;function uC(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function dC(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function pC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];uC(o,i),uC(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=dC(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=dC(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function fC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return lC("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return lC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===aC.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Eo(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===oC.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===oC.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===oC.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===oC.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return lC("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(lC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return lC("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void lC("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):sC("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void cC("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===iC.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===iC.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===iC.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===iC.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=oC[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(lC(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=oC.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const gC={clamping:!0,colorSpace:oC.RGB,hSVWrap:!0,scale:aC.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function mC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gC,n),El.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:oC},{type:"enum",name:"scale",enum:aC}]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),fC(e,t)}var hC={newInstance:jt.newInstance(mC,"vtkColorTransferFunction"),extend:mC,...rC},vC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:yC,ScaleModes:TC}=vC,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(yC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(yC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(yC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(yC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(TC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(TC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(TC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(TC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===TC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(bC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Wi.getCorners(l,c),t.bounds[0]=Wi.INIT_BOUNDS[0],t.bounds[1]=Wi.INIT_BOUNDS[1],t.bounds[2]=Wi.INIT_BOUNDS[2],t.bounds[3]=Wi.INIT_BOUNDS[3],t.bounds[4]=Wi.INIT_BOUNDS[4],t.bounds[5]=Wi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case yC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case yC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case yC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case TC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case TC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case TC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const CC={orient:!0,orientationMode:yC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:TC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,CC,n),uc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkGlyph3DMapper"),extend:SC,...vC};const{vtkErrorMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(IC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return IC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return IC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return IC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const PC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkPiecewiseFunction"),extend:OC};const{InterpolationType:MC,OpacityMode:EC}=Ug,{vtkErrorMacro:DC}=jt;function VC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(DC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=RC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=hC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=RC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return DC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(DC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(MC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(MC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(MC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(MC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const LC={colorMixPreset:null,independentComponents:!0,interpolationType:MC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,LC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:EC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}jt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeProperty"),extend:BC,...Ug};const{vtkDebugMacro:_C}=jt;function FC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=NC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){_C("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const kC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function GC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kC,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),FC(e,t)}var UC={newInstance:jt.newInstance(GC,"vtkVolume"),extend:GC};const{BlendMode:zC,FilterMode:WC}=Wg,HC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=RC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function jC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(zC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(zC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(zC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(zC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(zC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(zC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(zC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(WC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(WC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(WC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(WC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Eo(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const KC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:zC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:WC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function $C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KC,n),zs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),jC(e,t)}var qC={newInstance:jt.newInstance($C,"vtkVolumeMapper"),extend:$C,...HC};const{InterpolationType:XC}=pg,{vtkErrorMacro:YC}=jt;function ZC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return YC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(YC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(XC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(XC.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(XC,t.interpolationType)}const QC={independentComponents:!1,interpolationType:XC.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function JC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,QC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),ZC(e,t)}var eS={newInstance:jt.newInstance(JC,"vtkImageProperty"),extend:JC};const{vtkDebugMacro:tS}=jt;function nS(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=eS.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){tS("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Wi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Wi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Wi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const rS={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...Wi.INIT_BOUNDS]};function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rS,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),jt.getArray(e,t,["bounds"],6),nS(e,t)}var aS={newInstance:jt.newInstance(oS,"vtkImageSlice"),extend:oS};function iS(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const sS={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var lS=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sS,n),zs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),iS(e,t)};function cS(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ii.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:uS,otherStaticMethods:dS}=Kl,{SlicingMode:pS}=yg;function fS(e,t){function n(){let n;switch(t.slicingMode){case pS.X:n=0;break;case pS.Y:n=1;break;case pS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case pS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case pS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case pS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case pS.I:l=Ma(a[0],i[0],i[1]);break;case pS.J:l=Ma(a[1],i[2],i[3]);break;case pS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case pS.I:case pS.J:case pS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case pS.X:e.setSlice(r[0]);break;case pS.Y:e.setSlice(r[1]);break;case pS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(pS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(pS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(pS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(pS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(pS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(pS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case pS.X:n[0]=1;break;case pS.Y:n[1]=1;break;case pS.Z:n[2]=1;break;case pS.I:ea(r,[1,0,0],n);break;case pS.J:ea(r,[0,1,0],n);break;case pS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==pS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case pS.I:r[0]=a,r[1]=a;break;case pS.J:r[2]=a,r[3]=a;break;case pS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case pS.I:a[0]=s-r,a[1]=s+r;break;case pS.J:a[2]=s-r,a[3]=s+r;break;case pS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const gS={slicingMode:pS.NONE,closestIJKAxis:{ijkMode:pS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function mS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gS,n),lS(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Kl.implementCoincidentTopologyMethods(e,t),fS(e,t)}var hS={newInstance:jt.newInstance(mS,"vtkImageMapper"),extend:mS,...uS,...dS,...yg};const{vtkErrorMacro:vS}=jt;function yS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function TS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void vS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Cu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Xs.SINGLE?s=Cs.FLOAT:t.outputPointsPrecision===Xs.DOUBLE&&(s=Cs.DOUBLE);const v=Sc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ns.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ns.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ns.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),yS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),yS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),yS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),yS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const bS={outputPointsPrecision:Xs.DEFAULT};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkAppendPolyData"),extend:xS};function SS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Kf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Cu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const AS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function IS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),SS(e,t)}var wS={newInstance:jt.newInstance(IS,"vtkConeSource"),extend:IS};function PS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ns.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ns.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Kf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Cu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const OS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function RS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),PS(e,t)}var MS={newInstance:jt.newInstance(RS,"vtkCylinderSource"),extend:RS};function ES(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=MS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();jf().rotateZ(-90).apply(a).apply(i);const s=wS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Kf().translate(1-.5*t.tipLength,0,0).apply(c);const u=CS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Kf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Kf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Kf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const DS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function VS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),ES(e,t)}var LS={newInstance:jt.newInstance(VS,"vtkArrowSource"),extend:VS};function BS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];jf().translate(...n).apply(e.getPoints().getData())}function NS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],jf().translate(...o).apply(e.getPoints().getData())}function _S(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ns.newInstance({name:"color",numberOfComponents:3,values:a}))}function FS(e,t){t.classHierarchy.push("vtkAxesActor");const n=uc.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=LS.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?BS(r):NS(r,0,e.invert),_S(r,...e.color),e={...t.config,...t.yConfig};const o=LS.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?BS(o):NS(o,1,e.invert),_S(o,...e.color),e={...t.config,...t.zConfig};const a=LS.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?BS(a):NS(a,2,e.invert),_S(a,...e.color);const i=CS.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=jt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}function kS(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}function GS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,kS(n)),jt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),FS(e,t)}var US={newInstance:jt.newInstance(GS,"vtkAxesActor"),extend:GS};const zS="resetcamera",WS="orientation",HS={MODE_RESET_CAMERA:zS,MODE_ORIENTATION:WS,MODE_SAME:"same"};function jS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===WS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===zS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const KS={mode:WS,focalPoint:[0,0,0],distance:6.8,active:!0};function $S(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),jS(e,t)}var qS={newInstance:Dt($S,"vtkCameraSynchronizer"),extend:$S,SynchronizationMode:HS};const XS={},YS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=qS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:qS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ZS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;XS[r]||(XS[r]={});const o=XS[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=qS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];YS[e.type]?o[r]=new YS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const QS={},JS=/instance:\${([^}]+)}/,eA={},tA=[],nA={},rA={vtkPoints:Sc,vtkCellArray:vc,vtkDataArray:Ns};function oA(e){return e.map((e=>JS.exec(e))).filter((e=>e)).map((e=>e[1]))}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),aA(e,t)})),t}function iA(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=QS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function sA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=QS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function lA(){Object.keys(QS).forEach((e=>{delete QS[e]}))}function cA(){Object.keys(eA).forEach((e=>{delete eA[e]}))}function uA(e){if(1===e[1].length)return-1===tA.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===tA.indexOf(e[1][n]);return t}function dA(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(nA[r]){const{key:n,value:o}=nA[r];if(!n||e.properties[n]===o)return void tA.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=sA(r,{managedInstanceId:t}),n.registerInstance(t,o)),iA(r,o,e,n)})),t.calls&&t.calls.filter(uA).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=JS.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=rA[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function pA(e,t,n){eA[t.id]||dA(e,t,n),eA[t.id]=!0}function fA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function gA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function mA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=gA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=gA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),fA(t.getPointData(),i.pointData),fA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=dA(t,s,r);return r.end(),l}}const hA=mA(["points","polys","verts","lines","strips"]),vA=mA([]);function yA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dA;sA||iA?QS[e]={build:t,update:n}:delete QS[e]}const TA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},bA={vtkAxesActor:{build:US.newInstance,update:dA},vtkRenderWindow:{build:vv.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(uA).filter((e=>"removeRenderer"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),dA(e,t,n),ZS(e,t,n)}},vtkRenderer:{build:uv.newInstance,update:function(e,t,n){dA(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=aA(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(uA).filter((e=>"removeViewProp"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:Nl.newInstance,update:dA},vtkCamera:{build:$h.newInstance,update:pA},vtkPolyData:{build:Cu.newInstance,update:hA},vtkImageData:{build:vl.newInstance,update:vA},vtkMapper:{build:uc.newInstance,update:dA},vtkGlyph3DMapper:{build:AC.newInstance,update:dA},vtkProperty:{build:ms.newInstance,update:dA},vtkActor:{build:bs.newInstance,update:dA},vtkLight:{build:Zh.newInstance,update:dA},vtkColorTransferFunction:{build:hC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Pu.newInstance,update:dA},vtkVolume:{build:UC.newInstance,update:dA},vtkVolumeMapper:{build:qC.newInstance,update:dA},vtkVolumeProperty:{build:NC.newInstance,update:dA},vtkImageSlice:{build:aS.newInstance,update:dA},vtkImageMapper:{build:hS.newInstance,update:dA},vtkImageProperty:{build:eS.newInstance,update:dA},vtkPiecewiseFunction:{build:RC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:$u.newInstance,update:dA},vtkScalarBarActor:{build:Fp.newInstance,update:dA}};function xA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&lA(),Object.keys(bA).forEach((e=>{const t=bA[e];yA(e,t.build,t.update)}))}function CA(){Object.keys(TA).forEach((e=>{TA[e].forEach((t=>{QS[t]=QS[e]}))}))}xA(),CA(),nA.vtkPVLight={};var SA={build:sA,update:iA,genericUpdater:dA,oneTimeGenericUpdater:pA,setTypeMapping:yA,clearTypeMapping:lA,getSupportedTypes:function(){return Object.keys(QS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return cA();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete eA[e]})),r},updateRenderWindow:function(e,t,n){return iA("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){nA[e]={key:t,value:n}},setDefaultMapping:xA,applyDefaultAliases:CA,alwaysUpdateCamera:function(){yA("vtkCamera",$h.newInstance),CA()}};const AA={};function IA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Wm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function wA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function PA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Et(t,n,"progressEvent"),Et(t,n,"progressDone"),t}function OA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function RA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=AA[e];return t||(t={...IA(),...wA(),...PA(),...OA()},AA[e]=t),t}function MA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),SA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){SA.clearOneTimeUpdaters(a())}}}function EA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=RA(t.synchronizerContextName));const n=MA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const DA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function VA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DA,n),vv.extend(e,t),bt(e,t,["synchronizerContext"]),EA(e,t)}var LA={newInstance:Dt(VA,"vtkSynchronizableRenderWindow"),extend:VA,getSynchronizerContext:RA,setSynchronizerContext:function(e,t){AA[e]=t},clearSynchronizerContext:function(e){if(e&&AA[e]&&delete AA[e],!e){const e=Object.keys(AA);for(let t=0;t<e.length;t++)delete AA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=MA(e,RA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:wA,createArrayHandler:IA,createProgressHandler:PA,createSceneMtimeHandler:OA,vtkObjectManager:SA};const{vtkErrorMacro:BA,vtkDebugMacro:NA}=jt;let _A=0;function FA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function kA(e){return"/"===e[0]?e.substr(1):e}const GA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=FA(kA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=FA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=kA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=FA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Mh(Ph(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Wm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(NA(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&BA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--_A&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};jm("html",(e=>GA));const{vtkErrorMacro:UA,vtkDebugMacro:zA}=jt;function WA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const HA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new $m(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Oh)return Oh.encode(e);var o=e.length,a=new $m(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new $m(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return hh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Lh(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||UA("ERROR!!! zip not ready...");const u=WA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Mh(Ph(new Uint8Array(e.buffer))):e.buffer=Ph(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Nh!==e.ref.encode&&Nh&&(zA(`Swap bytes of ${e.name}`),_h(e.buffer,xs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&UA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Mh(Ph(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Mh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Mh(Ph(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Mh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Mh(Lh(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Mh(s))},fetchImage(e,n){const a=WA(n);t||UA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=zm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Ph(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};jm("zip",(e=>HA(e)));var jA=n(892),KA=n.n(jA),$A=n(760),qA=n.n($A),XA=n(311),YA=n.n(XA),ZA=n(192),QA=n.n(ZA),JA=n(60),eI=n.n(JA),tI=n(865),nI=n.n(tI),rI=n(34),oI={};oI.styleTagTransform=nI(),oI.setAttributes=QA(),oI.insert=YA().bind(null,"head"),oI.domAPI=qA(),oI.insertStyleElement=eI(),KA()(rI.Z,oI);var aI=rI.Z&&rI.Z.locals?rI.Z.locals:void 0;let iI=!0;function sI(e){e.preventDefault(),e.stopPropagation()}function lI(e,t){iI=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=nC.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=LA.getSynchronizerContext(),a=LA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",aI.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?zh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Km("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):zh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Km("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Wm(t.base64Str),n=Km("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function cI(e){iI=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(aI.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${aI.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){sI(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];lI(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",sI)}const uI=ny();if(uI.url||uI.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(aI.fullScreen),t.style.margin="0",t.style.padding="0"),iI=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>lI(n,uI)))}setTimeout((()=>{iI&&cI()}),100),window.OfflineLocalView={initLocalFileLoader:cI,load:lI}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(819),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>

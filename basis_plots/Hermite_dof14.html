<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},819:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return cI},load:function(){return lI}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return Ee},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],E=r[2],D=Math.hypot(R,M,E);return D<a?null:(R*=D=1/D,M*=D,E*=D,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,P=M*E*s-R*o,O=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),D(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,E=(1-(p+v))*C,D=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=D,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+E*I+L*w),e[14]=n[2]+w-(R*A+D*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],E=t[12],D=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-D)<=a*Math.max(1,Math.abs(h),Math.abs(D))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=Ee,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Et(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Dt(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Et,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Dt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:xt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Et,newInstance:Dt,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>{if(!t._parent)return null;return t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null)},e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=t=>{if(t&&t.length)for(let n=0;n<t.length;++n){const r=t[n];e.addMissingNode(r)}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function En(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Dn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Er=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Dr(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Dr((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Dr((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Er):kr:t instanceof dr?Er:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Eo,ceil:Do,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Ea(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Da=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Eo,ceil:Do,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Ea,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Da,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};function Wa(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{jt.vtkErrorMacro("not implemented")}}const Ha={};function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ha,n),jt.obj(e,t),jt.setGet(e,t,["transform"]),Wa(e,t)}var Ka={newInstance:jt.newInstance(ja,"vtkImplicitFunction"),extend:ja};const $a=1e-6,qa="coincide",Xa="disjoint";function Ya(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Za(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function Qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Ja(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function ei(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*$a:s*$a,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function ti(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<$a){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=qa:o.error=Xa,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const ni={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ya,projectPoint:Za,projectVector:Qa,generalizedProjectPoint:Ja,intersectWithLine:ei,intersectWithPlane:ti,DISJOINT:Xa,COINCIDE:qa};function ri(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ya(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Za(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>Qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Ja(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>ei(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>ti(e,n,t.origin,t.normal)}const oi={normal:[0,0,1],origin:[0,0,0]};function ai(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oi,n),Ka.extend(e,t,n),jt.setGetArray(e,t,["normal","origin"],3),ri(e,t)}var ii={newInstance:jt.newInstance(ai,"vtkPlane"),extend:ai,...ni};const si=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function li(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ci(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ui(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function di(e){return ui(e,si)}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function fi(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)pi(e,...t[n]);else for(let n=0;n<t.length;n+=3)pi(e,...t.slice(n,n+3));return e}function gi(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function mi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function hi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function vi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function yi(e,t,n,r){return!!ci(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function Ti(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function bi(e,t){return e[2*t+1]-e[2*t]}function xi(e){return[bi(e,0),bi(e,1),bi(e,2)]}function Ci(e){return e.slice(0,2)}function Si(e){return e.slice(2,4)}function Ai(e){return e.slice(4,6)}function Ii(e){const t=xi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function wi(e){if(ci(e)){const t=xi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Pi(e){return[e[0],e[2],e[4]]}function Oi(e){return[e[1],e[3],e[5]]}function Ri(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Mi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Ei(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Di(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Mi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return di(n),fi(n,r)}function Vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Li(e,t,n,r){const o=[].concat(si),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Bi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ni(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ii.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function _i(e,t){if(!ci(e)||!ci(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Fi(e,t){if(!ci(e)||!ci(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function ki(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Gi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ii.evaluate(n,t,l)}let i=2;for(;i--&&!(Ri(o[r[i][0]],o[r[i][4]])&&Ri(o[r[i][1]],o[r[i][5]])&&Ri(o[r[i][2]],o[r[i][6]])&&Ri(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ui{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(si))}getBounds(){return this.bounds}equals(e){return li(this.bounds,e)}isValid(){return ci(this.bounds)}setBounds(e){return ui(this.bounds,e)}reset(){return di(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return pi(this.bounds,...t)}addPoints(e){return fi(this.bounds,e)}addBounds(e,t,n,r,o,a){return gi(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return mi(this.bounds,e,t,n)}setMaxPoint(e,t,n){return hi(this.bounds,e,t,n)}inflate(e){return vi(this.bounds,e)}scale(e,t,n){return yi(this.bounds,e,t,n)}getCenter(){return Ti(this.bounds)}getLength(e){return bi(this.bounds,e)}getLengths(){return xi(this.bounds)}getMaxLength(){return Ii(this.bounds)}getDiagonalLength(){return wi(this.bounds)}getMinPoint(){return Pi(this.bounds)}getMaxPoint(){return Oi(this.bounds)}getXRange(){return Ci(this.bounds)}getYRange(){return Si(this.bounds)}getZRange(){return Ai(this.bounds)}getCorners(e){return Mi(this.bounds,e)}computeCornerPoints(e,t){return Ei(this.bounds,e,t)}computeLocalBounds(e,t,n){return Li(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Di(this.bounds,e,t)}computeScale3(e){return Vi(this.bounds,e)}cutWithPlane(e,t){return Gi(this.bounds,e,t)}intersectBox(e,t,n,r){return Bi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ni(this.bounds,e,t)}intersect(e){return _i(this.bounds,e)}intersects(e){return Fi(this.bounds,e)}containsPoint(e,t,n){return ki(this.bounds,e,t,n)}contains(e){return Fi(this.bounds,e)}}var zi,Wi={newInstance:function(e){const t=e&&e.bounds;return new Ui(t)},equals:li,isValid:ci,setBounds:ui,reset:di,addPoint:pi,addPoints:fi,addBounds:gi,setMinPoint:mi,setMaxPoint:hi,inflate:vi,scale:yi,scaleAboutCenter:function(e,t,n,r){if(!ci(e))return!1;const o=Ti(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],yi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:Ti,getLength:bi,getLengths:xi,getMaxLength:Ii,getDiagonalLength:wi,getMinPoint:Pi,getMaxPoint:Oi,getXRange:Ci,getYRange:Si,getZRange:Ai,getCorners:Mi,computeCornerPoints:Ei,computeLocalBounds:Li,transformBounds:Di,computeScale3:Vi,cutWithPlane:Gi,intersectBox:Bi,intersectPlane:Ni,intersect:_i,intersects:Fi,containsPoint:ki,contains:function(e,t){return!!Fi(e,t)&&!!ki(e,...Pi(t))&&!!ki(e,...Oi(t))},INIT_BOUNDS:si};function Hi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function ji(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Ki(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function $i(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}zi=new i(4),i!=Float32Array&&(zi[0]=0,zi[1]=0,zi[2]=0,zi[3]=0);var qi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),ji(),ji(),ie();var Xi={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Yi}=Xi;function Zi(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function Qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Zi("pick"),e.hasKey=Zi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Yi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Yi.DISPLAY)}const Ji={allocatedRenderTime:10,coordinateSystem:Yi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp"),extend:es,...Xi};function ns(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=ji();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return N(e,t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=ji();Ki(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);T(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>Wi.getCenter(t.bounds),e.getLength=()=>Wi.getLength(t.bounds),e.getXRange=()=>Wi.getXRange(t.bounds),e.getYRange=()=>Wi.getYRange(t.bounds),e.getZRange=()=>Wi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const rs={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function os(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rs,n),ts.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,ns(e,t)}var as={newInstance:jt.newInstance(os,"vtkProp3D"),extend:os};const is={FLAT:0,GOURAUD:1,PHONG:2},ss={POINTS:0,WIREFRAME:1,SURFACE:2};var ls={Shading:is,Representation:ss,Interpolation:is};const{Representation:cs,Interpolation:us}=ls;function ds(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ps(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ds("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ds("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(us.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(us.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(us.PHONG),e.getInterpolationAsString=()=>jt.enumToString(us,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(cs.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(cs.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(cs.POINTS),e.getRepresentationAsString=()=>jt.enumToString(cs,t.representation)}const fs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:us.GOURAUD,representation:cs.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ps(e,t)}var ms={newInstance:jt.newInstance(gs,"vtkProperty"),extend:gs,...ls};const{vtkDebugMacro:hs}=jt;function vs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ms.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){hs("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const ys={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Ts(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),vs(e,t)}var bs={newInstance:jt.newInstance(Ts,"vtkActor"),extend:Ts};const xs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},Cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ss={DefaultDataType:Cs.FLOAT,DataTypeByteSize:xs,VtkDataTypes:Cs};const{vtkErrorMacro:As}=Kt,{DefaultDataType:Is}=Ss,ws=1e-6;function Ps(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function Os(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ps(r,0,1)}return Ps(e,t<0?0:t,n)}function Rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function Ms(e){return Object.prototype.toString.call(e).slice(8,-1)}const Es={computeRange:Os,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ps,getDataType:Ms,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Ds(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=Os(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ws;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=Ms(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||As("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Vs={name:"",numberOfComponents:1,dataType:Is,rangeTuple:[0,0]};function Ls(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Vs,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=Ms(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Ds(e,t)}const Bs=Dt(Ls,"vtkDataArray");var Ns={newInstance:Bs,extend:Ls,...Es,...Ss};function _s(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Fs={clippingPlanes:[]};var ks=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fs,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),_s(e,t)};function Gs(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Wi.isValid(n)?Wi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Wi.getDiagonalLength(t)}}const Us=e=>({bounds:[...Wi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var zs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Us(n)),ks(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Gs(e,t)};const{vtkErrorMacro:Ws,vtkWarningMacro:Hs}=jt;function js(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Ws("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ns.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Hs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Ws("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ns.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const Ks={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function $s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ks,n),jt.obj(e,t),js(e,t)}var qs={newInstance:jt.newInstance($s,"vtkFieldData"),extend:$s};const Xs={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ys={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Xs,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Zs,AttributeCopyOperations:Qs}=Ys,{vtkWarningMacro:Js}=jt;function el(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Zs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Qs[e]]=Object.keys(Zs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Zs[t]]=!0,e)),[])})),t.copyAttributeFlags[Qs.COPYTUPLE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.INTERPOLATE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.COPYTUPLE][Zs.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ns.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const tl={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tl,n),qs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),el(e,t)}var rl={newInstance:jt.newInstance(nl,"vtkDataSetAttributes"),extend:nl,...Ys};const ol=["pointData","cellData","fieldData"];function al(e,t){t.classHierarchy.push("vtkDataSet"),ol.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=rl.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),ol.forEach((n=>{t[n]=rl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const il={};function sl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,il,n),jt.obj(e,t),jt.setGet(e,t,ol),al(e,t)}var ll={newInstance:jt.newInstance(sl,"vtkDataSet"),extend:sl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const cl={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ul={StructuredType:cl};const{StructuredType:dl}=ul;var pl={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?dl.EMPTY:3===t?dl.XYZ_GRID:2===t?e[0]===e[1]?dl.YZ_PLANE:e[2]===e[3]?dl.XZ_PLANE:dl.XY_PLANE:1===t?e[0]<e[1]?dl.X_LINE:e[2]<e[3]?dl.Y_LINE:dl.Z_LINE:dl.SINGLE_POINT},...ul};const{vtkErrorMacro:fl}=jt;function gl(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return fl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=pl.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)fl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void fl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return fl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case cl.EMPTY:return null;case cl.SINGLE_POINT:break;case cl.X_LINE:o[0]=n;break;case cl.Y_LINE:o[1]=n;break;case cl.Z_LINE:o[2]=n;break;case cl.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case cl.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case cl.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case cl.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:fl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Wi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Wi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Wi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Wi.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Ea(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ea(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return fl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return fl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const ml={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:cl.EMPTY};function hl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ml,n),ll.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),gl(e,t)}var vl={newInstance:jt.newInstance(hl,"vtkImageData"),extend:hl};const yl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Tl={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:yl},bl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:xl,VectorMode:Cl}=Tl,{VtkDataTypes:Sl}=Ns,{ColorMode:Al}=bl,{vtkErrorMacro:Il}=jt;function wl(e){return e}function Pl(e){return Math.floor(255*e+.5)}function Ol(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Cl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Cl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Cl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)Il("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===Al.DEFAULT&&(t.getDataType()===Sl.UNSIGNED_CHAR||t.getDataType()===Sl.UNSIGNED_CHAR_CLAMPED)||n===Al.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Sl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ns.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,xl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,xl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Cl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Cl.MAGNITUDE||1!==c&&1!==s||(i=Cl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Cl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Cl.RGBCOLORS:break;case Cl.MAGNITUDE:default:{const o=Ns.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Pl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Sl.UNSIGNED_CHAR)return n;const i=Ns.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Sl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=wl;switch(n.getDataType()!==Sl.FLOAT&&n.getDataType()!==Sl.DOUBLE||(s=Pl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return Il("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==Al.DEFAULT||n.getDataType()!==Sl.UNSIGNED_CHAR)&&r!==Al.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Rl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Cl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Ml(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rl,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Ol(e,t)}var El={newInstance:jt.newInstance(Ml,"vtkScalarsToColors"),extend:Ml,...Tl};const{vtkErrorMacro:Dl}=jt;function Vl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Dl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==Cs.UNSIGNED_CHAR)return Dl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Bl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ll,n),El.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Vl(e,t)}var Nl={newInstance:jt.newInstance(Bl,"vtkLookupTable"),extend:Bl};const _l={Off:0,PolygonOffset:1};let Fl=_l.PolygonOffset,kl=_l.Off;const Gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Ul(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=kl===e;return kl=e,t}var zl={Resolve:_l,getResolveCoincidentTopologyAsString:function(){return Gl[kl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Fl},getResolveCoincidentTopology:function(){return kl},setResolveCoincidentTopology:Ul,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=Fl===e;return Fl=e,t},setResolveCoincidentTopologyToDefault:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToOff:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Ul(_l.PolygonOffset)}};function Wl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=jt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Hl=["Polygon","Line","Point"],jl={modified:()=>{}};Wl(jl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Hl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Kl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(zl).forEach((t=>{e[t]=zl[t]})),Object.keys(jl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=jl[t]})),Wl(e,t.topologyOffset,Hl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=jl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:jl,otherStaticMethods:zl,CATEGORIES:Hl,Resolve:_l};const $l={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ql={PassTypes:$l};const{FieldAssociations:Xl}=ll,{staticOffsetAPI:Yl,otherStaticMethods:Zl}=Kl,{ColorMode:Ql,ScalarMode:Jl,GetArray:ec}=bl,{VectorMode:tc}=Tl,{VtkDataTypes:nc}=Ns;function rc(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function oc(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function ac(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const ic=new WeakMap;function sc(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(Ql,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(Jl,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Jl.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Jl.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Jl.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Jl.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_FIELD_DATA){const t=e.getFieldData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale();i&&Nl.getLogRange(a,a);const s=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,u=n**3-3,d=4094,p=2,f=r?u:d;t.numberOfColorsInRange=Math.min(Math.max(e,p),f);const g=t.numberOfColorsInRange+3,m=t.numberOfColorsInRange+2,h=r?[Math.min(Math.ceil(g/n**0),n),Math.min(Math.ceil(g/n**1),n),Math.min(Math.ceil(g/n**2),n)]:[m,2,1],v=h[0]*h[1]*h[2],y=new Float64Array(v);y.fill(NaN);const T=t.numberOfColorsInRange,b=T+2,x=[0,0,0],C=a[0],S=a[1]-a[0];for(let e=0;e<b;++e){const t=C+S*(e-1)/(T-1);y[(c=h,(l=x)[0]+c[0]*(l[1]+c[1]*l[2]))]=i?10**t:t,oc(x,h)}const A=Ns.newInstance({numberOfComponents:1,values:y}),I=t.lookupTable.mapScalars(A,t.colorMode,0);t.colorTextureMap=vl.newInstance(),t.colorTextureMap.setDimensions(h),t.colorTextureMap.getPointData().setScalars(I),t.lookupTable.setAlpha(s)}var l,c;const u=t.lookupTable.getVectorMode()===tc.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=ic.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(r-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(r+1)/(p-d),v=e.getData(),y=e.getNumberOfTuples(),T=e.getNumberOfComponents(),b=t<0||t>=T,x=o[2]<=1?2:3,C=Ns.newInstance({numberOfComponents:x,values:new Float32Array(y*x)}),S=C.getData(),A=[0,0,0];ac(A,r+2,o);let I=0,w=0;const P=[.5,.5,.5];for(let e=0;e<y;++e){let e;if(b){let t=0;for(let e=0;e<T;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(I+=T,a&&(e=Nl.applyLogScale(e,n,n)),_a(e))P[0]=A[0],P[1]=A[1],P[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>r&&(t=r+1),ac(P,t,o)}else{P[1]=.49;const t=(e-f)*g;P[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=P[e]}return ic.set(e,{stringHash:l,textureCoordinates:C}),C}(n,u,a,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),i,r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Ql.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Ql.DEFAULT&&e.getDataType()===nc.UNSIGNED_CHAR||t.colorMode===Ql.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=rc("AcquireInvertibleLookupTable"),e.valueToColor=rc("ValueToColor"),e.colorToValue=rc("ColorToValue"),e.useInvertibleColorFor=rc("UseInvertibleColorFor"),e.clearInvertibleColor=rc("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer($l.ID_LOW24),o=e.getRawPixelBuffer($l.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Xl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Xl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===$l.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer($l.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===$l.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer($l.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const lc={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lc,n),zs(e,t,n),jt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Kl.implementCoincidentTopologyMethods(e,t),sc(e,t)}var uc={newInstance:jt.newInstance(cc,"vtkMapper"),extend:cc,...Yl,...Zl,...bl};function dc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function pc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const fc={extractCellSizes:dc,getNumberOfCells:pc};function gc(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=pc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=dc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function mc(e){return{empty:!0,numberOfComponents:1,dataType:Cs.UNSIGNED_INT,...e}}function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ns.extend(e,t,mc(n)),gc(e,t)}var vc={newInstance:jt.newInstance(hc,"vtkCellArray"),extend:hc,...fc};const{vtkErrorMacro:yc}=jt,Tc=[1,-1,1,-1,1,-1];function bc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return yc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Tc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const xc={empty:!0,numberOfComponents:3,dataType:Cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),Ns.extend(e,t,n),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkPoints"),extend:Cc};function Ac(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const Ic={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),jt.obj(e,t),t.points||(t.points=Sc.newInstance()),jt.get(e,t,["points","pointsIds"]),Ac(e,t)}var Pc={newInstance:jt.newInstance(wc,"vtkCell"),extend:wc};function Oc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Pc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Pc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const Rc={array:null,maxId:0,extend:0};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),jt.obj(e,t),Oc(e,t)}var Ec={newInstance:jt.newInstance(Mc,"vtkCellLinks"),extend:Mc};const Dc=0,Vc=1,Lc=2,Bc=3,Nc=4,_c=5,Fc=6,kc=7,Gc=9,Uc=21,zc=41,Wc=42,Hc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],jc={getClassNameFromTypeId:function(e){return e<Hc.length?Hc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Hc.findIndex(e)},isLinear:function(e){return e<Uc||e===zc||e===Wc},hasSubCells:function(e){return e===Fc||e===Nc||e===Lc}};function Kc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Dc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const $c={size:0,maxId:-1,extend:1e3};function qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$c,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Kc(e,t)}var Xc={newInstance:jt.newInstance(qc,"vtkCellTypes"),extend:qc,...jc},Yc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Zc}=Yc;function Qc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function Jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Qc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Zc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Zc.YES_INTERSECTION:Zc.NO_INTERSECTION}const eu={distanceToLine:Qc,intersection:Jc};function tu(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Zc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Qc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Qc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Qc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Qc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const nu={orientations:null};function ru(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nu,n),Pc.extend(e,t,n),jt.setGet(e,t,["orientations"]),tu(e,t)}var ou={newInstance:jt.newInstance(ru,"vtkLine"),extend:ru,...eu,...Yc};function au(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=Sc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=Sc.newInstance(),t.points.shallowCopy(e.getPoints())}}const iu={};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),ll.extend(e,t,n),jt.setGet(e,t,["points"]),au(e,t)}var lu={newInstance:jt.newInstance(su,"vtkPointSet"),extend:su};function cu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function uu(e,t,n,r){cu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const du={computeNormalDirection:cu,computeNormal:uu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];uu(e,t,n,d),uu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ii.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ii.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[E],P[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function pu(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(uu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ii.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=ou.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),cu(l,c,u,d),ii.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=ou.distanceToLine(e,c,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=ou.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=ou.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=ou.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const fu={};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Pc.extend(e,t,n),pu(e,t)}var mu={newInstance:jt.newInstance(gu,"vtkTriangle"),extend:gu,...du};const hu=["verts","lines","polys","strips"],{vtkWarningMacro:vu}=jt,yu={[Bc]:ou,[Nc]:ou,[_c]:mu};function Tu(e,t){t.classHierarchy.push("vtkPolyData"),hu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=vc.newInstance()})),e.getNumberOfCells=()=>hu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),hu.forEach((n=>{t[n]=vc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?Lc:Vc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Nc:Bc,1===t&&vu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=_c;break;case 4:l[n]=Gc;break;default:l[n]=kc}t<3&&vu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Fc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Xc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Vc:case Lc:o=t.verts;break;case Bc:case Nc:o=t.lines;break;case _c:case Gc:case kc:o=t.polys;break;case Fc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||yu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const bu={};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),lu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),Tu(e,t)}var Cu={newInstance:jt.newInstance(xu,"vtkPolyData"),extend:xu};function Su(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const Au={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),Su(e,t)}const wu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Pu={newInstance:jt.newInstance(Iu,"vtkTexture"),extend:Iu,...wu};const Ou=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Ru=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Mu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Eu=[0,1,0,1,0,1,0,1,2,2,2,2],Du=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Vu=new Float64Array(3),Lu=new Float64Array(3),Bu=new Float64Array(3),Nu=new Float64Array(3),_u=new Float64Array(3),Fu=new Float64Array(3),ku=new Float64Array(16);function Gu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Uu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=go().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}function zu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],Vn(Bu,Vu,r),Bu[0]+=.1,Vn(Lu,Bu,o),Pn(_u,Lu,Vu),Bu[0]-=.1,Bu[1]+=.1,Vn(Lu,Bu,o),Pn(Fu,Lu,Vu);for(let e=0;e<3;e++)_u[e]/=.05*u[0],Fu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],a[0]<-.5?On(Bu,_u,a[0]*i-l.width):a[0]>.5?On(Bu,_u,a[0]*i):On(Bu,_u,a[0]*i-l.width/2),wn(Vu,Vu,Bu),On(Bu,Fu,a[1]*i-l.height/2),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Bu,_u,l.width),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Bu,Fu,l.height),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Bu,_u,l.width),Pn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(ku,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Vu[0]=f[3*u],Vu[1]=f[3*u+1],Vu[2]=f[3*u+2],Vn(Bu,Vu,n),Vu[0]=f[3*u+3],Vu[1]=f[3*u+4],Vu[2]=f[3*u+5],Vn(Nu,Vu,n),Pn(Bu,Bu,Nu);const r=[Bu[0],Bu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Wu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],zu(e,t)}),"vtkCubeAxesActorHelper");function Hu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Wi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Vu[s]=t.dataBounds[a]-.1*r*Ou[a][s],Vu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Vu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Bu,Vu,e),Vu[s]=t.dataBounds[a],Vn(Nu,Vu,e),Pn(Bu,Nu,Bu),Mn(Bu,Bu),i=Bu[2]>o,t.camera.getParallelProjection()||(Mn(Nu,Nu),i=En(Nu,Bu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Du[t][0]].length+2*r[Du[t][1]].length,a+=r[Du[t][0]].length+r[Du[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Mu[e][0],l[3*u+2]=Mu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Du[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Du[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Eu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Ru[a][e];if(1===n[d]){const e=Eu[d],n=3*Mu[d][0],p=3*Mu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Du[a][0]]=.5*(t.dataBounds[2*Du[a][0]]+t.dataBounds[2*Du[a][0]+1]),s[3*l+Du[a][1]]=.5*(t.dataBounds[2*Du[a][1]]+t.dataBounds[2*Du[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Ru[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Gu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Gu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Gu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Wi.setBounds(t.bounds,t.gridActor.getBounds()),Wi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function ju(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Wi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Uu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,ju(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=uc.newInstance(),t.polyData=Cu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=bs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Cu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Hu(e,t)}var $u={newInstance:jt.newInstance(Ku,"vtkCubeAxesActor"),extend:Ku,newCubeAxesActorHelper:Wu,defaultGenerateTicks:Uu};function qu(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Xu={};const Yu=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=$u.newCubeAxesActorHelper(),qu(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Yu);const Zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Qu={ObjectType:Zu};const{ObjectType:Ju}=Qu;function ed(e,t){function n(e){switch(e){case Ju.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Ju.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Ju.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const td={objectType:Ju.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,td,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ed(e,t)}var rd={newInstance:jt.newInstance(nd),extend:nd,...Qu};const{vtkErrorMacro:od}=jt;function ad(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=rd.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===ss.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===ss.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,E=0,D=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];E+=n*n;const r=.5*(t[1]+t[0]);D+=r*r}const V=E>0&&(Math.abs(D)/E>1e6||Math.abs(Math.log10(E))>3||0===E&&D>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,T++)C(A[e],A,e+1,T+a.cellOffset);return t.elementCount=w,e.upload(O,Zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,Zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,ji(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):od("Wrong type for coordScale, expected vec3 or null"):od("Wrong type for coordShift, expected vec3 or null")}}const id={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),rd.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),ad(e,t)}var ld={newInstance:jt.newInstance(sd),extend:sd};const{vtkErrorMacro:cd}=jt;function ud(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return cd(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const dd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkShader"),extend:pd};const{vtkErrorMacro:gd}=jt;function md(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(gd(`Links failed: ${t.error}`),0):(gd(t.error),0):(gd(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.fragmentShader.getError()),0):(gd(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return gd(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(gd("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return gd("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const hd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=fd.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=fd.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=fd.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),md(e,t)}var yd={newInstance:jt.newInstance(vd,"vtkShaderProgram"),extend:vd,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function Td(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const bd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function xd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),Td(e,t)}var Cd={newInstance:jt.newInstance(xd,"vtkOpenGLVertexArrayObject"),extend:xd};const Sd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function Ad(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===ss.POINTS||n===Sd.Points?t.context.POINTS:e===ss.WIREFRAME||n===Sd.Lines||n===Sd.TrisEdges||n===Sd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Sd.Points||r.getProperty().getRepresentation()===ss.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Sd.Points?2:t.primitiveType===Sd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const Id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=yd.newInstance(),t.VAO=Cd.newInstance(),t.CABO=ld.newInstance(),Ad(e,t)}var Pd={newInstance:jt.newInstance(wd),extend:wd,primTypes:Sd};const Od={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Rd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Md={Wrap:Od,Filter:Rd};const Ed=new Float32Array(1),Dd=new Int32Array(Ed.buffer);var Vd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Ed[0]=e;const t=Dd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Ld;const{Wrap:Bd,Filter:Nd}=Md,{VtkDataTypes:_d}=Ns,{vtkDebugMacro:Fd,vtkErrorMacro:kd,vtkWarningMacro:Gd}=Kt,{toHalf:Ud}=Vd;function zd(e,t){t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Nd.LINEAR),e.setMagnificationFilter(Nd.LINEAR)):(e.setMinificationFilter(Nd.NEAREST),e.setMagnificationFilter(Nd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Bd.REPEAT),e.setWrapS(Bd.REPEAT),e.setWrapT(Bd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const n=()=>{if(t.minificationFilter!==Nd.LINEAR&&t.magnificationFilter!==Nd.LINEAR||(void 0===Ld&&(Ld=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,y=i.getExtension("WEBGL_lose_context");return y&&y.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Ld))return t.oglNorm16Ext};function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Vd.toHalf(Vd.fromHalf(e[u][l+s+t])*h*(1-v)+Vd.fromHalf(e[u][l+p+t])*h*v+Vd.fromHalf(e[u][c+s+t])*m*(1-v)+Vd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&n())||e!==_d.UNSIGNED_SHORT&&e!==_d.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Gd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Fd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Gd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(r,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(r,o,n(),e.useHalfFloat()),a||(a||(Fd("Unsupported internal texture type!"),Fd(`Unable to find suitable internal format for T=${r} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=r=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case n()&&!o&&_d.SHORT:return t.context.SHORT;case n()&&!o&&_d.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&_d.SHORT:case o&&_d.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case _d.FLOAT:case _d.VOID:default:return t.context.FLOAT}switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case _d.FLOAT:case _d.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Nd.NEAREST:return t.context.NEAREST;case Nd.LINEAR:return t.context.LINEAR;case Nd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Nd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Nd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Nd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Bd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Bd.REPEAT:return t.context.REPEAT;case Bd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==_d.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==_d.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Ud(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=e.updateArrayDataTypeForGL(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(e.updateArrayDataTypeForGL(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=(r,a,i,s)=>(e.getOpenGLDataType(i),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?i===_d.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=r,t.height=a,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(i,n(),e.useHalfFloat()),e.deactivate(),!0):(kd("Failed to determine texture parameters."),!1)),e.create2DFromImage=r=>{if(e.getOpenGLDataType(_d.UNSIGNED_CHAR),e.getInternalFormat(_d.UNSIGNED_CHAR,4),e.getFormat(_d.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const a=!(t._openGLRenderWindow.getWebgl2()||Fo(r.width)&&Fo(r.height)),i=document.createElement("canvas");i.width=a?_o(r.width):r.width,i.height=a?_o(r.height):r.height,t.width=i.width,t.height=i.height;const s=i.getContext("2d");s.translate(0,i.height),s.scale(1,-1),s.drawImage(r,0,0,r.width,r.height,0,0,i.width,i.height);const l=i;return o(_d.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=l&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,l)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,l),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(_d.UNSIGNED_CHAR,n(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Ns.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.updateVolumeInfoForGL=(r,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(n()&&!i&&r===_d.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(n()&&!i&&r===_d.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(r===_d.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(r===_d.FLOAT||i&&(r===_d.SHORT||r===_d.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=(a,i,s,l,c,u)=>{let d=c,p=u;if(!e.updateVolumeInfoForGL(d,l)&&p){const e=a*i*s,n=structuredClone(t.volumeInfo),r=new Float32Array(e*l);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const c=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<l;e++)r[o]=(p[o]-n.offset[e])*c[e],o++;d=_d.FLOAT,p=r}if(e.getOpenGLDataType(d),e.getInternalFormat(d,l),e.getFormat(d,l),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const f=[p],g=r(e.updateArrayDataTypeForGL(d,f,!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(d)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=g[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,g[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,g[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(d,n(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Ns.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=[],g=[];for(let e=0;e<c;++e)f[e]=0,g[e]=1;if(t.volumeInfo={scale:g,offset:f,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw(n,r,i,c,u,d);const m=n*r*i,h=structuredClone(p);let v=(e,t,n,r,o)=>{e[t]=n},y=_d.UNSIGNED_CHAR;if(u===_d.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=_d.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=_d.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===_d.FLOAT||c>=3)&&(T=4096);let b=1,x=1;m>T*T&&(b=Math.ceil(Math.sqrt(m/(T*T))),x=b);let C=Math.sqrt(m)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===_d.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Wd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Bd.CLAMP_TO_EDGE,wrapT:Bd.CLAMP_TO_EDGE,wrapR:Bd.CLAMP_TO_EDGE,minificationFilter:Nd.NEAREST,magnificationFilter:Nd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),zd(e,t)}const jd=Dt(Hd,"vtkOpenGLTexture");var Kd={newInstance:jd,extend:Hd,...Md};rn("vtkTexture",jd);var $d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",qd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Xd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=yd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Yd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=yd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Zd}=ll,{primTypes:Qd}=Pd,{Representation:Jd,Shading:ep}=ms,{ScalarMode:tp}=uc,{Filter:np,Wrap:rp}=Kd,{vtkErrorMacro:op}=Kt,ap={type:"StartEvent"},ip={type:"EndEvent"},{CoordinateSystem:sp}=ts;function lp(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=yd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=yd.substitute(i,"//VTK::Color::Impl",c).result):i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=yd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=yd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=yd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:op("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=yd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=yd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=yd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=yd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=yd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=yd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=yd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Jd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Qd.Points||o.getRepresentation()===Jd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Qd.Lines||o.getRepresentation()===Jd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Qd.Tris&&e!==Qd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Qd.TrisEdges&&e!==Qd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=yd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==$l.ID_LOW24&&t.lastSelectionState!==$l.ID_HIGH24||(a=yd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=yd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=yd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=yd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case $l.ID_LOW24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case $l.ID_HIGH24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=yd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===ep.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||op(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||op("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||op("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===sp.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():$l.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Jd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===$l.ID_LOW24||t.lastSelectionState===$l.ID_HIGH24);for(let i=Qd.Start;i<Qd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Qd.TrisEdges||i===Qd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ip),!t.currentInput)return void op("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==tp.USE_CELL_DATA&&a!==tp.USE_CELL_FIELD_DATA&&a!==tp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===tp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==ep.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Kd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(np.NEAREST),e.setMagnificationFilter(np.NEAREST),e.setWrapS(rp.CLAMP_TO_EDGE),e.setWrapT(rp.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Jd.SURFACE;for(let n=Qd.Start;n<Qd.End;n++)n!==Qd.TrisEdges&&n!==Qd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Jd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const cp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:$l.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=Qd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),lp(e,t)}const dp=Dt(up,"vtkOpenGLPolyDataMapper");var pp={newInstance:dp,extend:up};rn("vtkMapper",dp);const{ColorMode:fp,ScalarMode:gp,GetArray:mp}=bl;function hp(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(fp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(gp,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===gp.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===gp.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===gp.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===gp.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_FIELD_DATA){const t=e.getFieldData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const vp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),ks(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),hp(e,t)}var Tp={newInstance:jt.newInstance(yp,"vtkMapper2D"),extend:yp};const bp=1,{primTypes:xp}=Pd,{ScalarMode:Cp}=Tp,{vtkErrorMacro:Sp}=Kt,Ap={type:"StartEvent"},Ip={type:"EndEvent"};function wp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=xp.Start;e<xp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Ip),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Sp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Cp.USE_CELL_DATA&&a!==Cp.USE_CELL_FIELD_DATA&&a!==Cp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Cp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Sc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[xp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[xp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[xp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[xp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=xp.Start;a<xp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=yd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=yd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=yd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=yd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=yd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=yd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=yd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=yd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=yd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Sp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Sp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Sp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===bp?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Pp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Op=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=xp,t.tmpMat4=g(new Float64Array(16));for(let e=xp.Start;e<xp.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),wp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",Op);const{VectorMode:Rp}=El;function Mp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Ep(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Vp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Mp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Mp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Mp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Rp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ns.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Lp=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=uc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Cu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=bs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Vp(e,t)}),"vtkScalarBarActorHelper");function Bp(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Ep(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dp())}}function Np(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Np(n)),t.autoLayout||(t.autoLayout=Ep(0,t)),t.generateTicks||(t.generateTicks=Dp()),bs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Bp(e,t)}var Fp={newInstance:jt.newInstance(_p,"vtkScalarBarActor"),extend:_p,newScalarBarActorHelper:Lp};function kp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gp={};const Up=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Fp.newScalarBarActorHelper(),kp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Up);const{vtkErrorMacro:zp}=Kt;function Wp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ns.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Hp={context:null};const jp=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Zt.extend(e,t,n),t.openGLTexture=Kd.newInstance(),t.tris=Pd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Wp(e,t)}));rn("vtkSkybox",jp);const{FieldAssociations:Kp}=ll;function $p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const qp={fieldAssociation:Kp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),$p(e,t)}var Yp={newInstance:jt.newInstance(Xp,"vtkHardwareSelector"),extend:Xp};function Zp(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Kd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Rd.LINEAR),r.setMagnificationFilter(Rd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,Cs.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const Qp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Zp(e,t)}var ef={newInstance:Dt(Jp,"vtkFramebuffer"),extend:Jp};function tf(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const nf={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function rf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nf,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),tf(e,t)}var of={newInstance:jt.newInstance(rf,"vtkSelectionNode"),extend:rf,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:af}=ql,{SelectionContent:sf,SelectionField:lf}=of,{FieldAssociations:cf}=ll,{vtkErrorMacro:uf}=jt;function df(e){return`${e.propID} ${e.compositeID}`}function pf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ff(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function gf(e,t){let n=t;return n<<=24,n|=e,n}function mf(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ff(n[0],n[1],e.pixBuffer[af.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ff(n[0],n[1],e.pixBuffer[af.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[af.ID_LOW24]&&0===pf(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area))return a;const s=ff(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area),l=ff(n[0],n[1],e.pixBuffer[af.ID_HIGH24],e.area);return a.attributeID=gf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=mf(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=mf(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=mf(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function hf(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=of.newInstance();switch(l.setContentType(sf.INDICES),e){case cf.FIELD_ASSOCIATION_CELLS:l.setFieldType(lf.CELL);break;case cf.FIELD_ASSOCIATION_POINTS:l.setFieldType(lf.POINT);break;default:uf("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function vf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=mf(e,[n,t],0,u);if(r&&r.valid){const t=df(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return hf(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function yf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return vf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return uf("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=af.MIN_KNOWN_PASS;t.currentPass<=af.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===af.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=af.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===af.ID_HIGH24){if(t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===cf.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===af.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ff(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===af.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===af.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(af,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ff(e[0],e[1],t.pixBuffer[af.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ff(e[0],e[1],t.pixBuffer[af.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[af.ID_LOW24]&&0===pf(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area))return a;const s=ff(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area),l=ff(e[0],e[1],t.pixBuffer[af.ID_HIGH24],t.area);return a.attributeID=gf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=df(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return hf(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const Tf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Yp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),yf(e,t)}var xf={newInstance:jt.newInstance(bf,"vtkOpenGLHardwareSelector"),extend:bf,...ql};const{vtkErrorMacro:Cf}=Kt,{Representation:Sf}=ms,{ObjectType:Af}=rd,{PassTypes:If}=xf,wf={type:"StartEvent"},Pf={type:"EndEvent"};function Of(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(wf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Pf),!t.currentInput)return void Cf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=yd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=yd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=yd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=yd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=yd.substitute(o,"//VTK::Color::Impl",s).result,o=yd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=yd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=yd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=yd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=yd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===Sf.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===If.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Cf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Cf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=rd.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=rd.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=rd.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=rd.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,Af.ARRAY_BUFFER),t.normalBuffer.upload(n,Af.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),Af.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Af.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Rf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Mf=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),pp.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),Of(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",Mf);const{vtkErrorMacro:Ef}=jt;class Df{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Vf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Ef("Invalid or missing input");const r=Cu.newInstance();r.shallowCopy(n);const o=new Df,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(vc.newInstance({values:c,name:"faces"})),t[0]=r}}const Lf={};function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),jt.obj(e,t),jt.algo(e,t,1,1),Vf(e,t)}var Nf={newInstance:jt.newInstance(Bf,"vtkClosedPolyLineToSurfaceFilter"),extend:Bf};const{vtkErrorMacro:_f}=Kt;function Ff(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void _f("Invalid or missing input");if(!t.cutFunction)return void _f("Missing cut function");const o=Cu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const kf={cutFunction:null,cutScalars:null,cutValue:0};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Ff(e,t)}var Uf={newInstance:Dt(Gf,"vtkCutter"),extend:Gf};const zf=e=>e,Wf=1e-6;class Hf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:zf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=En(n,r);return a>=1||(Dn(this.tmp,n,r),Sn(this.tmp)<Wf&&(Dn(this.tmp,[1,0,0],e),Sn(this.tmp)<Wf&&Dn(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var jf=function(){return new Hf(!0)},Kf=function(){return new Hf(!1)};const $f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],qf=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Xf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Cu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Ns.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Ns.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&jf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Kf().translate(...t.center).apply(o),t.matrix){Kf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Kf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Yf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=vc.newInstance({values:Uint16Array.from(qf)}),t._lineCells=vc.newInstance({values:Uint16Array.from($f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),Xf(e,t)}var Qf={newInstance:jt.newInstance(Zf,"vtkCubeSource"),extend:Zf};const{vtkErrorMacro:Jf}=jt;function eg(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Jf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Jf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const tg={};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=Qf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),eg(e,t)}var rg={newInstance:jt.newInstance(ng,"vtkImageDataOutlineFilter"),extend:ng};let og;function ag(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>og({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const ig={preMultiplyFlag:!1,matrix:[...vo]};function sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),ag(e,t)}og=jt.newInstance(sg,"vtkTransform");var lg={newInstance:og,extend:sg};function cg(e,t,n){return e?`${e.getMTime()}-${t}-${n}`:"0"}function ug(e,t){return`${e.getMTime()}A${t.getMTime()}`}const dg={NEAREST:0,LINEAR:1};var pg={InterpolationType:dg};const{vtkErrorMacro:fg}=Kt;function gg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function mg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera());const o=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),o&&!o.isDeleted()&&o!==t._openGLRenderWindow&&n(o),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):fg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.openGLTexture.setMinificationFilter(Rd.LINEAR),t.openGLTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()?.getScalars();if(!a)return;const i=a.getNumberOfComponents();let s=ug(o,a);const l=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(l?.oglObject?.getHandle()&&l?.hash===s)t.openGLTexture=l.oglObject;else{t.openGLTexture=Kd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a),t._openGLRenderWindow.setGraphicsResourceForObject(a,t.openGLTexture,s),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a}const c=r.getProperty(),u=c.getIndependentComponents(),d=u?i:1,p=u?2*d:1,f=c.getRGBTransferFunction();s=cg(f,u,d);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===s)t.colorTexture=g.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*p*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=c.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,s),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const m=c.getPiecewiseFunction();s=cg(m,u,d);const h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===s)t.pwfTexture=h.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),m){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=c.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.pwfTexture,s),m!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=m)}const v=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==v){const e=Ns.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ns.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:fg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",ss.SURFACE,r)}t.VBOBuildString=v,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",gg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",gg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=yd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:fg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=yd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:fg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=yd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=yd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=yd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ii.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();za.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ns.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Cu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ns.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else fg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const hg={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};const vg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=rg.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Cu.newInstance(),t.cutter=Uf.newInstance(),t.lineToSurfaceFilter=Nf.newInstance(),t.transform=lg.newInstance(),bt(e,t,["openGLTexture"]),mg(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",vg);var yg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Tg}=Kt,{SlicingMode:bg}=yg;function xg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function Cg(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=yd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=yd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Tg("Unsupported number of independent coordinates.")}}if(i=yd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=yd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=yd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Tg("Unsupported number of independent coordinates.")}i=yd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=yd.substitute(i,"//VTK::TCoord::Impl",[...xg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Tg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Tg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===bg.NONE&&(i=bg.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Tg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=cg(f,u,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.oglObject?.getHandle()&&m?.hash===g)t.colorTexture=m.oglObject;else{t.colorTexture=Kd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(n*p*3);if(c===dg.NEAREST?(t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST)):(t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR)),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,g),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const h=l.getPiecewiseFunction(),v=cg(h,u,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.oglObject?.getHandle()&&y?.hash===v)t.pwfTexture=y.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===dg.NEAREST?(t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),h){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);h&&(t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,v),h!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(h,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=h)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===bg.I&&(S=x-C[0]),T===bg.J&&(S=x-C[2]),T!==bg.K&&T!==bg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Kd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===dg.NEAREST?(new Set([1,3,4]).has(s)&&i===Cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.NEAREST)):t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST)):(4!==s||i!==Cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Rd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Rd.LINEAR)),t.openGLTexture.setWrapS(Od.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Od.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[bg.X,bg.Y,bg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===bg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===bg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===bg.K||T===bg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Tg("Reformat slicing not yet supported.");t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const m=Ns.newInstance({numberOfComponents:3,values:r});m.setName("points");const h=Ns.newInstance({numberOfComponents:2,values:l});h.setName("tcoords");const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const y=Ns.newInstance({numberOfComponents:1,values:v});t.tris.getCABO().createVBO(y,"polys",ss.SURFACE,{points:m,tcoords:h,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Kd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Sg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const Ag=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),Cg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",Ag);const Ig=0,wg=1,Pg=2,{vtkErrorMacro:Og}=jt;function Rg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.volumeTexture.setMinificationFilter(Rd.NEAREST),t.volumeTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.volumeTexture.setMinificationFilter(Rd.LINEAR),t.volumeTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=o?.getPointData()?.getScalars();if(!i)return;const s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=ug(o,i);if(s?.oglObject?.getHandle()&&s?.hash===l)t.volumeTexture=s.oglObject;else{t.volumeTexture=Kd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],i,t.renderable.getPreferSizeOverAccuracy()),t._openGLRenderWindow.setGraphicsResourceForObject(i,t.volumeTexture,l),i!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(i,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=i}const c=i.getNumberOfComponents(),u=r.getProperty(),d=u.getIndependentComponents(),p=d?c:1,f=d?2*p:1,g=u.getRGBTransferFunction(),m=cg(g,d,p),h=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(h?.oglObject?.getHandle()&&h?.hash===m)t.colorTexture=h.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*f*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),g){const e=new Float32Array(3*n);for(let t=0;t<p;t++){const o=u.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),d)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,f,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}g&&(t._openGLRenderWindow.setGraphicsResourceForObject(g,t.colorTexture,m),g!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(g,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=g)}const v=u.getPiecewiseFunction(),y=cg(v,d,p),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===y)t.pwfTexture=T.oglObject;else{const n=1024,r=n*f,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),v){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<p;++t){const r=u.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),d)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,f,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);v&&(t._openGLRenderWindow.setGraphicsResourceForObject(v,t.pwfTexture,y),v!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(v,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=v)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ns.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ns.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ns.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Ns.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ns.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ns.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",ss.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Og("Unsupported number of independent coordinates.")}}i=yd.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===wg?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Ig:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case wg:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===Pg&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Og("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Og("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Og(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),Rn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),T(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=jt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Mg={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Eg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mg,n),Zt.extend(e,t,n),Xd(e,t,n),jt.algo(e,t,2,0),t.tris=Pd.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),Rg(e,t)}),"vtkOpenGLImageCPRMapper");function Dg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Eg);const Vg={context:null,keyMatrixTime:null,keyMatrices:null};const Lg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),Dg(e,t)}),"vtkOpenGLImageSlice");function Bg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Lg);const Ng={};const _g=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Bg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",_g);const Fg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},kg={FRACTIONAL:0,PROPORTIONAL:1},Gg={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var Ug={InterpolationType:Fg,OpacityMode:kg,ColorMixPreset:Gg};const zg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Wg={BlendMode:zg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Hg,vtkErrorMacro:jg}=Kt;function Kg(e,t){function n(n){[t._scalars,t._scalarOpacityFunc,t._colorTransferFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(r,o)=>{if(r){const r=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const o=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const a=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(a.getActiveCamera()),e.renderPiece(a,o)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.useIndependentComponents=e=>{const n=e.getIndependentComponents(),r=t.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(),o=e.getColorMixPreset();return n&&r>=2||!!o},e.replaceShaderValues=(n,r,o)=>{const a=o.getProperty();let i=n.Fragment;a.getInterpolationType()===Fg.LINEAR&&(i=yd.substitute(i,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===e.isLabelmapOutlineRequired(o)&&(i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),t.renderable.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND&&(i=yd.substitute(i,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const s=t.scalarTexture.getComponents();i=yd.substitute(i,"//VTK::NumComponents",`#define vtkNumComponents ${s}`).result;const l=e.useIndependentComponents(a);l&&(i=yd.substitute(i,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const c=[],u=[];for(let e=0;e<s;e++)a.getOpacityMode(e)===kg.PROPORTIONAL&&c.push(`#define vtkComponent${e}Proportional`),a.getForceNearestInterpolation(e)&&u.push(`#define vtkComponent${e}ForceNearest`);i=yd.substitute(i,"//VTK::vtkProportionalComponents",c.join("\n")).result,i=yd.substitute(i,"//VTK::vtkForceNearestComponents",u.join("\n")).result;const d=function(e){switch(e){case Gg.CUSTOM:return"//VTK::CustomColorMix";case Gg.ADDITIVE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n\n          vec3 scalarInterp1[2];\n          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);\n          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;\n          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;\n          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n          vec4 normalLight1 = normalMat[1];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        float opacity1 = pwfValue1;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          opacity1 *= gof1;\n        #endif\n        float opacitySum = opacity0 + opacity1;\n        if (opacitySum <= 0.0) {\n          return vec4(0.0);\n        }\n\n        // mix the colors and opacities\n        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);\n        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);\n        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;\n        return vec4(mixedColor, min(1.0, opacitySum));\n";case Gg.COLORIZE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n        #endif\n\n        // mix the colors and opacities\n        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);\n        color = applyAllLightning(color, opacity0, posIS, normalLight0);\n        return vec4(color, opacity0);\n";default:return null}}(a.getColorMixPreset());d&&(i=yd.substitute(i,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,i=yd.substitute(i,"//VTK::CustomComponentsColorMix::Impl",d).result);const p=t.currentInput.getSpatialExtent(),f=t.currentInput.getSpacing(),g=new Float64Array(3);In(g,(p[1]-p[0])*f[0],(p[3]-p[2])*f[1],(p[5]-p[4])*f[2]);const m=Sn(g)/e.getCurrentSampleDistance(r);i=yd.substitute(i,"//VTK::MaximumSamplesValue",`${Math.ceil(m)}`).result,i=yd.substitute(i,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lightComplexity}`).result,t.lightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(i=yd.substitute(i,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(i=yd.substitute(i,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&a.getAmbient()>0&&(i=yd.substitute(i,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const h=l?s:1;t.gopacity=!1;for(let e=0;!t.gopacity&&e<h;++e)t.gopacity||=a.getUseGradientOpacity(e);t.gopacity&&(i=yd.substitute(i,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(i=yd.substitute(i,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),i=yd.substitute(i,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=i,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=yd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lightComplexity&&(o=yd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=yd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=yd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=yd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=yd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{const a=o.getProperty();((n,r)=>{let o=0;n.getProperty().getShade()&&t.renderable.getBlendMode()===zg.COMPOSITE_BLEND&&(o=0,t.numberOfLights=0,r.forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===o&&(o=1)),1===o&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(o=2),o<3&&e.getPositional()&&(o=3)}))),o!==t.lightComplexity&&(t.lightComplexity=o,e.modified())})(o,r.getLights());const i=t.scalarTexture.getComponents(),s=[],l=[];for(let e=0;e<i;e++)s.push(a.getOpacityMode(e)),l.push(a.getForceNearestInterpolation(e));const c=t.currentInput.getSpatialExtent(),u=t.currentInput.getSpacing(),d=new Float64Array(3);In(d,(c[1]-c[0])*u[0],(c[3]-c[2])*u[1],(c[5]-c[4])*u[2]);const p=Sn(d)/e.getCurrentSampleDistance(r),f=!!t.zBufferTexture,g={iComps:a.getIndependentComponents(),colorMixPreset:a.getColorMixPreset(),interpolationType:a.getInterpolationType(),useLabelOutline:e.isLabelmapOutlineRequired(o),numComp:i,maxSamples:p,useGradientOpacity:a.getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),hasZBufferTexture:f,opacityModes:s,forceNearestInterps:l};return(0===n.getProgram()?.getHandle()||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime()||!t.previousState||!ke()(t.previousState,g))&&(t.previousState=g,!0)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange();if(i?.dataComputedScale?.length){const e=[],t=[];for(let n=0;n<4;n++)e[n]=s[0]*i.dataComputedScale[n]+i.dataComputedOffset[n],t[n]=s[1]*i.dataComputedScale[n]+i.dataComputedOffset[n],e[n]=(e[n]-i.offset[n])/i.scale[n],t[n]=(t[n]-i.offset[n])/i.scale[n];a.setUniform4f("ipScalarRangeMin",e[0],e[1],e[2],e[3]),a.setUniform4f("ipScalarRangeMax",t[0],t[1],t[2],t[3])}if(null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Hg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),s.setUniform3f("volumeSpacings",x[0],x[1],x[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*En(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(e.isLabelmapOutlineRequired(o)){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lightComplexity)return;let O=0;const R=[],M=[],E=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],E[0+3*O]=-.5*w[0],E[1+3*O]=-.5*w[1],E[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",E),3===t.lightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(n,r,o)=>{const a=n.getProgram();a.setUniformi("ctexture",t.colorTexture.getTextureUnit()),a.setUniformi("otexture",t.opacityTexture.getTextureUnit()),a.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),a.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const i=t.scalarTexture.getVolumeInfo(),s=o.getProperty(),l=t.scalarTexture.getComponents(),c=e.useIndependentComponents(s);if(c)for(let e=0;e<l;e++)a.setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));for(let e=0;e<l;e++){const t=c?e:0,n=i.scale[e],r=s.getScalarOpacity(t).getRange(),o=n/(r[1]-r[0]),l=(i.offset[e]-r[0])/(r[1]-r[0]);a.setUniformf(`oshift${e}`,l),a.setUniformf(`oscale${e}`,o);const u=s.getRGBTransferFunction(t).getRange(),d=(i.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);a.setUniformf(`cshift${e}`,d),a.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(c)for(let e=0;e<l;++e){const t=i.scale[e];if(s.getUseGradientOpacity(e)){const n=s.getGradientOpacityMinimumOpacity(e),r=s.getGradientOpacityMaximumOpacity(e);a.setUniformf(`gomin${e}`,n),a.setUniformf(`gomax${e}`,r);const o=[s.getGradientOpacityMinimumValue(e),s.getGradientOpacityMaximumValue(e)];a.setUniformf(`goscale${e}`,t*(r-n)/(o[1]-o[0])),a.setUniformf(`goshift${e}`,-o[0]*(r-n)/(o[1]-o[0])+n)}else a.setUniformf(`gomin${e}`,1),a.setUniformf(`gomax${e}`,1),a.setUniformf(`goscale${e}`,0),a.setUniformf(`goshift${e}`,1)}else{const e=i.scale[l-1],t=s.getGradientOpacityMinimumOpacity(0),n=s.getGradientOpacityMaximumOpacity(0);a.setUniformf("gomin0",t),a.setUniformf("gomax0",n);const r=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];a.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),a.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===e.isLabelmapOutlineRequired(o)){const e=o.getProperty().getLabelOutlineOpacity();a.setUniformf("outlineOpacity",e)}t.lightComplexity>0&&(a.setUniformf("vAmbient",s.getAmbient()),a.setUniformf("vDiffuse",s.getDiffuse()),a.setUniformf("vSpecular",s.getSpecular()),a.setUniformf("vSpecularPower",s.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*En(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Fg.NEAREST?(t.scalarTexture.setMinificationFilter(Rd.NEAREST),t.scalarTexture.setMagnificationFilter(Rd.NEAREST)):(t.scalarTexture.setMinificationFilter(Rd.LINEAR),t.scalarTexture.setMagnificationFilter(Rd.LINEAR)),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):jg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.scalarTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(Rd.LINEAR),t.jitterTexture.setMagnificationFilter(Rd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,Cs.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=e.useIndependentComponents(i),c=l?s:1,u=i.getScalarOpacity(),d=t._openGLRenderWindow.getGraphicsResourceForObject(u);let p=cg(u,l,c);if(d?.oglObject&&d.hash===p)t.opacityTexture=d.oglObject;else{t.opacityTexture=Kd.newInstance(),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const r=1024,o=2*r*c,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<c;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(Rd.LINEAR),t.opacityTexture.setMagnificationFilter(Rd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.UNSIGNED_CHAR,e)}u&&(t._openGLRenderWindow.setGraphicsResourceForObject(u,t.opacityTexture,p),u!==t._scalarOpacityFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(u,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalarOpacityFunc,e)),t._scalarOpacityFunc=u)}const f=i.getRGBTransferFunction();p=cg(f,l,c);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===p)t.colorTexture=g.oglObject;else{t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(2*n*c*3),o=new Float32Array(3*n);for(let e=0;e<c;++e){const t=i.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.create2DFromRaw(n,2*c,3,Cs.UNSIGNED_CHAR,r),f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,p),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}e.updateLabelOutlineThicknessTexture(r);const m=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(p=ug(o,a),m?.oglObject?.getHandle()&&m?.hash===p)t.scalarTexture=m.oglObject;else{t.scalarTexture=Kd.newInstance(),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a,t.renderable.getPreferSizeOverAccuracy()),a&&(t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,p),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ns.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ns.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThickness(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{t.labelOutlineThicknessTexture=Kd.newInstance(),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.isLabelmapOutlineRequired=e=>{const n=e.getProperty(),r=t.renderable;return n.getUseLabelOutline()||r.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND}}const $g={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$g,n),Zt.extend(e,t,n),Yd(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),t.jitterTexture=Kd.newInstance(),t.jitterTexture.setWrapS(Od.REPEAT),t.jitterTexture.setWrapT(Od.REPEAT),t.framebuffer=ef.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Kg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",qg);const{vtkDebugMacro:Xg}=Kt;function Yg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Xg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const Zg={};const Qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zg,n),Zt.extend(e,t,n),Yg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Qg);var Jg="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:em}=ms;function tm(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Kd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function nm(e,t){return tm(e,t,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE)}function rm(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",em.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=nm(t._openGLRenderWindow,t.size),t.seedTexture0=nm(t._openGLRenderWindow,t.size),t.licTexture1=nm(t._openGLRenderWindow,t.size),t.seedTexture1=nm(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?tm(t._openGLRenderWindow,t.size,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return tm(e,t,Kd.Filter.LINEAR,Kd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const om={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,om,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),rm(e,t)}var im={newInstance:jt.newInstance(am,"vtkLICPingPongBufferManager"),extend:am};const sm=0,lm=1,cm=2,um=3,dm=1;function pm(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=ef.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=ef.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=im.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],y=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;y.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:T}=t;y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",0),T.setUniformf("uMaskThreshold",t.maskThreshold),T.setUniform2f("uNoiseBoundsPt1",...m),T.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),T.setUniformi("texLIC",t.bufs.getLICTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,T);const{LICIShaderProgram:b}=t;y.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",1),n(T,t.bufs),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;y.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)y.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),y.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const fm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),pm(e,t)}var mm={newInstance:jt.newInstance(gm,"vtkLineIntegralConvolution2D"),extend:gm};function hm(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const vm={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:sm,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:dm,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vm,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),hm(0,t)}var Tm={newInstance:jt.newInstance(ym,"vtkSurfaceLICInterface"),extend:ym};const{Representation:bm}=ms;function xm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===dm?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Kd.newInstance({wrapS:Kd.Wrap.REPEAT,wrapT:Kd.Wrap.REPEAT,minificationFilter:Kd.Filter.NEAREST,magnificationFilter:Kd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.allocateTextures=()=>{const n=Kd.Filter.NEAREST,r=Kd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Kd.newInstance({wrapS:Kd.Wrap.CLAMP_TO_EDGE,wrapT:Kd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Kd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=ef.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",bm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=mm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===cm||u===um){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const Cm={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Sm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cm,n),Tm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),xm(e,t)}var Am={newInstance:jt.newInstance(Sm,"vtkSurfaceLICInterface"),extend:Sm};const{vtkErrorMacro:Im}=Kt;function wm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=yd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=yd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=yd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=yd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=yd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Im("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Im("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Im("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Tm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Am.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Im("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const Pm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Om=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pm,n),pp.extend(e,t,n),wm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",Om);const{vtkErrorMacro:Rm}=Kt;function Mm(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Rm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,Zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Em={};const Dm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Em,n),pp.extend(e,t,n),Mm(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",Dm);const{vtkErrorMacro:Vm}=Kt;function Lm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=yd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||Vm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||Vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||Vm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():Vm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,Zu.ARRAY_BUFFER),a.getColorBO().upload(g,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Bm={};const Nm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bm,n),pp.extend(e,t,n),Lm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Nm);const _m=[];_m["-".charCodeAt(0)]=62,_m["_".charCodeAt(0)]=63;const Fm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<Fm.length;e++)_m[Fm.charCodeAt(e)]=e;function km(e){return void 0!==_m[e.charCodeAt(0)]}function Gm(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<18;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<12;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<6;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<10;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<4;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<2;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Um(e,t,n){const r=(e<<16)+(t<<8)+n;return Fm[r>>18]+Fm[r>>12&63]+Fm[r>>6&63]+Fm[63&r]}function zm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Um(t[n],t[n+1],t[n+2])}if(n>0){const e=Um(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Wm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)km(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Gm(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Hm={};function jm(e,t){Hm[e]=t}var Km=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Hm[e](t)},$m=Uint8Array,qm=Uint16Array,Xm=Uint32Array,Ym=new $m([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zm=new $m([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qm=new $m([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jm=function(e,t){for(var n=new qm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Xm(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},eh=Jm(Ym,2),th=eh[0],nh=eh[1];th[28]=258,nh[258]=28;for(var rh=Jm(Zm,0),oh=rh[0],ah=(rh[1],new qm(32768)),ih=0;ih<32768;++ih){var sh=(43690&ih)>>>1|(21845&ih)<<1;sh=(61680&(sh=(52428&sh)>>>2|(13107&sh)<<2))>>>4|(3855&sh)<<4,ah[ih]=((65280&sh)>>>8|(255&sh)<<8)>>>1}var lh=function(e,t,n){for(var r=e.length,o=0,a=new qm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new qm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new qm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[ah[d]>>>l]=c}else for(i=new qm(r),o=0;o<r;++o)e[o]&&(i[o]=ah[s[e[o]-1]++]>>>15-e[o]);return i},ch=new $m(288);for(ih=0;ih<144;++ih)ch[ih]=8;for(ih=144;ih<256;++ih)ch[ih]=9;for(ih=256;ih<280;++ih)ch[ih]=7;for(ih=280;ih<288;++ih)ch[ih]=8;var uh=new $m(32);for(ih=0;ih<32;++ih)uh[ih]=5;var dh=lh(ch,9,1),ph=lh(uh,5,1),fh=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},gh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},mh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},hh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?qm:4==e.BYTES_PER_ELEMENT?Xm:$m)(n-t);return r.set(e.subarray(t,n)),r},vh=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],yh=function(e,t,n){var r=new Error(t||vh[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,yh),!n)throw r;return r},Th=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new $m(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new $m(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new $m(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=gh(e,c,1);var h=gh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&yh(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=dh,p=ph,f=9,g=5;else if(2==h){var T=gh(e,c,31)+257,b=gh(e,c+10,15)+4,x=T+gh(e,c+5,31)+1;c+=14;for(var C=new $m(x),S=new $m(19),A=0;A<b;++A)S[Qm[A]]=gh(e,c+3*A,7);c+=3*b;var I=fh(S),w=(1<<I)-1,P=lh(S,I,1);for(A=0;A<x;){var O,R=P[gh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,E=0;for(16==O?(E=3+gh(e,c,3),c+=2,M=C[A-1]):17==O?(E=3+gh(e,c,7),c+=3):18==O&&(E=11+gh(e,c,127),c+=7);E--;)C[A++]=M}}var D=C.subarray(0,T),V=C.subarray(T);f=fh(D),g=fh(V),d=lh(D,f,1),p=lh(V,g,1)}else yh(1);if(c>m){a&&yh(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[mh(e,c)&L])>>>4;if((c+=15&M)>m){a&&yh(0);break}if(M||yh(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Ym[A=_-257];F=gh(e,c,(1<<k)-1)+th[A],c+=k}var G=p[mh(e,c)&B],U=G>>>4;if(G||yh(3),c+=15&G,V=oh[U],U>3&&(k=Zm[U],V+=mh(e,c)&(1<<k)-1,c+=k),c>m){a&&yh(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:hh(t,0,u)},bh=new $m(0),xh=function(e,t){return e[t]|e[t+1]<<8},Ch=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Sh=function(e,t){return Ch(e,t)+4294967296*Ch(e,t+4)};function Ah(e,t){return Th(e,t)}function Ih(e,t){return Th(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||yh(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new $m((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function wh(e,t){return Th(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&yh(6,"invalid zlib data"),32&n[1]&&yh(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Ph(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Ih(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Ah(e,t):wh(e,t)}var Oh="undefined"!=typeof TextEncoder&&new TextEncoder,Rh="undefined"!=typeof TextDecoder&&new TextDecoder;try{Rh.decode(bh,{stream:!0})}catch(e){}function Mh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Rh)return Rh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,hh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&yh(8),a}var Eh=function(e,t){return t+30+xh(e,t+26)+xh(e,t+28)},Dh=function(e,t,n){var r=xh(e,t+28),o=Mh(e.subarray(t+46,t+46+r),!(2048&xh(e,t+8))),a=t+46+r,i=Ch(e,t+20),s=n&&4294967295==i?Vh(e,a):[i,Ch(e,t+24),Ch(e,t+42)],l=s[0],c=s[1],u=s[2];return[xh(e,t+10),l,c,o,a+xh(e,t+30)+xh(e,t+32),u]},Vh=function(e,t){for(;1!=xh(e,t);t+=4+xh(e,t+2));return[Sh(e,t+12),Sh(e,t+4),Sh(e,t+20)]};function Lh(e,t){for(var n={},r=e.length-22;101010256!=Ch(e,r);--r)(!r||e.length-r>65558)&&yh(13);var o=xh(e,r+8);if(!o)return{};var a=Ch(e,r+16),i=4294967295==a;i&&(r=Ch(e,r-12),101075792!=Ch(e,r)&&yh(13),o=Ch(e,r+32),a=Ch(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Dh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Eh(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Ah(e.subarray(h,h+d),new $m(p)):yh(14,"unknown compression type "+u):n[f]=hh(e,h,h+d))}return n}function Bh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Nh=Bh(),_h=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:Fh,vtkDebugMacro:kh}=jt;let Gh=0;function Uh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const zh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Uh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(kh(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Fh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Mh(Ph(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Mh(Ph(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Uh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Ph(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};jm("http",(e=>zh));const{vtkDebugMacro:Wh}=jt;function Hh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Wh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Wh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Hi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Hi(o,[...t.position,1],n),Hi(a,[...t.focalPoint,1],n),Hi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=qi(e[0],e[1],e[2],e[3]),n=ji(),r=qi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],$i(r,t,r),$i(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=ji();Ki(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const jh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Kh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Hh(e,t)}var $h={newInstance:jt.newInstance(Kh,"vtkCamera"),extend:Kh};function qh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const Xh={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xh,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),qh(e,t)}var Zh={newInstance:jt.newInstance(Yh,"vtkLight"),extend:Yh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Qh}=jt;function Jh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Qh("call displayToView on your view instead"),e.viewToDisplay=()=>Qh("callviewtodisplay on your view instead"),e.getSize=()=>Qh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Qh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const ev={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function tv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ev,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Jh(e,t)}var nv={newInstance:jt.newInstance(tv,"vtkViewport"),extend:tv};const{vtkDebugMacro:rv,vtkErrorMacro:ov,vtkWarningMacro:av}=Kt;function iv(e){return()=>ov(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function sv(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(rv("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):ov("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=iv("allocateTime"),e.updateGeometry=iv("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{rv(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=$h.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Zh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ov("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ov("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Wi.INIT_BOUNDS[0],t.allBounds[1]=Wi.INIT_BOUNDS[1],t.allBounds[2]=Wi.INIT_BOUNDS[2],t.allBounds[3]=Wi.INIT_BOUNDS[3],t.allBounds[4]=Wi.INIT_BOUNDS[4],t.allBounds[5]=Wi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),rv("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return rv("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return ov("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&(av("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return rv("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ov("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const lv={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lv,n),nv.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),sv(e,t)}var uv={newInstance:Dt(cv,"vtkRenderer"),extend:cv};const dv=Object.create(null);function pv(e,t){dv[e]=t}function fv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dv[e]&&dv[e](t)}function gv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}const mv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers","childRenderWindows"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),gv(e,t)}var vv={newInstance:jt.newInstance(hv,"vtkRenderWindow"),extend:hv,registerViewConstructor:pv,listViewAPIs:function(){return Object.keys(dv)},newAPISpecificView:fv};const yv={Unknown:0,LeftController:1,RightController:2},Tv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var bv={Device:yv,Input:Tv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:xv,Input:Cv}=bv,{vtkWarningMacro:Sv,vtkErrorMacro:Av,normalizeWheel:Iv,vtkOnceErrorMacro:wv}=jt,Pv={ctrlKey:!1,altKey:!1,shiftKey:!1},Ov={"xr-standard":[Cv.Trigger,Cv.Grip,Cv.TrackPad,Cv.Thumbstick,Cv.A,Cv.B]},Rv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Mv(e){e.cancelable&&e.preventDefault()}function Ev(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function Dv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Av("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Sv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Mv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Mv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Mv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Sv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Mv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Av(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Sv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Av("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Sv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?xv.LeftController:xv.RightController,input:Ov[s.mapping]&&Ov[s.mapping][r]?Ov[s.mapping][r]:Cv.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?xv.LeftController:xv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Mv(n);const r={...Iv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Av(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);if(2===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Ev(o);e.recognizeGesture("TouchEnd",t);const a={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Rv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void wv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const Vv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),Rv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),Dv(e,t)}var Bv={newInstance:jt.newInstance(Lv,"vtkRenderWindowInteractor"),extend:Lv,handledEvents:Rv,...bv};const{vtkErrorMacro:Nv,VOID:_v}=jt;function Fv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Bv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):_v),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Nv("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const kv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorObserver"),extend:Gv,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},zv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Wv}=zv,Hv={Rotate:Wv.IS_ROTATE,Pan:Wv.IS_PAN,Spin:Wv.IS_SPIN,Dolly:Wv.IS_DOLLY,CameraPose:Wv.IS_CAMERA_POSE,WindowLevel:Wv.IS_WINDOW_LEVEL,Slice:Wv.IS_SLICE};function jv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Hv).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Wv.IS_NONE&&(t.state=Hv[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Hv[n]&&(t.state=Wv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Kv={state:Wv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Uv.extend(e,t,n),jt.setGet(e,t,["focusedRenderer"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkInteractorStyle"),extend:$v,...zv};const{States:Xv}=zv;function Yv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case Xv.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad?!n||n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad||t.state!==Xv.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===Xv.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case Xv.IS_DOLLY:e.endDolly();break;case Xv.IS_PAN:e.endPan();break;case Xv.IS_SPIN:e.endSpin();break;case Xv.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const Zv={motionFactor:10,zoomFactor:10};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),qv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Yv(e,t)}var Jv={newInstance:jt.newInstance(Qv,"vtkInteractorStyleTrackballCamera"),extend:Qv};function ey(e){return e}function ty(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>ty(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var ny=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?ty:ey,o=new URLSearchParams(t);return o.forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};function ry(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const oy={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),ry(e,t)}var iy={newInstance:jt.newInstance(ay,"vtkRenderPass"),extend:ay};const{Representation:sy}=ms,{vtkErrorMacro:ly}=jt;function cy(e){const t=yd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function uy(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ns.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ns.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",sy.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Kd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Kd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Kd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||ly("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||ly("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?cy:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const dy={framebuffer:null,copyShader:null,tris:null};function py(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dy,n),iy.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),jt.get(e,t,["framebuffer"]),uy(e,t)}var fy={newInstance:jt.newInstance(py,"vtkOpenGLOrderIndependentTranslucentPass"),extend:py};function gy(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=ef.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=fy.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const my={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),iy.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkForwardPass"),extend:hy},yy=n(594),Ty=n.n(yy);const by=["lastShaderProgramBound","context","_openGLRenderWindow"];function xy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=yd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=yd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=yd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=yd.substitute(l,"varying","out").result,o=yd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=yd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=yd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:yd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Ty().hash(o);if(!(a in t.shaderPrograms)){const o=yd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const Cy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,by),jt.moveToProtected(e,t,["openGLRenderWindow"]),xy(e,t)}var Ay={newInstance:jt.newInstance(Sy,"vtkShaderCache"),extend:Sy};const{vtkErrorMacro:Iy}=jt;function wy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&Iy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const Py={context:null,numberOfTextureUnits:0,textureUnits:0};function Oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),wy(e,t)}var Ry={newInstance:jt.newInstance(Oy,"vtkOpenGLTextureUnitManager"),extend:Oy};function My(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ey={size:void 0,selector:void 0};function Dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),My(e,t)}var Vy={newInstance:jt.newInstance(Dy,"vtkRenderWindowViewNode"),extend:Dy};const{vtkDebugMacro:Ly,vtkErrorMacro:By}=jt,Ny={position:"absolute",top:0,left:0,width:"100%",height:"100%"},_y=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Fy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ky=0;const Gy=[];function Uy(e){e.preventDefault()}function zy(e,t){let n;function r(){return n||(n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n}t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Uy,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const o=[0,0];let a;e.onModified((function(){t.renderable&&(t.size[0]===o[0]&&t.size[1]===o[1]||(o[0]=t.size[0],o[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ky++,Gy.forEach((e=>e(ky)))),t.textureUnitManager=Ry.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&By("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},n=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(n=t.canvas.getContext("webgl2",e),n&&(t.webgl2=!0,Ly("using webgl2"))),n||(Ly("using webgl1"),n=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(n,r())},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=iy.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?By("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case Cs.CHAR:case Cs.SIGNED_CHAR:case Cs.UNSIGNED_CHAR:return 1;case n:case r:case Cs.UNSIGNED_SHORT:case Cs.SHORT:case Cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case Cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&Cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&Cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ny,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=a)return a;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return a=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Fy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Fy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Fy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Fy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Fy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Fy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Fy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=xf.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((()=>{t.context&&(ky--,Gy.forEach((e=>e(ky)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Uy),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const i=e.setSize;e.setSize=(t,n)=>{const r=i(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null),t._graphicsResources.get(n)?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))};const s={...e};_y.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):s[n](...arguments)}}))}const Wy={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Hy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),Vy.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=xf.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.shaderCache=Ay.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=vy.newInstance(),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),jt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"imageReady"),jt.event(e,t,"windowResizeEvent"),zy(e,t)}),"vtkOpenGLRenderWindow");function jy(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}pv("WebGL",Hy),rn("vtkRenderWindow",Hy);const Ky={device:null,handle:null};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),jy(e,t)}var qy={newInstance:jt.newInstance($y,"vtkWebGPUShaderModule"),extend:$y};function Xy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=qy.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const Yy={shaderModules:null,device:null,window:null};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Xy(e,t)}var Qy={newInstance:jt.newInstance(Zy,"vtkWebGPUShaderCache"),extend:Zy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function Jy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const eT={device:null,handle:null,label:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),Jy(e,t)}var nT={newInstance:jt.newInstance(tT),extend:tT};function rT(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const oT={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function aT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oT,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),rT(e,t)}var iT={newInstance:Dt(aT,"vtkWebGPUPipeline"),extend:aT};function sT(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Qy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Qy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Qy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const lT={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),sT(e,t)}var uT={newInstance:jt.newInstance(cT,"vtkWebGPUShaderDescription"),extend:cT};const dT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var pT=function(e){return!e||e.length<6?0:e in dT==1?dT[e]:(et(`unknown format ${e}`),null)},fT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},gT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},mT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},hT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},vT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function yT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function TT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(yT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=mT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const bT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function xT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),TT(e,t)}var CT={newInstance:Dt(xT,"vtkWebGPUVertexInput"),extend:xT};const ST="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",AT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function IT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=uT.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=uT.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=iT.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const wT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=CT.newInstance(),t.bindGroup=nT.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||AT,t.vertexShaderTemplate=t.vertexShaderTemplate||ST,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),IT(e,t)}var OT={newInstance:jt.newInstance(PT,"vtkWebGPUSimpleMapper"),extend:PT};function RT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const MT={};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),OT.extend(e,t,n),RT(e,t)}var DT={newInstance:jt.newInstance(ET,"vtkWebGPUFullScreenQuad"),extend:ET};const VT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function LT(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<VT.length;n++)e[VT[n]]=function(){return t.handle[VT[n]](...arguments)}}const BT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),LT(e,t)}var _T={newInstance:Dt(NT,"vtkWebGPURenderEncoder"),extend:NT},FT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const kT=["getMappedRange","mapAsync","unmap"];function GT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<kT.length;n++)e[kT[n]]=function(){return t.handle[kT[n]](...arguments)}}const UT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function zT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,UT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),GT(e,t)}var WT={newInstance:jt.newInstance(zT),extend:zT,...FT};const{Representation:HT}=ms,{PrimitiveTypes:jT}=FT;class KT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function $T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function qT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=$T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=$T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=$T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=$T(n,o,t),n.ibo[n.iboId++]=a}function XT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let YT;const ZT=new Uint32Array(1),QT=new Uint32Array(2),JT=new Uint32Array(3),eb={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)ZT[0]=t[n+a],YT(ZT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)QT[0]=t[n+a],QT[1]=t[n+(a+1)%e],YT(QT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o);for(let a=0;a<e-2;a++)QT[0]=t[n+a],QT[1]=t[n+a+2],YT(QT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n],JT[1]=t[n+a+1],JT[2]=t[n+a+2],YT(JT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n+a],JT[1]=t[n+a+1+a%2],JT[2]=t[n+a+1+(a+1)%2],YT(JT,r,o)}};function tb(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case jT.Points:return"points";case jT.Lines:return"lines";case jT.Triangles:case jT.TriangleEdges:return"polys";case jT.TriangleStripEdges:case jT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new KT};let d=null;d=o===HT.POINTS||r===jT.Points?eb.anythingToPoints:o===HT.WIREFRAME||r===jT.Lines?eb[`${l}ToWireframe`]:eb[`${l}ToSurface`],YT=XT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),YT=qT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const nb={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nb,n),WT.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),tb(e,t)}var ob={newInstance:jt.newInstance(rb),extend:rb,...FT};const{BufferUsage:ab}=FT,{vtkErrorMacro:ib}=Kt,{VtkDataTypes:sb}=Ns;function lb(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function cb(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function ub(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===ab.Index&&(n=ob.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=WT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===ab.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===ab.PointArray){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=lb(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===ab.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=cb(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=lb(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===ab.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case sb.UNSIGNED_CHAR:t="uint8";break;case sb.FLOAT:t="float32";break;case sb.UNSIGNED_INT:t="uint32";break;case sb.INT:t="sint32";break;case sb.DOUBLE:t="float32";break;case sb.UNSIGNED_SHORT:t="uint16";break;case sb.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ib(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:ab.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=WT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const db={device:null,fullScreenQuadBuffer:null};function pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,db,n),yt(e,t),At(e,t,["device"]),ub(e,t)}var fb={newInstance:Dt(pb),extend:pb,...FT};function gb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const mb={device:null,handle:null,label:null,options:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),gb(e,t)}var vb={newInstance:jt.newInstance(hb),extend:hb};function yb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vb.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const Tb={texture:null,handle:null,sampler:null,label:null};function bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),yb(e,t)}var xb={newInstance:jt.newInstance(bb),extend:bb};const{BufferUsage:Cb}=fb;function Sb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=pT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Vd.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Pu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:Cb.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:Cb.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=pT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>pT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=xb.newInstance({label:n});return o.create(e,r),o}}const Ab={device:null,handle:null,buffer:null,ready:!1,label:null};function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ab,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),Sb(e,t)}var wb={newInstance:jt.newInstance(Ib),extend:Ib};function Pb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=wb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=_T.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const Ob={renderEncoder:null,colorTexture:null,depthTexture:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Pb(e,t)}var Mb={newInstance:jt.newInstance(Rb,"vtkWebGPUOpaquePass"),extend:Rb};function Eb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=wb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=wb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=DT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=_T.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=_T.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const Db={colorTextureView:null,depthTextureView:null};function Vb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Db,n),iy.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),Eb(e,t)}var Lb={newInstance:jt.newInstance(Vb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Vb};const{BufferUsage:Bb}=fb,{vtkErrorMacro:Nb}=jt;function _b(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Nb(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:hT(n),offset:-1,nativeType:vT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Bb.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Fb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),_b(e,t)}var Gb={newInstance:jt.newInstance(kb,"vtkWebGPUUniformBuffer"),extend:kb};const{BufferUsage:Ub}=fb,{vtkErrorMacro:zb}=jt;function Wb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void zb(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=hT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:vT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Ub.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Hb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Wb(e,t)}var Kb={newInstance:jt.newInstance(jb,"vtkWebGPUStorageBuffer"),extend:jb};const $b="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",qb=new Float64Array(16),Xb=new Float64Array(16);function Yb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===zg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Qy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Qy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Qy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===zg.COMPOSITE_BLEND?l=!0:n===zg.MAXIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.MINIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.AVERAGE_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.ADDITIVE_INTENSITY_BLEND&&(a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Qy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(qb),b(qb,qb,o);const p=n.getMatrix();m(Xb,p),h(Xb,Xb),T(qb,Xb,qb);const f=d.getWorldToIndex();T(qb,f,qb);const v=d.getDimensions();g(Xb),x(Xb,Xb,[1/v[0],1/v[1],1/v[2]]),T(qb,Xb,qb);for(let t=0;t<16;t++)a[16*e+t]=qb[t];h(qb,qb);for(let t=0;t<4;t++)i[16*e+4*t]=qb[4*t],i[16*e+4*t+1]=qb[4*t+1],i[16*e+4*t+2]=qb[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=pT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vb.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Zb={volumes:null,rowLength:1024,lastVolumeLength:0};function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zb,n),DT.extend(e,t,n),t.fragmentShaderTemplate=$b,t.UBO=Gb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Kb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Kb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),Yb(e,t)}var Jb={newInstance:jt.newInstance(Qb,"vtkWebGPUVolumePassFSQ"),extend:Qb};const{Representation:ex}=ms,{BufferUsage:tx,PrimitiveTypes:nx}=fb,rx=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],ox="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function ax(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=Jb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=DT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Gb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:tx.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:nx.Triangles,representation:ex.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:tx.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+rx[e][0],l[n++]=r+rx[e][1],l[n++]=r+rx[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=_T.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=wb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=wb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=wb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=_T.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=_T.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=_T.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const ix={colorTextureView:null,depthTextureView:null,volumes:null};function sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ix,n),iy.extend(e,t,n),t._mapper=OT.newInstance(),t._mapper.setFragmentShaderTemplate(ox),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Cu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),ax(e,t)}var lx={newInstance:jt.newInstance(sx,"vtkWebGPUVolumePass"),extend:sx};function cx(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Mb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Lb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=lx.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=_T.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vb.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=DT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=xb.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const ux={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ux,n),iy.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),cx(e,t)}var px={newInstance:jt.newInstance(dx,"vtkForwardPass"),extend:dx};const{VtkDataTypes:fx}=Ns;function gx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case fx.UNSIGNED_CHAR:e.format+="8unorm";break;case fx.FLOAT:case fx.UNSIGNED_INT:case fx.INT:case fx.DOUBLE:case fx.UNSIGNED_SHORT:case fx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=wb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const mx={handle:null,device:null};function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mx,n),jt.obj(e,t),jt.setGet(e,t,["device"]),gx(e,t)}var vx={newInstance:jt.newInstance(hx),extend:hx};class yx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function Tx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const bx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new yx,t.shaderCache=Qy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=fb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=vx.newInstance(),t.textureManager.setDevice(e),t.pipelines={},Tx(e,t)}var Cx={newInstance:Dt(xx,"vtkWebGPUDevice"),extend:xx};function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=wb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=_T.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const Ax={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelectionPass"),extend:Ix};const{SelectionContent:Px,SelectionField:Ox}=of,{FieldAssociations:Rx}=ll,{vtkErrorMacro:Mx}=jt;function Ex(e){return`${e.propID} ${e.compositeID}`}function Dx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Vx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Dx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Dx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Vx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Vx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Vx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Vx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Vx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Lx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Mx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=WT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=WT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Vx(e,[n,t],0,u);if(r){const t=Ex(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=of.newInstance();switch(i.setContentType(Px.INDICES),e){case Rx.FIELD_ASSOCIATION_CELLS:i.setFieldType(Ox.CELL);break;case Rx.FIELD_ASSOCIATION_POINTS:i.setFieldType(Ox.POINT);break;default:Mx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Bx={};function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),Yp.extend(e,t,n),t._selectionPass=wx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Lx(e,t)}var _x={newInstance:jt.newInstance(Nx,"vtkWebGPUHardwareSelector"),extend:Nx};const Fx=Object.create(null);function kx(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Gx={};function Ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gx,n),t.overrides=Fx,tn.extend(e,t,n),kx(0,t)}var zx={newInstance:jt.newInstance(Ux,"vtkWebGPUViewNodeFactory"),extend:Ux};const{vtkErrorMacro:Wx}=jt,Hx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function jx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Wx("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Wx("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=Cx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=iy.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Hx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=WT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Vd.fromHalf(r.colorValues[o]),s[n+1]=255*Vd.fromHalf(r.colorValues[o+1]),s[n+2]=255*Vd.fromHalf(r.colorValues[o+2]),s[n+3]=255*Vd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=_x.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Kx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const $x=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Vy.extend(e,t,n),t.myFactory=zx.newInstance(),t.renderPasses[0]=px.newInstance(),t.selector||(t.selector=_x.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),jx(e,t)}),"vtkWebGPURenderWindow");var qx;pv("WebGPU",$x),qx=$x,Fx.vtkRenderWindow=qx;const Xx=ny(),Yx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Zx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Qx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Jx(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Qx(t.container,t.containerStyle||Yx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=vv.newInstance(),t.renderer=uv.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Xx.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Bv.newInstance(),t.interactor.setInteractorStyle(Jv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Qx(t.controlContainer,t.controlPanelStyle||Zx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const eC={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function tC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eC,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Jx(e,t)}var nC={newInstance:jt.newInstance(tC),extend:tC},rC={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:oC,Scale:aC}=rC,{ScalarMappingTarget:iC}=El,{vtkDebugMacro:sC,vtkErrorMacro:lC,vtkWarningMacro:cC}=jt;function uC(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function dC(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function pC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];uC(o,i),uC(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=dC(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=dC(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function fC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return lC("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return lC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===aC.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Eo(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===oC.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===oC.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===oC.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===oC.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return lC("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(lC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return lC("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void lC("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):sC("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void cC("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===iC.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===iC.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===iC.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===iC.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=oC[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(lC(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=oC.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const gC={clamping:!0,colorSpace:oC.RGB,hSVWrap:!0,scale:aC.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function mC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gC,n),El.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:oC},{type:"enum",name:"scale",enum:aC}]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),fC(e,t)}var hC={newInstance:jt.newInstance(mC,"vtkColorTransferFunction"),extend:mC,...rC},vC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:yC,ScaleModes:TC}=vC,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(yC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(yC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(yC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(yC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(TC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(TC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(TC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(TC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===TC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(bC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Wi.getCorners(l,c),t.bounds[0]=Wi.INIT_BOUNDS[0],t.bounds[1]=Wi.INIT_BOUNDS[1],t.bounds[2]=Wi.INIT_BOUNDS[2],t.bounds[3]=Wi.INIT_BOUNDS[3],t.bounds[4]=Wi.INIT_BOUNDS[4],t.bounds[5]=Wi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case yC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case yC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case yC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case TC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case TC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case TC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const CC={orient:!0,orientationMode:yC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:TC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,CC,n),uc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkGlyph3DMapper"),extend:SC,...vC};const{vtkErrorMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(IC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return IC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return IC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return IC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const PC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkPiecewiseFunction"),extend:OC};const{InterpolationType:MC,OpacityMode:EC}=Ug,{vtkErrorMacro:DC}=jt;function VC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(DC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=RC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=hC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=RC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return DC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(DC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(MC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(MC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(MC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(MC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const LC={colorMixPreset:null,independentComponents:!0,interpolationType:MC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,LC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:EC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}jt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeProperty"),extend:BC,...Ug};const{vtkDebugMacro:_C}=jt;function FC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=NC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){_C("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const kC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function GC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kC,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),FC(e,t)}var UC={newInstance:jt.newInstance(GC,"vtkVolume"),extend:GC};const{BlendMode:zC,FilterMode:WC}=Wg,HC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=RC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function jC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(zC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(zC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(zC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(zC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(zC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(zC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(zC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(WC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(WC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(WC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(WC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Eo(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const KC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:zC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:WC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function $C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KC,n),zs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),jC(e,t)}var qC={newInstance:jt.newInstance($C,"vtkVolumeMapper"),extend:$C,...HC};const{InterpolationType:XC}=pg,{vtkErrorMacro:YC}=jt;function ZC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return YC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(YC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(XC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(XC.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(XC,t.interpolationType)}const QC={independentComponents:!1,interpolationType:XC.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function JC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,QC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),ZC(e,t)}var eS={newInstance:jt.newInstance(JC,"vtkImageProperty"),extend:JC};const{vtkDebugMacro:tS}=jt;function nS(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=eS.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){tS("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Wi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Wi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Wi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const rS={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...Wi.INIT_BOUNDS]};function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rS,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),jt.getArray(e,t,["bounds"],6),nS(e,t)}var aS={newInstance:jt.newInstance(oS,"vtkImageSlice"),extend:oS};function iS(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const sS={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var lS=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sS,n),zs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),iS(e,t)};function cS(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ii.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:uS,otherStaticMethods:dS}=Kl,{SlicingMode:pS}=yg;function fS(e,t){function n(){let n;switch(t.slicingMode){case pS.X:n=0;break;case pS.Y:n=1;break;case pS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case pS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case pS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case pS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case pS.I:l=Ma(a[0],i[0],i[1]);break;case pS.J:l=Ma(a[1],i[2],i[3]);break;case pS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case pS.I:case pS.J:case pS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case pS.X:e.setSlice(r[0]);break;case pS.Y:e.setSlice(r[1]);break;case pS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(pS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(pS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(pS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(pS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(pS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(pS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case pS.X:n[0]=1;break;case pS.Y:n[1]=1;break;case pS.Z:n[2]=1;break;case pS.I:ea(r,[1,0,0],n);break;case pS.J:ea(r,[0,1,0],n);break;case pS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==pS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case pS.I:r[0]=a,r[1]=a;break;case pS.J:r[2]=a,r[3]=a;break;case pS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case pS.I:a[0]=s-r,a[1]=s+r;break;case pS.J:a[2]=s-r,a[3]=s+r;break;case pS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const gS={slicingMode:pS.NONE,closestIJKAxis:{ijkMode:pS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function mS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gS,n),lS(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Kl.implementCoincidentTopologyMethods(e,t),fS(e,t)}var hS={newInstance:jt.newInstance(mS,"vtkImageMapper"),extend:mS,...uS,...dS,...yg};const{vtkErrorMacro:vS}=jt;function yS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function TS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void vS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Cu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Xs.SINGLE?s=Cs.FLOAT:t.outputPointsPrecision===Xs.DOUBLE&&(s=Cs.DOUBLE);const v=Sc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ns.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ns.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ns.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),yS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),yS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),yS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),yS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const bS={outputPointsPrecision:Xs.DEFAULT};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkAppendPolyData"),extend:xS};function SS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Kf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Cu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const AS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function IS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),SS(e,t)}var wS={newInstance:jt.newInstance(IS,"vtkConeSource"),extend:IS};function PS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ns.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ns.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Kf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Cu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const OS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function RS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),PS(e,t)}var MS={newInstance:jt.newInstance(RS,"vtkCylinderSource"),extend:RS};function ES(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=MS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();jf().rotateZ(-90).apply(a).apply(i);const s=wS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Kf().translate(1-.5*t.tipLength,0,0).apply(c);const u=CS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Kf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Kf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Kf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const DS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function VS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),ES(e,t)}var LS={newInstance:jt.newInstance(VS,"vtkArrowSource"),extend:VS};function BS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];jf().translate(...n).apply(e.getPoints().getData())}function NS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],jf().translate(...o).apply(e.getPoints().getData())}function _S(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ns.newInstance({name:"color",numberOfComponents:3,values:a}))}function FS(e,t){t.classHierarchy.push("vtkAxesActor");const n=uc.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=LS.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?BS(r):NS(r,0,e.invert),_S(r,...e.color),e={...t.config,...t.yConfig};const o=LS.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?BS(o):NS(o,1,e.invert),_S(o,...e.color),e={...t.config,...t.zConfig};const a=LS.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?BS(a):NS(a,2,e.invert),_S(a,...e.color);const i=CS.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=jt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}function kS(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}function GS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,kS(n)),jt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),FS(e,t)}var US={newInstance:jt.newInstance(GS,"vtkAxesActor"),extend:GS};const zS="resetcamera",WS="orientation",HS={MODE_RESET_CAMERA:zS,MODE_ORIENTATION:WS,MODE_SAME:"same"};function jS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===WS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===zS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const KS={mode:WS,focalPoint:[0,0,0],distance:6.8,active:!0};function $S(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),jS(e,t)}var qS={newInstance:Dt($S,"vtkCameraSynchronizer"),extend:$S,SynchronizationMode:HS};const XS={},YS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=qS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:qS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ZS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;XS[r]||(XS[r]={});const o=XS[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=qS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];YS[e.type]?o[r]=new YS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const QS={},JS=/instance:\${([^}]+)}/,eA={},tA=[],nA={},rA={vtkPoints:Sc,vtkCellArray:vc,vtkDataArray:Ns};function oA(e){return e.map((e=>JS.exec(e))).filter((e=>e)).map((e=>e[1]))}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),aA(e,t)})),t}function iA(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=QS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function sA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=QS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function lA(){Object.keys(QS).forEach((e=>{delete QS[e]}))}function cA(){Object.keys(eA).forEach((e=>{delete eA[e]}))}function uA(e){if(1===e[1].length)return-1===tA.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===tA.indexOf(e[1][n]);return t}function dA(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(nA[r]){const{key:n,value:o}=nA[r];if(!n||e.properties[n]===o)return void tA.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=sA(r,{managedInstanceId:t}),n.registerInstance(t,o)),iA(r,o,e,n)})),t.calls&&t.calls.filter(uA).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=JS.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=rA[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function pA(e,t,n){eA[t.id]||dA(e,t,n),eA[t.id]=!0}function fA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function gA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function mA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=gA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=gA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),fA(t.getPointData(),i.pointData),fA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=dA(t,s,r);return r.end(),l}}const hA=mA(["points","polys","verts","lines","strips"]),vA=mA([]);function yA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dA;sA||iA?QS[e]={build:t,update:n}:delete QS[e]}const TA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},bA={vtkAxesActor:{build:US.newInstance,update:dA},vtkRenderWindow:{build:vv.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(uA).filter((e=>"removeRenderer"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),dA(e,t,n),ZS(e,t,n)}},vtkRenderer:{build:uv.newInstance,update:function(e,t,n){dA(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=aA(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(uA).filter((e=>"removeViewProp"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:Nl.newInstance,update:dA},vtkCamera:{build:$h.newInstance,update:pA},vtkPolyData:{build:Cu.newInstance,update:hA},vtkImageData:{build:vl.newInstance,update:vA},vtkMapper:{build:uc.newInstance,update:dA},vtkGlyph3DMapper:{build:AC.newInstance,update:dA},vtkProperty:{build:ms.newInstance,update:dA},vtkActor:{build:bs.newInstance,update:dA},vtkLight:{build:Zh.newInstance,update:dA},vtkColorTransferFunction:{build:hC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Pu.newInstance,update:dA},vtkVolume:{build:UC.newInstance,update:dA},vtkVolumeMapper:{build:qC.newInstance,update:dA},vtkVolumeProperty:{build:NC.newInstance,update:dA},vtkImageSlice:{build:aS.newInstance,update:dA},vtkImageMapper:{build:hS.newInstance,update:dA},vtkImageProperty:{build:eS.newInstance,update:dA},vtkPiecewiseFunction:{build:RC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:$u.newInstance,update:dA},vtkScalarBarActor:{build:Fp.newInstance,update:dA}};function xA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&lA(),Object.keys(bA).forEach((e=>{const t=bA[e];yA(e,t.build,t.update)}))}function CA(){Object.keys(TA).forEach((e=>{TA[e].forEach((t=>{QS[t]=QS[e]}))}))}xA(),CA(),nA.vtkPVLight={};var SA={build:sA,update:iA,genericUpdater:dA,oneTimeGenericUpdater:pA,setTypeMapping:yA,clearTypeMapping:lA,getSupportedTypes:function(){return Object.keys(QS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return cA();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete eA[e]})),r},updateRenderWindow:function(e,t,n){return iA("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){nA[e]={key:t,value:n}},setDefaultMapping:xA,applyDefaultAliases:CA,alwaysUpdateCamera:function(){yA("vtkCamera",$h.newInstance),CA()}};const AA={};function IA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Wm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function wA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function PA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Et(t,n,"progressEvent"),Et(t,n,"progressDone"),t}function OA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function RA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=AA[e];return t||(t={...IA(),...wA(),...PA(),...OA()},AA[e]=t),t}function MA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),SA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){SA.clearOneTimeUpdaters(a())}}}function EA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=RA(t.synchronizerContextName));const n=MA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const DA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function VA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DA,n),vv.extend(e,t),bt(e,t,["synchronizerContext"]),EA(e,t)}var LA={newInstance:Dt(VA,"vtkSynchronizableRenderWindow"),extend:VA,getSynchronizerContext:RA,setSynchronizerContext:function(e,t){AA[e]=t},clearSynchronizerContext:function(e){if(e&&AA[e]&&delete AA[e],!e){const e=Object.keys(AA);for(let t=0;t<e.length;t++)delete AA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=MA(e,RA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:wA,createArrayHandler:IA,createProgressHandler:PA,createSceneMtimeHandler:OA,vtkObjectManager:SA};const{vtkErrorMacro:BA,vtkDebugMacro:NA}=jt;let _A=0;function FA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function kA(e){return"/"===e[0]?e.substr(1):e}const GA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=FA(kA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=FA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=kA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=FA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Mh(Ph(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Wm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(NA(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&BA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--_A&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};jm("html",(e=>GA));const{vtkErrorMacro:UA,vtkDebugMacro:zA}=jt;function WA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const HA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new $m(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Oh)return Oh.encode(e);var o=e.length,a=new $m(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new $m(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return hh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Lh(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||UA("ERROR!!! zip not ready...");const u=WA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Mh(Ph(new Uint8Array(e.buffer))):e.buffer=Ph(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Nh!==e.ref.encode&&Nh&&(zA(`Swap bytes of ${e.name}`),_h(e.buffer,xs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&UA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Mh(Ph(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Mh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Mh(Ph(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Mh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Mh(Lh(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Mh(s))},fetchImage(e,n){const a=WA(n);t||UA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=zm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Ph(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};jm("zip",(e=>HA(e)));var jA=n(892),KA=n.n(jA),$A=n(760),qA=n.n($A),XA=n(311),YA=n.n(XA),ZA=n(192),QA=n.n(ZA),JA=n(60),eI=n.n(JA),tI=n(865),nI=n.n(tI),rI=n(34),oI={};oI.styleTagTransform=nI(),oI.setAttributes=QA(),oI.insert=YA().bind(null,"head"),oI.domAPI=qA(),oI.insertStyleElement=eI(),KA()(rI.Z,oI);var aI=rI.Z&&rI.Z.locals?rI.Z.locals:void 0;let iI=!0;function sI(e){e.preventDefault(),e.stopPropagation()}function lI(e,t){iI=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=nC.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=LA.getSynchronizerContext(),a=LA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",aI.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?zh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Km("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):zh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Km("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Wm(t.base64Str),n=Km("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function cI(e){iI=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(aI.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${aI.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){sI(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];lI(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",sI)}const uI=ny();if(uI.url||uI.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(aI.fullScreen),t.style.margin="0",t.style.padding="0"),iI=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>lI(n,uI)))}setTimeout((()=>{iI&&cI()}),100),window.OfflineLocalView={initLocalFileLoader:cI,load:lI}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(819),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "UEsDBBQAAAAIACCV9lqCPkp8S7sEALvJDQAKAAAAaW5kZXguanNvboy9XVPqTNSu+1dWvafsKhARwz5jdDOZTESMiBhPdmHASCMGRIy4/vxuvrrp61m7as+q9+N6OoTOuO+R7jEC+L//5228fpuu/+f//l//+3+uKpOL1+i6PpnUG69p9TpNG6/VWu2icVVp1KaX1//PZVS/qLzuj929zP4//79f83/9r//52i6nu5f8ec/HX5fV5ufneLv7799f891/tv/nLp99fK13/y3NP76mH1+7/75dfzwsm/afjnb/u5lffsY7Luta8/Tvzv5PCXwaf1Xft8v/w3jjyI+T33/LMz6NR0e+yS/byzM+jV8fWX6v9fKMT+P1I1+W6uXlGZ/Gr468+VeKlmd8Gq8def6orpZnfBq/PPI4a1eXZ3warx45vu5ul2d8Gr848t92/3t5xqfxypEb0l8vz/g0/nvk33SQL8/4NL498vJj9L4849P4z0mf7Xi2POPTeHHk0e10ujzj0/j3kXvJ7GV5xqfxzZHVwyJZnvFp/OvItc1iuDzj0/j6pM/V6n55xqfxzyO/tzb95RmfxldHfnnddpdnfBpfHvl+Vf27POPTeH7S573eWp7xafzjpE9Rl+UZn8YXR87/Nq6XZ3wafz/ycPOnsjzj0/j85O/W7WZ5xqdxc+Sv8f3H8oxP47MjPxfPb8szPo2/Hbk9ehsvz/g0nh15u37f53+G8anL7699fk8xnrr8vdjnb4rxscvP2j4/xxhPXP419/mXYHzk8quzz68Rxocuf3r7/BlifODyY7jPjwHGY+f/dO//GON95+/53t99jPecf/O9f3sY7zp/Fnt/djHecf6r7f3XwXjb+at8nReeT+Mt55+7zW68hXHl/PHythtXGG86/T8eduNNjEe6sv//d/fn3fiJT+O1I+/un7vxGsYrR97d33bjFYwXR97df3bjBcbXR97dH3bja4znR97l7248x/j8yLv82o3PMZ4deef/3XiG8cRdX3N/fQnGYzf/dD//GOMdN7/afn4djDfd+9v4Z559fAofn8yzn3/h55959uc/jdvzx57d+P/nPxWs3ycugSPwNbgOvgLXwJfgKvgCXAH/grfgH3AB/gZvwF/gNfgTvAIvwTn4A7wAv4PnYAOegd/AGXgKTsFjcAIegYfgATgG98E9cBfcAbfB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ef+f+fk34tQb6vkGE3Ho9bd6vjtx6k3z83fEqTfV8w0LceidPOr5HsTp7xnWE3HsP8V+2LsCV/x2/+L5bJ3G4rw/7D+39dlEHHoDnKdl62dx6v3D89n90lycem1b39v6vBCnHu4Pf7yK83nwfOcTcezH+RPs/QaenwfnP4P+Rpzf53H+J1tfTMShx+dDfH+KU4/Ph/t1xKmH869sPSrEEW84b9EV93mDzjMCz/l4/qjzbMV5/7XOU4zFqdfSeS4zh97Fo86zJ057brDOHPtHti4Q7/vGr3I9+MZ57PmLpTi/v49s3cL+R3HoXdrfF4jfI3HeH+e52opjP+5XwJ4d49f5+XkePF9bnPfH/Q6xfysO+1O/I+7zAv392O7Xz/Xruoi/7yVxnncH60fpY//YztM3//ZQX39qv//9NjjPw7U9bw/19X/+n//jf/3P3d7N8e7d7v7B8W1rr3V8cHC/u7t31Dq6be937vY7nf9rd69z1Pr3P//n//q//+fhZv3w3//y//lv/pP/qF/v7E9OnlY3H4ft7vv7TW3/+dfH0v7j//5HcfNxo/94vnr5uHv5MNRtruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqruZqrv8frtT9vNhsR9urSW/2efA1fHq2/3TRO9z5Pjva2dk53hlsdy7/2zC6/3HY/rpazIyvipsd+5//L1lftqCqzrR9QRzEAQUOGRxQVGztdjhzxKEd0BaUq/8reSqs/X7/PuptViCkqp4aUwlbQZ3mbwL5Pz3Pz+Q/LIbRfX2xN+NcPn88Wcv5n+d9fzQzb9CR/7Tf9gVe3zVeUXHyxvR35zBV853Yc9ZHuz7+lv8g/Hng/ae2YWaDsC2nHdsXNX/RHoSv6OPy/E0m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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>

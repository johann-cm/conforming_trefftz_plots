<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},819:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return cI},load:function(){return lI}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return Ee},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],E=r[2],D=Math.hypot(R,M,E);return D<a?null:(R*=D=1/D,M*=D,E*=D,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,P=M*E*s-R*o,O=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),D(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,E=(1-(p+v))*C,D=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=D,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+E*I+L*w),e[14]=n[2]+w-(R*A+D*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],E=t[12],D=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-D)<=a*Math.max(1,Math.abs(h),Math.abs(D))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=Ee,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Et(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Dt(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Et,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Dt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:xt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Et,newInstance:Dt,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>{if(!t._parent)return null;return t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null)},e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=t=>{if(t&&t.length)for(let n=0;n<t.length;++n){const r=t[n];e.addMissingNode(r)}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function En(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Dn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Er=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Dr(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Dr((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Dr((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Er):kr:t instanceof dr?Er:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Eo,ceil:Do,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Ea(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Da=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Eo,ceil:Do,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Ea,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Da,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};function Wa(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{jt.vtkErrorMacro("not implemented")}}const Ha={};function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ha,n),jt.obj(e,t),jt.setGet(e,t,["transform"]),Wa(e,t)}var Ka={newInstance:jt.newInstance(ja,"vtkImplicitFunction"),extend:ja};const $a=1e-6,qa="coincide",Xa="disjoint";function Ya(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Za(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function Qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Ja(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function ei(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*$a:s*$a,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function ti(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<$a){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=qa:o.error=Xa,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const ni={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ya,projectPoint:Za,projectVector:Qa,generalizedProjectPoint:Ja,intersectWithLine:ei,intersectWithPlane:ti,DISJOINT:Xa,COINCIDE:qa};function ri(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ya(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Za(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>Qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Ja(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>ei(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>ti(e,n,t.origin,t.normal)}const oi={normal:[0,0,1],origin:[0,0,0]};function ai(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oi,n),Ka.extend(e,t,n),jt.setGetArray(e,t,["normal","origin"],3),ri(e,t)}var ii={newInstance:jt.newInstance(ai,"vtkPlane"),extend:ai,...ni};const si=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function li(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ci(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ui(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function di(e){return ui(e,si)}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function fi(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)pi(e,...t[n]);else for(let n=0;n<t.length;n+=3)pi(e,...t.slice(n,n+3));return e}function gi(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function mi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function hi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function vi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function yi(e,t,n,r){return!!ci(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function Ti(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function bi(e,t){return e[2*t+1]-e[2*t]}function xi(e){return[bi(e,0),bi(e,1),bi(e,2)]}function Ci(e){return e.slice(0,2)}function Si(e){return e.slice(2,4)}function Ai(e){return e.slice(4,6)}function Ii(e){const t=xi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function wi(e){if(ci(e)){const t=xi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Pi(e){return[e[0],e[2],e[4]]}function Oi(e){return[e[1],e[3],e[5]]}function Ri(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Mi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Ei(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Di(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Mi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return di(n),fi(n,r)}function Vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Li(e,t,n,r){const o=[].concat(si),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Bi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ni(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ii.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function _i(e,t){if(!ci(e)||!ci(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Fi(e,t){if(!ci(e)||!ci(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function ki(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Gi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ii.evaluate(n,t,l)}let i=2;for(;i--&&!(Ri(o[r[i][0]],o[r[i][4]])&&Ri(o[r[i][1]],o[r[i][5]])&&Ri(o[r[i][2]],o[r[i][6]])&&Ri(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ui{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(si))}getBounds(){return this.bounds}equals(e){return li(this.bounds,e)}isValid(){return ci(this.bounds)}setBounds(e){return ui(this.bounds,e)}reset(){return di(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return pi(this.bounds,...t)}addPoints(e){return fi(this.bounds,e)}addBounds(e,t,n,r,o,a){return gi(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return mi(this.bounds,e,t,n)}setMaxPoint(e,t,n){return hi(this.bounds,e,t,n)}inflate(e){return vi(this.bounds,e)}scale(e,t,n){return yi(this.bounds,e,t,n)}getCenter(){return Ti(this.bounds)}getLength(e){return bi(this.bounds,e)}getLengths(){return xi(this.bounds)}getMaxLength(){return Ii(this.bounds)}getDiagonalLength(){return wi(this.bounds)}getMinPoint(){return Pi(this.bounds)}getMaxPoint(){return Oi(this.bounds)}getXRange(){return Ci(this.bounds)}getYRange(){return Si(this.bounds)}getZRange(){return Ai(this.bounds)}getCorners(e){return Mi(this.bounds,e)}computeCornerPoints(e,t){return Ei(this.bounds,e,t)}computeLocalBounds(e,t,n){return Li(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Di(this.bounds,e,t)}computeScale3(e){return Vi(this.bounds,e)}cutWithPlane(e,t){return Gi(this.bounds,e,t)}intersectBox(e,t,n,r){return Bi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ni(this.bounds,e,t)}intersect(e){return _i(this.bounds,e)}intersects(e){return Fi(this.bounds,e)}containsPoint(e,t,n){return ki(this.bounds,e,t,n)}contains(e){return Fi(this.bounds,e)}}var zi,Wi={newInstance:function(e){const t=e&&e.bounds;return new Ui(t)},equals:li,isValid:ci,setBounds:ui,reset:di,addPoint:pi,addPoints:fi,addBounds:gi,setMinPoint:mi,setMaxPoint:hi,inflate:vi,scale:yi,scaleAboutCenter:function(e,t,n,r){if(!ci(e))return!1;const o=Ti(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],yi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:Ti,getLength:bi,getLengths:xi,getMaxLength:Ii,getDiagonalLength:wi,getMinPoint:Pi,getMaxPoint:Oi,getXRange:Ci,getYRange:Si,getZRange:Ai,getCorners:Mi,computeCornerPoints:Ei,computeLocalBounds:Li,transformBounds:Di,computeScale3:Vi,cutWithPlane:Gi,intersectBox:Bi,intersectPlane:Ni,intersect:_i,intersects:Fi,containsPoint:ki,contains:function(e,t){return!!Fi(e,t)&&!!ki(e,...Pi(t))&&!!ki(e,...Oi(t))},INIT_BOUNDS:si};function Hi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function ji(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Ki(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function $i(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}zi=new i(4),i!=Float32Array&&(zi[0]=0,zi[1]=0,zi[2]=0,zi[3]=0);var qi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),ji(),ji(),ie();var Xi={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Yi}=Xi;function Zi(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function Qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Zi("pick"),e.hasKey=Zi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Yi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Yi.DISPLAY)}const Ji={allocatedRenderTime:10,coordinateSystem:Yi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp"),extend:es,...Xi};function ns(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=ji();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return N(e,t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=ji();Ki(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);T(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>Wi.getCenter(t.bounds),e.getLength=()=>Wi.getLength(t.bounds),e.getXRange=()=>Wi.getXRange(t.bounds),e.getYRange=()=>Wi.getYRange(t.bounds),e.getZRange=()=>Wi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const rs={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function os(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rs,n),ts.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,ns(e,t)}var as={newInstance:jt.newInstance(os,"vtkProp3D"),extend:os};const is={FLAT:0,GOURAUD:1,PHONG:2},ss={POINTS:0,WIREFRAME:1,SURFACE:2};var ls={Shading:is,Representation:ss,Interpolation:is};const{Representation:cs,Interpolation:us}=ls;function ds(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ps(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ds("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ds("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(us.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(us.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(us.PHONG),e.getInterpolationAsString=()=>jt.enumToString(us,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(cs.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(cs.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(cs.POINTS),e.getRepresentationAsString=()=>jt.enumToString(cs,t.representation)}const fs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:us.GOURAUD,representation:cs.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ps(e,t)}var ms={newInstance:jt.newInstance(gs,"vtkProperty"),extend:gs,...ls};const{vtkDebugMacro:hs}=jt;function vs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ms.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){hs("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const ys={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Ts(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),vs(e,t)}var bs={newInstance:jt.newInstance(Ts,"vtkActor"),extend:Ts};const xs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},Cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ss={DefaultDataType:Cs.FLOAT,DataTypeByteSize:xs,VtkDataTypes:Cs};const{vtkErrorMacro:As}=Kt,{DefaultDataType:Is}=Ss,ws=1e-6;function Ps(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function Os(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ps(r,0,1)}return Ps(e,t<0?0:t,n)}function Rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function Ms(e){return Object.prototype.toString.call(e).slice(8,-1)}const Es={computeRange:Os,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ps,getDataType:Ms,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Ds(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=Os(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ws;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=Ms(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||As("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Vs={name:"",numberOfComponents:1,dataType:Is,rangeTuple:[0,0]};function Ls(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Vs,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=Ms(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Ds(e,t)}const Bs=Dt(Ls,"vtkDataArray");var Ns={newInstance:Bs,extend:Ls,...Es,...Ss};function _s(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Fs={clippingPlanes:[]};var ks=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fs,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),_s(e,t)};function Gs(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Wi.isValid(n)?Wi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Wi.getDiagonalLength(t)}}const Us=e=>({bounds:[...Wi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var zs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Us(n)),ks(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Gs(e,t)};const{vtkErrorMacro:Ws,vtkWarningMacro:Hs}=jt;function js(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Ws("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ns.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Hs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Ws("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ns.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const Ks={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function $s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ks,n),jt.obj(e,t),js(e,t)}var qs={newInstance:jt.newInstance($s,"vtkFieldData"),extend:$s};const Xs={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ys={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Xs,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Zs,AttributeCopyOperations:Qs}=Ys,{vtkWarningMacro:Js}=jt;function el(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Zs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Qs[e]]=Object.keys(Zs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Zs[t]]=!0,e)),[])})),t.copyAttributeFlags[Qs.COPYTUPLE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.INTERPOLATE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.COPYTUPLE][Zs.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ns.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const tl={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tl,n),qs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),el(e,t)}var rl={newInstance:jt.newInstance(nl,"vtkDataSetAttributes"),extend:nl,...Ys};const ol=["pointData","cellData","fieldData"];function al(e,t){t.classHierarchy.push("vtkDataSet"),ol.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=rl.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),ol.forEach((n=>{t[n]=rl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const il={};function sl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,il,n),jt.obj(e,t),jt.setGet(e,t,ol),al(e,t)}var ll={newInstance:jt.newInstance(sl,"vtkDataSet"),extend:sl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const cl={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ul={StructuredType:cl};const{StructuredType:dl}=ul;var pl={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?dl.EMPTY:3===t?dl.XYZ_GRID:2===t?e[0]===e[1]?dl.YZ_PLANE:e[2]===e[3]?dl.XZ_PLANE:dl.XY_PLANE:1===t?e[0]<e[1]?dl.X_LINE:e[2]<e[3]?dl.Y_LINE:dl.Z_LINE:dl.SINGLE_POINT},...ul};const{vtkErrorMacro:fl}=jt;function gl(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return fl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=pl.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)fl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void fl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return fl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case cl.EMPTY:return null;case cl.SINGLE_POINT:break;case cl.X_LINE:o[0]=n;break;case cl.Y_LINE:o[1]=n;break;case cl.Z_LINE:o[2]=n;break;case cl.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case cl.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case cl.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case cl.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:fl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Wi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Wi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Wi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Wi.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Ea(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ea(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return fl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return fl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const ml={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:cl.EMPTY};function hl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ml,n),ll.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),gl(e,t)}var vl={newInstance:jt.newInstance(hl,"vtkImageData"),extend:hl};const yl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Tl={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:yl},bl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:xl,VectorMode:Cl}=Tl,{VtkDataTypes:Sl}=Ns,{ColorMode:Al}=bl,{vtkErrorMacro:Il}=jt;function wl(e){return e}function Pl(e){return Math.floor(255*e+.5)}function Ol(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Cl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Cl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Cl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)Il("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===Al.DEFAULT&&(t.getDataType()===Sl.UNSIGNED_CHAR||t.getDataType()===Sl.UNSIGNED_CHAR_CLAMPED)||n===Al.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Sl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ns.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,xl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,xl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Cl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Cl.MAGNITUDE||1!==c&&1!==s||(i=Cl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Cl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Cl.RGBCOLORS:break;case Cl.MAGNITUDE:default:{const o=Ns.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Pl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Sl.UNSIGNED_CHAR)return n;const i=Ns.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Sl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=wl;switch(n.getDataType()!==Sl.FLOAT&&n.getDataType()!==Sl.DOUBLE||(s=Pl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return Il("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==Al.DEFAULT||n.getDataType()!==Sl.UNSIGNED_CHAR)&&r!==Al.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Rl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Cl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Ml(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rl,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Ol(e,t)}var El={newInstance:jt.newInstance(Ml,"vtkScalarsToColors"),extend:Ml,...Tl};const{vtkErrorMacro:Dl}=jt;function Vl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Dl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==Cs.UNSIGNED_CHAR)return Dl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Bl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ll,n),El.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Vl(e,t)}var Nl={newInstance:jt.newInstance(Bl,"vtkLookupTable"),extend:Bl};const _l={Off:0,PolygonOffset:1};let Fl=_l.PolygonOffset,kl=_l.Off;const Gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Ul(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=kl===e;return kl=e,t}var zl={Resolve:_l,getResolveCoincidentTopologyAsString:function(){return Gl[kl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Fl},getResolveCoincidentTopology:function(){return kl},setResolveCoincidentTopology:Ul,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=Fl===e;return Fl=e,t},setResolveCoincidentTopologyToDefault:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToOff:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Ul(_l.PolygonOffset)}};function Wl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=jt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Hl=["Polygon","Line","Point"],jl={modified:()=>{}};Wl(jl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Hl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Kl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(zl).forEach((t=>{e[t]=zl[t]})),Object.keys(jl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=jl[t]})),Wl(e,t.topologyOffset,Hl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=jl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:jl,otherStaticMethods:zl,CATEGORIES:Hl,Resolve:_l};const $l={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ql={PassTypes:$l};const{FieldAssociations:Xl}=ll,{staticOffsetAPI:Yl,otherStaticMethods:Zl}=Kl,{ColorMode:Ql,ScalarMode:Jl,GetArray:ec}=bl,{VectorMode:tc}=Tl,{VtkDataTypes:nc}=Ns;function rc(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function oc(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function ac(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const ic=new WeakMap;function sc(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(Ql,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(Jl,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Jl.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Jl.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Jl.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Jl.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_FIELD_DATA){const t=e.getFieldData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale();i&&Nl.getLogRange(a,a);const s=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,u=n**3-3,d=4094,p=2,f=r?u:d;t.numberOfColorsInRange=Math.min(Math.max(e,p),f);const g=t.numberOfColorsInRange+3,m=t.numberOfColorsInRange+2,h=r?[Math.min(Math.ceil(g/n**0),n),Math.min(Math.ceil(g/n**1),n),Math.min(Math.ceil(g/n**2),n)]:[m,2,1],v=h[0]*h[1]*h[2],y=new Float64Array(v);y.fill(NaN);const T=t.numberOfColorsInRange,b=T+2,x=[0,0,0],C=a[0],S=a[1]-a[0];for(let e=0;e<b;++e){const t=C+S*(e-1)/(T-1);y[(c=h,(l=x)[0]+c[0]*(l[1]+c[1]*l[2]))]=i?10**t:t,oc(x,h)}const A=Ns.newInstance({numberOfComponents:1,values:y}),I=t.lookupTable.mapScalars(A,t.colorMode,0);t.colorTextureMap=vl.newInstance(),t.colorTextureMap.setDimensions(h),t.colorTextureMap.getPointData().setScalars(I),t.lookupTable.setAlpha(s)}var l,c;const u=t.lookupTable.getVectorMode()===tc.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=ic.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(r-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(r+1)/(p-d),v=e.getData(),y=e.getNumberOfTuples(),T=e.getNumberOfComponents(),b=t<0||t>=T,x=o[2]<=1?2:3,C=Ns.newInstance({numberOfComponents:x,values:new Float32Array(y*x)}),S=C.getData(),A=[0,0,0];ac(A,r+2,o);let I=0,w=0;const P=[.5,.5,.5];for(let e=0;e<y;++e){let e;if(b){let t=0;for(let e=0;e<T;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(I+=T,a&&(e=Nl.applyLogScale(e,n,n)),_a(e))P[0]=A[0],P[1]=A[1],P[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>r&&(t=r+1),ac(P,t,o)}else{P[1]=.49;const t=(e-f)*g;P[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=P[e]}return ic.set(e,{stringHash:l,textureCoordinates:C}),C}(n,u,a,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),i,r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Ql.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Ql.DEFAULT&&e.getDataType()===nc.UNSIGNED_CHAR||t.colorMode===Ql.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=rc("AcquireInvertibleLookupTable"),e.valueToColor=rc("ValueToColor"),e.colorToValue=rc("ColorToValue"),e.useInvertibleColorFor=rc("UseInvertibleColorFor"),e.clearInvertibleColor=rc("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer($l.ID_LOW24),o=e.getRawPixelBuffer($l.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Xl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Xl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===$l.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer($l.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===$l.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer($l.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const lc={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lc,n),zs(e,t,n),jt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Kl.implementCoincidentTopologyMethods(e,t),sc(e,t)}var uc={newInstance:jt.newInstance(cc,"vtkMapper"),extend:cc,...Yl,...Zl,...bl};function dc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function pc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const fc={extractCellSizes:dc,getNumberOfCells:pc};function gc(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=pc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=dc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function mc(e){return{empty:!0,numberOfComponents:1,dataType:Cs.UNSIGNED_INT,...e}}function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ns.extend(e,t,mc(n)),gc(e,t)}var vc={newInstance:jt.newInstance(hc,"vtkCellArray"),extend:hc,...fc};const{vtkErrorMacro:yc}=jt,Tc=[1,-1,1,-1,1,-1];function bc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return yc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Tc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const xc={empty:!0,numberOfComponents:3,dataType:Cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),Ns.extend(e,t,n),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkPoints"),extend:Cc};function Ac(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const Ic={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),jt.obj(e,t),t.points||(t.points=Sc.newInstance()),jt.get(e,t,["points","pointsIds"]),Ac(e,t)}var Pc={newInstance:jt.newInstance(wc,"vtkCell"),extend:wc};function Oc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Pc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Pc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const Rc={array:null,maxId:0,extend:0};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),jt.obj(e,t),Oc(e,t)}var Ec={newInstance:jt.newInstance(Mc,"vtkCellLinks"),extend:Mc};const Dc=0,Vc=1,Lc=2,Bc=3,Nc=4,_c=5,Fc=6,kc=7,Gc=9,Uc=21,zc=41,Wc=42,Hc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],jc={getClassNameFromTypeId:function(e){return e<Hc.length?Hc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Hc.findIndex(e)},isLinear:function(e){return e<Uc||e===zc||e===Wc},hasSubCells:function(e){return e===Fc||e===Nc||e===Lc}};function Kc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Dc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const $c={size:0,maxId:-1,extend:1e3};function qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$c,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Kc(e,t)}var Xc={newInstance:jt.newInstance(qc,"vtkCellTypes"),extend:qc,...jc},Yc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Zc}=Yc;function Qc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function Jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Qc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Zc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Zc.YES_INTERSECTION:Zc.NO_INTERSECTION}const eu={distanceToLine:Qc,intersection:Jc};function tu(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Zc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Qc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Qc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Qc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Qc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const nu={orientations:null};function ru(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nu,n),Pc.extend(e,t,n),jt.setGet(e,t,["orientations"]),tu(e,t)}var ou={newInstance:jt.newInstance(ru,"vtkLine"),extend:ru,...eu,...Yc};function au(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=Sc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=Sc.newInstance(),t.points.shallowCopy(e.getPoints())}}const iu={};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),ll.extend(e,t,n),jt.setGet(e,t,["points"]),au(e,t)}var lu={newInstance:jt.newInstance(su,"vtkPointSet"),extend:su};function cu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function uu(e,t,n,r){cu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const du={computeNormalDirection:cu,computeNormal:uu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];uu(e,t,n,d),uu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ii.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ii.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[E],P[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function pu(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(uu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ii.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=ou.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),cu(l,c,u,d),ii.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=ou.distanceToLine(e,c,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=ou.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=ou.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=ou.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const fu={};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Pc.extend(e,t,n),pu(e,t)}var mu={newInstance:jt.newInstance(gu,"vtkTriangle"),extend:gu,...du};const hu=["verts","lines","polys","strips"],{vtkWarningMacro:vu}=jt,yu={[Bc]:ou,[Nc]:ou,[_c]:mu};function Tu(e,t){t.classHierarchy.push("vtkPolyData"),hu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=vc.newInstance()})),e.getNumberOfCells=()=>hu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),hu.forEach((n=>{t[n]=vc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?Lc:Vc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Nc:Bc,1===t&&vu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=_c;break;case 4:l[n]=Gc;break;default:l[n]=kc}t<3&&vu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Fc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Xc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Vc:case Lc:o=t.verts;break;case Bc:case Nc:o=t.lines;break;case _c:case Gc:case kc:o=t.polys;break;case Fc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||yu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const bu={};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),lu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),Tu(e,t)}var Cu={newInstance:jt.newInstance(xu,"vtkPolyData"),extend:xu};function Su(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const Au={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),Su(e,t)}const wu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Pu={newInstance:jt.newInstance(Iu,"vtkTexture"),extend:Iu,...wu};const Ou=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Ru=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Mu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Eu=[0,1,0,1,0,1,0,1,2,2,2,2],Du=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Vu=new Float64Array(3),Lu=new Float64Array(3),Bu=new Float64Array(3),Nu=new Float64Array(3),_u=new Float64Array(3),Fu=new Float64Array(3),ku=new Float64Array(16);function Gu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Uu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=go().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}function zu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],Vn(Bu,Vu,r),Bu[0]+=.1,Vn(Lu,Bu,o),Pn(_u,Lu,Vu),Bu[0]-=.1,Bu[1]+=.1,Vn(Lu,Bu,o),Pn(Fu,Lu,Vu);for(let e=0;e<3;e++)_u[e]/=.05*u[0],Fu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],a[0]<-.5?On(Bu,_u,a[0]*i-l.width):a[0]>.5?On(Bu,_u,a[0]*i):On(Bu,_u,a[0]*i-l.width/2),wn(Vu,Vu,Bu),On(Bu,Fu,a[1]*i-l.height/2),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Bu,_u,l.width),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Bu,Fu,l.height),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Bu,_u,l.width),Pn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(ku,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Vu[0]=f[3*u],Vu[1]=f[3*u+1],Vu[2]=f[3*u+2],Vn(Bu,Vu,n),Vu[0]=f[3*u+3],Vu[1]=f[3*u+4],Vu[2]=f[3*u+5],Vn(Nu,Vu,n),Pn(Bu,Bu,Nu);const r=[Bu[0],Bu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Wu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],zu(e,t)}),"vtkCubeAxesActorHelper");function Hu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Wi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Vu[s]=t.dataBounds[a]-.1*r*Ou[a][s],Vu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Vu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Bu,Vu,e),Vu[s]=t.dataBounds[a],Vn(Nu,Vu,e),Pn(Bu,Nu,Bu),Mn(Bu,Bu),i=Bu[2]>o,t.camera.getParallelProjection()||(Mn(Nu,Nu),i=En(Nu,Bu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Du[t][0]].length+2*r[Du[t][1]].length,a+=r[Du[t][0]].length+r[Du[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Mu[e][0],l[3*u+2]=Mu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Du[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Du[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Eu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Ru[a][e];if(1===n[d]){const e=Eu[d],n=3*Mu[d][0],p=3*Mu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Du[a][0]]=.5*(t.dataBounds[2*Du[a][0]]+t.dataBounds[2*Du[a][0]+1]),s[3*l+Du[a][1]]=.5*(t.dataBounds[2*Du[a][1]]+t.dataBounds[2*Du[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Ru[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Gu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Gu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Gu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Wi.setBounds(t.bounds,t.gridActor.getBounds()),Wi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function ju(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Wi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Uu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,ju(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=uc.newInstance(),t.polyData=Cu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=bs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Cu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Hu(e,t)}var $u={newInstance:jt.newInstance(Ku,"vtkCubeAxesActor"),extend:Ku,newCubeAxesActorHelper:Wu,defaultGenerateTicks:Uu};function qu(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Xu={};const Yu=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=$u.newCubeAxesActorHelper(),qu(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Yu);const Zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Qu={ObjectType:Zu};const{ObjectType:Ju}=Qu;function ed(e,t){function n(e){switch(e){case Ju.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Ju.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Ju.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const td={objectType:Ju.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,td,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ed(e,t)}var rd={newInstance:jt.newInstance(nd),extend:nd,...Qu};const{vtkErrorMacro:od}=jt;function ad(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=rd.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===ss.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===ss.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,E=0,D=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];E+=n*n;const r=.5*(t[1]+t[0]);D+=r*r}const V=E>0&&(Math.abs(D)/E>1e6||Math.abs(Math.log10(E))>3||0===E&&D>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,T++)C(A[e],A,e+1,T+a.cellOffset);return t.elementCount=w,e.upload(O,Zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,Zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,ji(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):od("Wrong type for coordScale, expected vec3 or null"):od("Wrong type for coordShift, expected vec3 or null")}}const id={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),rd.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),ad(e,t)}var ld={newInstance:jt.newInstance(sd),extend:sd};const{vtkErrorMacro:cd}=jt;function ud(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return cd(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const dd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkShader"),extend:pd};const{vtkErrorMacro:gd}=jt;function md(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(gd(`Links failed: ${t.error}`),0):(gd(t.error),0):(gd(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.fragmentShader.getError()),0):(gd(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return gd(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(gd("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return gd("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const hd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=fd.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=fd.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=fd.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),md(e,t)}var yd={newInstance:jt.newInstance(vd,"vtkShaderProgram"),extend:vd,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function Td(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const bd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function xd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),Td(e,t)}var Cd={newInstance:jt.newInstance(xd,"vtkOpenGLVertexArrayObject"),extend:xd};const Sd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function Ad(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===ss.POINTS||n===Sd.Points?t.context.POINTS:e===ss.WIREFRAME||n===Sd.Lines||n===Sd.TrisEdges||n===Sd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Sd.Points||r.getProperty().getRepresentation()===ss.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Sd.Points?2:t.primitiveType===Sd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const Id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=yd.newInstance(),t.VAO=Cd.newInstance(),t.CABO=ld.newInstance(),Ad(e,t)}var Pd={newInstance:jt.newInstance(wd),extend:wd,primTypes:Sd};const Od={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Rd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Md={Wrap:Od,Filter:Rd};const Ed=new Float32Array(1),Dd=new Int32Array(Ed.buffer);var Vd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Ed[0]=e;const t=Dd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Ld;const{Wrap:Bd,Filter:Nd}=Md,{VtkDataTypes:_d}=Ns,{vtkDebugMacro:Fd,vtkErrorMacro:kd,vtkWarningMacro:Gd}=Kt,{toHalf:Ud}=Vd;function zd(e,t){t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Nd.LINEAR),e.setMagnificationFilter(Nd.LINEAR)):(e.setMinificationFilter(Nd.NEAREST),e.setMagnificationFilter(Nd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Bd.REPEAT),e.setWrapS(Bd.REPEAT),e.setWrapT(Bd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const n=()=>{if(t.minificationFilter!==Nd.LINEAR&&t.magnificationFilter!==Nd.LINEAR||(void 0===Ld&&(Ld=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,y=i.getExtension("WEBGL_lose_context");return y&&y.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Ld))return t.oglNorm16Ext};function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Vd.toHalf(Vd.fromHalf(e[u][l+s+t])*h*(1-v)+Vd.fromHalf(e[u][l+p+t])*h*v+Vd.fromHalf(e[u][c+s+t])*m*(1-v)+Vd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&n())||e!==_d.UNSIGNED_SHORT&&e!==_d.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Gd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Fd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Gd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(r,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(r,o,n(),e.useHalfFloat()),a||(a||(Fd("Unsupported internal texture type!"),Fd(`Unable to find suitable internal format for T=${r} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=r=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case n()&&!o&&_d.SHORT:return t.context.SHORT;case n()&&!o&&_d.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&_d.SHORT:case o&&_d.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case _d.FLOAT:case _d.VOID:default:return t.context.FLOAT}switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case _d.FLOAT:case _d.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Nd.NEAREST:return t.context.NEAREST;case Nd.LINEAR:return t.context.LINEAR;case Nd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Nd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Nd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Nd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Bd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Bd.REPEAT:return t.context.REPEAT;case Bd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==_d.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==_d.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Ud(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=e.updateArrayDataTypeForGL(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(e.updateArrayDataTypeForGL(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=(r,a,i,s)=>(e.getOpenGLDataType(i),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?i===_d.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=r,t.height=a,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(i,n(),e.useHalfFloat()),e.deactivate(),!0):(kd("Failed to determine texture parameters."),!1)),e.create2DFromImage=r=>{if(e.getOpenGLDataType(_d.UNSIGNED_CHAR),e.getInternalFormat(_d.UNSIGNED_CHAR,4),e.getFormat(_d.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const a=!(t._openGLRenderWindow.getWebgl2()||Fo(r.width)&&Fo(r.height)),i=document.createElement("canvas");i.width=a?_o(r.width):r.width,i.height=a?_o(r.height):r.height,t.width=i.width,t.height=i.height;const s=i.getContext("2d");s.translate(0,i.height),s.scale(1,-1),s.drawImage(r,0,0,r.width,r.height,0,0,i.width,i.height);const l=i;return o(_d.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=l&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,l)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,l),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(_d.UNSIGNED_CHAR,n(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Ns.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.updateVolumeInfoForGL=(r,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(n()&&!i&&r===_d.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(n()&&!i&&r===_d.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(r===_d.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(r===_d.FLOAT||i&&(r===_d.SHORT||r===_d.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=(a,i,s,l,c,u)=>{let d=c,p=u;if(!e.updateVolumeInfoForGL(d,l)&&p){const e=a*i*s,n=structuredClone(t.volumeInfo),r=new Float32Array(e*l);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const c=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<l;e++)r[o]=(p[o]-n.offset[e])*c[e],o++;d=_d.FLOAT,p=r}if(e.getOpenGLDataType(d),e.getInternalFormat(d,l),e.getFormat(d,l),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const f=[p],g=r(e.updateArrayDataTypeForGL(d,f,!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(d)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=g[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,g[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,g[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(d,n(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Ns.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=[],g=[];for(let e=0;e<c;++e)f[e]=0,g[e]=1;if(t.volumeInfo={scale:g,offset:f,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw(n,r,i,c,u,d);const m=n*r*i,h=structuredClone(p);let v=(e,t,n,r,o)=>{e[t]=n},y=_d.UNSIGNED_CHAR;if(u===_d.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=_d.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=_d.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===_d.FLOAT||c>=3)&&(T=4096);let b=1,x=1;m>T*T&&(b=Math.ceil(Math.sqrt(m/(T*T))),x=b);let C=Math.sqrt(m)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===_d.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Wd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Bd.CLAMP_TO_EDGE,wrapT:Bd.CLAMP_TO_EDGE,wrapR:Bd.CLAMP_TO_EDGE,minificationFilter:Nd.NEAREST,magnificationFilter:Nd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),zd(e,t)}const jd=Dt(Hd,"vtkOpenGLTexture");var Kd={newInstance:jd,extend:Hd,...Md};rn("vtkTexture",jd);var $d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",qd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Xd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=yd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Yd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=yd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Zd}=ll,{primTypes:Qd}=Pd,{Representation:Jd,Shading:ep}=ms,{ScalarMode:tp}=uc,{Filter:np,Wrap:rp}=Kd,{vtkErrorMacro:op}=Kt,ap={type:"StartEvent"},ip={type:"EndEvent"},{CoordinateSystem:sp}=ts;function lp(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=yd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=yd.substitute(i,"//VTK::Color::Impl",c).result):i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=yd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=yd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=yd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:op("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=yd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=yd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=yd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=yd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=yd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=yd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=yd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Jd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Qd.Points||o.getRepresentation()===Jd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Qd.Lines||o.getRepresentation()===Jd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Qd.Tris&&e!==Qd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Qd.TrisEdges&&e!==Qd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=yd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==$l.ID_LOW24&&t.lastSelectionState!==$l.ID_HIGH24||(a=yd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=yd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=yd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=yd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case $l.ID_LOW24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case $l.ID_HIGH24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=yd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===ep.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||op(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||op("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||op("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===sp.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():$l.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Jd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===$l.ID_LOW24||t.lastSelectionState===$l.ID_HIGH24);for(let i=Qd.Start;i<Qd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Qd.TrisEdges||i===Qd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ip),!t.currentInput)return void op("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==tp.USE_CELL_DATA&&a!==tp.USE_CELL_FIELD_DATA&&a!==tp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===tp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==ep.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Kd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(np.NEAREST),e.setMagnificationFilter(np.NEAREST),e.setWrapS(rp.CLAMP_TO_EDGE),e.setWrapT(rp.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Jd.SURFACE;for(let n=Qd.Start;n<Qd.End;n++)n!==Qd.TrisEdges&&n!==Qd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Jd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const cp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:$l.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=Qd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),lp(e,t)}const dp=Dt(up,"vtkOpenGLPolyDataMapper");var pp={newInstance:dp,extend:up};rn("vtkMapper",dp);const{ColorMode:fp,ScalarMode:gp,GetArray:mp}=bl;function hp(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(fp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(gp,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===gp.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===gp.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===gp.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===gp.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_FIELD_DATA){const t=e.getFieldData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const vp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),ks(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),hp(e,t)}var Tp={newInstance:jt.newInstance(yp,"vtkMapper2D"),extend:yp};const bp=1,{primTypes:xp}=Pd,{ScalarMode:Cp}=Tp,{vtkErrorMacro:Sp}=Kt,Ap={type:"StartEvent"},Ip={type:"EndEvent"};function wp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=xp.Start;e<xp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Ip),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Sp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Cp.USE_CELL_DATA&&a!==Cp.USE_CELL_FIELD_DATA&&a!==Cp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Cp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Sc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[xp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[xp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[xp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[xp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=xp.Start;a<xp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=yd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=yd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=yd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=yd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=yd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=yd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=yd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=yd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=yd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Sp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Sp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Sp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===bp?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Pp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Op=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=xp,t.tmpMat4=g(new Float64Array(16));for(let e=xp.Start;e<xp.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),wp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",Op);const{VectorMode:Rp}=El;function Mp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Ep(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Vp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Mp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Mp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Mp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Rp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ns.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Lp=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=uc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Cu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=bs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Vp(e,t)}),"vtkScalarBarActorHelper");function Bp(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Ep(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dp())}}function Np(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Np(n)),t.autoLayout||(t.autoLayout=Ep(0,t)),t.generateTicks||(t.generateTicks=Dp()),bs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Bp(e,t)}var Fp={newInstance:jt.newInstance(_p,"vtkScalarBarActor"),extend:_p,newScalarBarActorHelper:Lp};function kp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gp={};const Up=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Fp.newScalarBarActorHelper(),kp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Up);const{vtkErrorMacro:zp}=Kt;function Wp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ns.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Hp={context:null};const jp=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Zt.extend(e,t,n),t.openGLTexture=Kd.newInstance(),t.tris=Pd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Wp(e,t)}));rn("vtkSkybox",jp);const{FieldAssociations:Kp}=ll;function $p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const qp={fieldAssociation:Kp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),$p(e,t)}var Yp={newInstance:jt.newInstance(Xp,"vtkHardwareSelector"),extend:Xp};function Zp(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Kd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Rd.LINEAR),r.setMagnificationFilter(Rd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,Cs.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const Qp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Zp(e,t)}var ef={newInstance:Dt(Jp,"vtkFramebuffer"),extend:Jp};function tf(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const nf={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function rf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nf,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),tf(e,t)}var of={newInstance:jt.newInstance(rf,"vtkSelectionNode"),extend:rf,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:af}=ql,{SelectionContent:sf,SelectionField:lf}=of,{FieldAssociations:cf}=ll,{vtkErrorMacro:uf}=jt;function df(e){return`${e.propID} ${e.compositeID}`}function pf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ff(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function gf(e,t){let n=t;return n<<=24,n|=e,n}function mf(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ff(n[0],n[1],e.pixBuffer[af.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ff(n[0],n[1],e.pixBuffer[af.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[af.ID_LOW24]&&0===pf(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area))return a;const s=ff(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area),l=ff(n[0],n[1],e.pixBuffer[af.ID_HIGH24],e.area);return a.attributeID=gf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=mf(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=mf(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=mf(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function hf(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=of.newInstance();switch(l.setContentType(sf.INDICES),e){case cf.FIELD_ASSOCIATION_CELLS:l.setFieldType(lf.CELL);break;case cf.FIELD_ASSOCIATION_POINTS:l.setFieldType(lf.POINT);break;default:uf("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function vf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=mf(e,[n,t],0,u);if(r&&r.valid){const t=df(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return hf(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function yf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return vf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return uf("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=af.MIN_KNOWN_PASS;t.currentPass<=af.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===af.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=af.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===af.ID_HIGH24){if(t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===cf.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===af.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ff(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===af.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===af.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(af,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ff(e[0],e[1],t.pixBuffer[af.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ff(e[0],e[1],t.pixBuffer[af.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[af.ID_LOW24]&&0===pf(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area))return a;const s=ff(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area),l=ff(e[0],e[1],t.pixBuffer[af.ID_HIGH24],t.area);return a.attributeID=gf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=df(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return hf(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const Tf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Yp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),yf(e,t)}var xf={newInstance:jt.newInstance(bf,"vtkOpenGLHardwareSelector"),extend:bf,...ql};const{vtkErrorMacro:Cf}=Kt,{Representation:Sf}=ms,{ObjectType:Af}=rd,{PassTypes:If}=xf,wf={type:"StartEvent"},Pf={type:"EndEvent"};function Of(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(wf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Pf),!t.currentInput)return void Cf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=yd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=yd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=yd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=yd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=yd.substitute(o,"//VTK::Color::Impl",s).result,o=yd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=yd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=yd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=yd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=yd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===Sf.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===If.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Cf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Cf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=rd.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=rd.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=rd.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=rd.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,Af.ARRAY_BUFFER),t.normalBuffer.upload(n,Af.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),Af.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Af.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Rf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Mf=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),pp.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),Of(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",Mf);const{vtkErrorMacro:Ef}=jt;class Df{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Vf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Ef("Invalid or missing input");const r=Cu.newInstance();r.shallowCopy(n);const o=new Df,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(vc.newInstance({values:c,name:"faces"})),t[0]=r}}const Lf={};function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),jt.obj(e,t),jt.algo(e,t,1,1),Vf(e,t)}var Nf={newInstance:jt.newInstance(Bf,"vtkClosedPolyLineToSurfaceFilter"),extend:Bf};const{vtkErrorMacro:_f}=Kt;function Ff(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void _f("Invalid or missing input");if(!t.cutFunction)return void _f("Missing cut function");const o=Cu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const kf={cutFunction:null,cutScalars:null,cutValue:0};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Ff(e,t)}var Uf={newInstance:Dt(Gf,"vtkCutter"),extend:Gf};const zf=e=>e,Wf=1e-6;class Hf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:zf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=En(n,r);return a>=1||(Dn(this.tmp,n,r),Sn(this.tmp)<Wf&&(Dn(this.tmp,[1,0,0],e),Sn(this.tmp)<Wf&&Dn(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var jf=function(){return new Hf(!0)},Kf=function(){return new Hf(!1)};const $f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],qf=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Xf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Cu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Ns.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Ns.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&jf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Kf().translate(...t.center).apply(o),t.matrix){Kf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Kf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Yf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=vc.newInstance({values:Uint16Array.from(qf)}),t._lineCells=vc.newInstance({values:Uint16Array.from($f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),Xf(e,t)}var Qf={newInstance:jt.newInstance(Zf,"vtkCubeSource"),extend:Zf};const{vtkErrorMacro:Jf}=jt;function eg(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Jf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Jf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const tg={};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=Qf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),eg(e,t)}var rg={newInstance:jt.newInstance(ng,"vtkImageDataOutlineFilter"),extend:ng};let og;function ag(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>og({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const ig={preMultiplyFlag:!1,matrix:[...vo]};function sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),ag(e,t)}og=jt.newInstance(sg,"vtkTransform");var lg={newInstance:og,extend:sg};function cg(e,t,n){return e?`${e.getMTime()}-${t}-${n}`:"0"}function ug(e,t){return`${e.getMTime()}A${t.getMTime()}`}const dg={NEAREST:0,LINEAR:1};var pg={InterpolationType:dg};const{vtkErrorMacro:fg}=Kt;function gg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function mg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera());const o=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),o&&!o.isDeleted()&&o!==t._openGLRenderWindow&&n(o),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):fg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.openGLTexture.setMinificationFilter(Rd.LINEAR),t.openGLTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()?.getScalars();if(!a)return;const i=a.getNumberOfComponents();let s=ug(o,a);const l=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(l?.oglObject?.getHandle()&&l?.hash===s)t.openGLTexture=l.oglObject;else{t.openGLTexture=Kd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a),t._openGLRenderWindow.setGraphicsResourceForObject(a,t.openGLTexture,s),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a}const c=r.getProperty(),u=c.getIndependentComponents(),d=u?i:1,p=u?2*d:1,f=c.getRGBTransferFunction();s=cg(f,u,d);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===s)t.colorTexture=g.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*p*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=c.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,s),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const m=c.getPiecewiseFunction();s=cg(m,u,d);const h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===s)t.pwfTexture=h.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),m){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=c.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.pwfTexture,s),m!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=m)}const v=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==v){const e=Ns.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ns.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:fg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",ss.SURFACE,r)}t.VBOBuildString=v,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",gg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",gg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=yd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:fg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=yd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:fg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=yd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=yd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=yd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ii.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();za.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ns.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Cu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ns.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else fg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const hg={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};const vg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=rg.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Cu.newInstance(),t.cutter=Uf.newInstance(),t.lineToSurfaceFilter=Nf.newInstance(),t.transform=lg.newInstance(),bt(e,t,["openGLTexture"]),mg(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",vg);var yg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Tg}=Kt,{SlicingMode:bg}=yg;function xg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function Cg(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=yd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=yd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Tg("Unsupported number of independent coordinates.")}}if(i=yd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=yd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=yd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Tg("Unsupported number of independent coordinates.")}i=yd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=yd.substitute(i,"//VTK::TCoord::Impl",[...xg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Tg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Tg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===bg.NONE&&(i=bg.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Tg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=cg(f,u,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.oglObject?.getHandle()&&m?.hash===g)t.colorTexture=m.oglObject;else{t.colorTexture=Kd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(n*p*3);if(c===dg.NEAREST?(t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST)):(t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR)),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,g),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const h=l.getPiecewiseFunction(),v=cg(h,u,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.oglObject?.getHandle()&&y?.hash===v)t.pwfTexture=y.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===dg.NEAREST?(t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),h){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);h&&(t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,v),h!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(h,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=h)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===bg.I&&(S=x-C[0]),T===bg.J&&(S=x-C[2]),T!==bg.K&&T!==bg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Kd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===dg.NEAREST?(new Set([1,3,4]).has(s)&&i===Cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.NEAREST)):t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST)):(4!==s||i!==Cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Rd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Rd.LINEAR)),t.openGLTexture.setWrapS(Od.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Od.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[bg.X,bg.Y,bg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===bg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===bg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===bg.K||T===bg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Tg("Reformat slicing not yet supported.");t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const m=Ns.newInstance({numberOfComponents:3,values:r});m.setName("points");const h=Ns.newInstance({numberOfComponents:2,values:l});h.setName("tcoords");const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const y=Ns.newInstance({numberOfComponents:1,values:v});t.tris.getCABO().createVBO(y,"polys",ss.SURFACE,{points:m,tcoords:h,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Kd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Sg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const Ag=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),Cg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",Ag);const Ig=0,wg=1,Pg=2,{vtkErrorMacro:Og}=jt;function Rg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.volumeTexture.setMinificationFilter(Rd.NEAREST),t.volumeTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.volumeTexture.setMinificationFilter(Rd.LINEAR),t.volumeTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=o?.getPointData()?.getScalars();if(!i)return;const s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=ug(o,i);if(s?.oglObject?.getHandle()&&s?.hash===l)t.volumeTexture=s.oglObject;else{t.volumeTexture=Kd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],i,t.renderable.getPreferSizeOverAccuracy()),t._openGLRenderWindow.setGraphicsResourceForObject(i,t.volumeTexture,l),i!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(i,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=i}const c=i.getNumberOfComponents(),u=r.getProperty(),d=u.getIndependentComponents(),p=d?c:1,f=d?2*p:1,g=u.getRGBTransferFunction(),m=cg(g,d,p),h=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(h?.oglObject?.getHandle()&&h?.hash===m)t.colorTexture=h.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*f*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),g){const e=new Float32Array(3*n);for(let t=0;t<p;t++){const o=u.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),d)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,f,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}g&&(t._openGLRenderWindow.setGraphicsResourceForObject(g,t.colorTexture,m),g!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(g,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=g)}const v=u.getPiecewiseFunction(),y=cg(v,d,p),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===y)t.pwfTexture=T.oglObject;else{const n=1024,r=n*f,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),v){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<p;++t){const r=u.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),d)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,f,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);v&&(t._openGLRenderWindow.setGraphicsResourceForObject(v,t.pwfTexture,y),v!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(v,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=v)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ns.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ns.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ns.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Ns.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ns.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ns.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",ss.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Og("Unsupported number of independent coordinates.")}}i=yd.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===wg?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Ig:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case wg:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===Pg&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Og("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Og("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Og(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),Rn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),T(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=jt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Mg={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Eg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mg,n),Zt.extend(e,t,n),Xd(e,t,n),jt.algo(e,t,2,0),t.tris=Pd.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),Rg(e,t)}),"vtkOpenGLImageCPRMapper");function Dg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Eg);const Vg={context:null,keyMatrixTime:null,keyMatrices:null};const Lg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),Dg(e,t)}),"vtkOpenGLImageSlice");function Bg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Lg);const Ng={};const _g=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Bg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",_g);const Fg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},kg={FRACTIONAL:0,PROPORTIONAL:1},Gg={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var Ug={InterpolationType:Fg,OpacityMode:kg,ColorMixPreset:Gg};const zg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Wg={BlendMode:zg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Hg,vtkErrorMacro:jg}=Kt;function Kg(e,t){function n(n){[t._scalars,t._scalarOpacityFunc,t._colorTransferFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(r,o)=>{if(r){const r=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const o=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const a=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(a.getActiveCamera()),e.renderPiece(a,o)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.useIndependentComponents=e=>{const n=e.getIndependentComponents(),r=t.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(),o=e.getColorMixPreset();return n&&r>=2||!!o},e.replaceShaderValues=(n,r,o)=>{const a=o.getProperty();let i=n.Fragment;a.getInterpolationType()===Fg.LINEAR&&(i=yd.substitute(i,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===e.isLabelmapOutlineRequired(o)&&(i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),t.renderable.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND&&(i=yd.substitute(i,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const s=t.scalarTexture.getComponents();i=yd.substitute(i,"//VTK::NumComponents",`#define vtkNumComponents ${s}`).result;const l=e.useIndependentComponents(a);l&&(i=yd.substitute(i,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const c=[],u=[];for(let e=0;e<s;e++)a.getOpacityMode(e)===kg.PROPORTIONAL&&c.push(`#define vtkComponent${e}Proportional`),a.getForceNearestInterpolation(e)&&u.push(`#define vtkComponent${e}ForceNearest`);i=yd.substitute(i,"//VTK::vtkProportionalComponents",c.join("\n")).result,i=yd.substitute(i,"//VTK::vtkForceNearestComponents",u.join("\n")).result;const d=function(e){switch(e){case Gg.CUSTOM:return"//VTK::CustomColorMix";case Gg.ADDITIVE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n\n          vec3 scalarInterp1[2];\n          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);\n          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;\n          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;\n          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n          vec4 normalLight1 = normalMat[1];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        float opacity1 = pwfValue1;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          opacity1 *= gof1;\n        #endif\n        float opacitySum = opacity0 + opacity1;\n        if (opacitySum <= 0.0) {\n          return vec4(0.0);\n        }\n\n        // mix the colors and opacities\n        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);\n        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);\n        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;\n        return vec4(mixedColor, min(1.0, opacitySum));\n";case Gg.COLORIZE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n        #endif\n\n        // mix the colors and opacities\n        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);\n        color = applyAllLightning(color, opacity0, posIS, normalLight0);\n        return vec4(color, opacity0);\n";default:return null}}(a.getColorMixPreset());d&&(i=yd.substitute(i,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,i=yd.substitute(i,"//VTK::CustomComponentsColorMix::Impl",d).result);const p=t.currentInput.getSpatialExtent(),f=t.currentInput.getSpacing(),g=new Float64Array(3);In(g,(p[1]-p[0])*f[0],(p[3]-p[2])*f[1],(p[5]-p[4])*f[2]);const m=Sn(g)/e.getCurrentSampleDistance(r);i=yd.substitute(i,"//VTK::MaximumSamplesValue",`${Math.ceil(m)}`).result,i=yd.substitute(i,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lightComplexity}`).result,t.lightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(i=yd.substitute(i,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(i=yd.substitute(i,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&a.getAmbient()>0&&(i=yd.substitute(i,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const h=l?s:1;t.gopacity=!1;for(let e=0;!t.gopacity&&e<h;++e)t.gopacity||=a.getUseGradientOpacity(e);t.gopacity&&(i=yd.substitute(i,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(i=yd.substitute(i,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),i=yd.substitute(i,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=i,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=yd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lightComplexity&&(o=yd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=yd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=yd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=yd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=yd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{const a=o.getProperty();((n,r)=>{let o=0;n.getProperty().getShade()&&t.renderable.getBlendMode()===zg.COMPOSITE_BLEND&&(o=0,t.numberOfLights=0,r.forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===o&&(o=1)),1===o&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(o=2),o<3&&e.getPositional()&&(o=3)}))),o!==t.lightComplexity&&(t.lightComplexity=o,e.modified())})(o,r.getLights());const i=t.scalarTexture.getComponents(),s=[],l=[];for(let e=0;e<i;e++)s.push(a.getOpacityMode(e)),l.push(a.getForceNearestInterpolation(e));const c=t.currentInput.getSpatialExtent(),u=t.currentInput.getSpacing(),d=new Float64Array(3);In(d,(c[1]-c[0])*u[0],(c[3]-c[2])*u[1],(c[5]-c[4])*u[2]);const p=Sn(d)/e.getCurrentSampleDistance(r),f=!!t.zBufferTexture,g={iComps:a.getIndependentComponents(),colorMixPreset:a.getColorMixPreset(),interpolationType:a.getInterpolationType(),useLabelOutline:e.isLabelmapOutlineRequired(o),numComp:i,maxSamples:p,useGradientOpacity:a.getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),hasZBufferTexture:f,opacityModes:s,forceNearestInterps:l};return(0===n.getProgram()?.getHandle()||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime()||!t.previousState||!ke()(t.previousState,g))&&(t.previousState=g,!0)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange();if(i?.dataComputedScale?.length){const e=[],t=[];for(let n=0;n<4;n++)e[n]=s[0]*i.dataComputedScale[n]+i.dataComputedOffset[n],t[n]=s[1]*i.dataComputedScale[n]+i.dataComputedOffset[n],e[n]=(e[n]-i.offset[n])/i.scale[n],t[n]=(t[n]-i.offset[n])/i.scale[n];a.setUniform4f("ipScalarRangeMin",e[0],e[1],e[2],e[3]),a.setUniform4f("ipScalarRangeMax",t[0],t[1],t[2],t[3])}if(null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Hg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),s.setUniform3f("volumeSpacings",x[0],x[1],x[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*En(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(e.isLabelmapOutlineRequired(o)){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lightComplexity)return;let O=0;const R=[],M=[],E=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],E[0+3*O]=-.5*w[0],E[1+3*O]=-.5*w[1],E[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",E),3===t.lightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(n,r,o)=>{const a=n.getProgram();a.setUniformi("ctexture",t.colorTexture.getTextureUnit()),a.setUniformi("otexture",t.opacityTexture.getTextureUnit()),a.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),a.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const i=t.scalarTexture.getVolumeInfo(),s=o.getProperty(),l=t.scalarTexture.getComponents(),c=e.useIndependentComponents(s);if(c)for(let e=0;e<l;e++)a.setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));for(let e=0;e<l;e++){const t=c?e:0,n=i.scale[e],r=s.getScalarOpacity(t).getRange(),o=n/(r[1]-r[0]),l=(i.offset[e]-r[0])/(r[1]-r[0]);a.setUniformf(`oshift${e}`,l),a.setUniformf(`oscale${e}`,o);const u=s.getRGBTransferFunction(t).getRange(),d=(i.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);a.setUniformf(`cshift${e}`,d),a.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(c)for(let e=0;e<l;++e){const t=i.scale[e];if(s.getUseGradientOpacity(e)){const n=s.getGradientOpacityMinimumOpacity(e),r=s.getGradientOpacityMaximumOpacity(e);a.setUniformf(`gomin${e}`,n),a.setUniformf(`gomax${e}`,r);const o=[s.getGradientOpacityMinimumValue(e),s.getGradientOpacityMaximumValue(e)];a.setUniformf(`goscale${e}`,t*(r-n)/(o[1]-o[0])),a.setUniformf(`goshift${e}`,-o[0]*(r-n)/(o[1]-o[0])+n)}else a.setUniformf(`gomin${e}`,1),a.setUniformf(`gomax${e}`,1),a.setUniformf(`goscale${e}`,0),a.setUniformf(`goshift${e}`,1)}else{const e=i.scale[l-1],t=s.getGradientOpacityMinimumOpacity(0),n=s.getGradientOpacityMaximumOpacity(0);a.setUniformf("gomin0",t),a.setUniformf("gomax0",n);const r=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];a.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),a.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===e.isLabelmapOutlineRequired(o)){const e=o.getProperty().getLabelOutlineOpacity();a.setUniformf("outlineOpacity",e)}t.lightComplexity>0&&(a.setUniformf("vAmbient",s.getAmbient()),a.setUniformf("vDiffuse",s.getDiffuse()),a.setUniformf("vSpecular",s.getSpecular()),a.setUniformf("vSpecularPower",s.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*En(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Fg.NEAREST?(t.scalarTexture.setMinificationFilter(Rd.NEAREST),t.scalarTexture.setMagnificationFilter(Rd.NEAREST)):(t.scalarTexture.setMinificationFilter(Rd.LINEAR),t.scalarTexture.setMagnificationFilter(Rd.LINEAR)),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):jg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.scalarTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(Rd.LINEAR),t.jitterTexture.setMagnificationFilter(Rd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,Cs.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=e.useIndependentComponents(i),c=l?s:1,u=i.getScalarOpacity(),d=t._openGLRenderWindow.getGraphicsResourceForObject(u);let p=cg(u,l,c);if(d?.oglObject&&d.hash===p)t.opacityTexture=d.oglObject;else{t.opacityTexture=Kd.newInstance(),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const r=1024,o=2*r*c,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<c;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(Rd.LINEAR),t.opacityTexture.setMagnificationFilter(Rd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.UNSIGNED_CHAR,e)}u&&(t._openGLRenderWindow.setGraphicsResourceForObject(u,t.opacityTexture,p),u!==t._scalarOpacityFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(u,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalarOpacityFunc,e)),t._scalarOpacityFunc=u)}const f=i.getRGBTransferFunction();p=cg(f,l,c);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===p)t.colorTexture=g.oglObject;else{t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(2*n*c*3),o=new Float32Array(3*n);for(let e=0;e<c;++e){const t=i.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.create2DFromRaw(n,2*c,3,Cs.UNSIGNED_CHAR,r),f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,p),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}e.updateLabelOutlineThicknessTexture(r);const m=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(p=ug(o,a),m?.oglObject?.getHandle()&&m?.hash===p)t.scalarTexture=m.oglObject;else{t.scalarTexture=Kd.newInstance(),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a,t.renderable.getPreferSizeOverAccuracy()),a&&(t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,p),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ns.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ns.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThickness(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{t.labelOutlineThicknessTexture=Kd.newInstance(),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.isLabelmapOutlineRequired=e=>{const n=e.getProperty(),r=t.renderable;return n.getUseLabelOutline()||r.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND}}const $g={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$g,n),Zt.extend(e,t,n),Yd(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),t.jitterTexture=Kd.newInstance(),t.jitterTexture.setWrapS(Od.REPEAT),t.jitterTexture.setWrapT(Od.REPEAT),t.framebuffer=ef.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Kg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",qg);const{vtkDebugMacro:Xg}=Kt;function Yg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Xg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const Zg={};const Qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zg,n),Zt.extend(e,t,n),Yg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Qg);var Jg="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:em}=ms;function tm(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Kd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function nm(e,t){return tm(e,t,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE)}function rm(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",em.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=nm(t._openGLRenderWindow,t.size),t.seedTexture0=nm(t._openGLRenderWindow,t.size),t.licTexture1=nm(t._openGLRenderWindow,t.size),t.seedTexture1=nm(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?tm(t._openGLRenderWindow,t.size,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return tm(e,t,Kd.Filter.LINEAR,Kd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const om={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,om,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),rm(e,t)}var im={newInstance:jt.newInstance(am,"vtkLICPingPongBufferManager"),extend:am};const sm=0,lm=1,cm=2,um=3,dm=1;function pm(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=ef.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=ef.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=im.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],y=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;y.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:T}=t;y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",0),T.setUniformf("uMaskThreshold",t.maskThreshold),T.setUniform2f("uNoiseBoundsPt1",...m),T.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),T.setUniformi("texLIC",t.bufs.getLICTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,T);const{LICIShaderProgram:b}=t;y.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",1),n(T,t.bufs),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;y.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)y.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),y.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const fm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),pm(e,t)}var mm={newInstance:jt.newInstance(gm,"vtkLineIntegralConvolution2D"),extend:gm};function hm(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const vm={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:sm,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:dm,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vm,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),hm(0,t)}var Tm={newInstance:jt.newInstance(ym,"vtkSurfaceLICInterface"),extend:ym};const{Representation:bm}=ms;function xm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===dm?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Kd.newInstance({wrapS:Kd.Wrap.REPEAT,wrapT:Kd.Wrap.REPEAT,minificationFilter:Kd.Filter.NEAREST,magnificationFilter:Kd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.allocateTextures=()=>{const n=Kd.Filter.NEAREST,r=Kd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Kd.newInstance({wrapS:Kd.Wrap.CLAMP_TO_EDGE,wrapT:Kd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Kd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=ef.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",bm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=mm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===cm||u===um){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const Cm={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Sm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cm,n),Tm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),xm(e,t)}var Am={newInstance:jt.newInstance(Sm,"vtkSurfaceLICInterface"),extend:Sm};const{vtkErrorMacro:Im}=Kt;function wm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=yd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=yd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=yd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=yd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=yd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Im("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Im("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Im("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Tm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Am.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Im("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const Pm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Om=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pm,n),pp.extend(e,t,n),wm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",Om);const{vtkErrorMacro:Rm}=Kt;function Mm(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Rm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,Zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Em={};const Dm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Em,n),pp.extend(e,t,n),Mm(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",Dm);const{vtkErrorMacro:Vm}=Kt;function Lm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=yd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||Vm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||Vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||Vm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():Vm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,Zu.ARRAY_BUFFER),a.getColorBO().upload(g,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Bm={};const Nm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bm,n),pp.extend(e,t,n),Lm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Nm);const _m=[];_m["-".charCodeAt(0)]=62,_m["_".charCodeAt(0)]=63;const Fm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<Fm.length;e++)_m[Fm.charCodeAt(e)]=e;function km(e){return void 0!==_m[e.charCodeAt(0)]}function Gm(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<18;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<12;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<6;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<10;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<4;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<2;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Um(e,t,n){const r=(e<<16)+(t<<8)+n;return Fm[r>>18]+Fm[r>>12&63]+Fm[r>>6&63]+Fm[63&r]}function zm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Um(t[n],t[n+1],t[n+2])}if(n>0){const e=Um(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Wm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)km(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Gm(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Hm={};function jm(e,t){Hm[e]=t}var Km=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Hm[e](t)},$m=Uint8Array,qm=Uint16Array,Xm=Uint32Array,Ym=new $m([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zm=new $m([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qm=new $m([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jm=function(e,t){for(var n=new qm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Xm(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},eh=Jm(Ym,2),th=eh[0],nh=eh[1];th[28]=258,nh[258]=28;for(var rh=Jm(Zm,0),oh=rh[0],ah=(rh[1],new qm(32768)),ih=0;ih<32768;++ih){var sh=(43690&ih)>>>1|(21845&ih)<<1;sh=(61680&(sh=(52428&sh)>>>2|(13107&sh)<<2))>>>4|(3855&sh)<<4,ah[ih]=((65280&sh)>>>8|(255&sh)<<8)>>>1}var lh=function(e,t,n){for(var r=e.length,o=0,a=new qm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new qm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new qm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[ah[d]>>>l]=c}else for(i=new qm(r),o=0;o<r;++o)e[o]&&(i[o]=ah[s[e[o]-1]++]>>>15-e[o]);return i},ch=new $m(288);for(ih=0;ih<144;++ih)ch[ih]=8;for(ih=144;ih<256;++ih)ch[ih]=9;for(ih=256;ih<280;++ih)ch[ih]=7;for(ih=280;ih<288;++ih)ch[ih]=8;var uh=new $m(32);for(ih=0;ih<32;++ih)uh[ih]=5;var dh=lh(ch,9,1),ph=lh(uh,5,1),fh=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},gh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},mh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},hh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?qm:4==e.BYTES_PER_ELEMENT?Xm:$m)(n-t);return r.set(e.subarray(t,n)),r},vh=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],yh=function(e,t,n){var r=new Error(t||vh[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,yh),!n)throw r;return r},Th=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new $m(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new $m(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new $m(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=gh(e,c,1);var h=gh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&yh(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=dh,p=ph,f=9,g=5;else if(2==h){var T=gh(e,c,31)+257,b=gh(e,c+10,15)+4,x=T+gh(e,c+5,31)+1;c+=14;for(var C=new $m(x),S=new $m(19),A=0;A<b;++A)S[Qm[A]]=gh(e,c+3*A,7);c+=3*b;var I=fh(S),w=(1<<I)-1,P=lh(S,I,1);for(A=0;A<x;){var O,R=P[gh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,E=0;for(16==O?(E=3+gh(e,c,3),c+=2,M=C[A-1]):17==O?(E=3+gh(e,c,7),c+=3):18==O&&(E=11+gh(e,c,127),c+=7);E--;)C[A++]=M}}var D=C.subarray(0,T),V=C.subarray(T);f=fh(D),g=fh(V),d=lh(D,f,1),p=lh(V,g,1)}else yh(1);if(c>m){a&&yh(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[mh(e,c)&L])>>>4;if((c+=15&M)>m){a&&yh(0);break}if(M||yh(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Ym[A=_-257];F=gh(e,c,(1<<k)-1)+th[A],c+=k}var G=p[mh(e,c)&B],U=G>>>4;if(G||yh(3),c+=15&G,V=oh[U],U>3&&(k=Zm[U],V+=mh(e,c)&(1<<k)-1,c+=k),c>m){a&&yh(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:hh(t,0,u)},bh=new $m(0),xh=function(e,t){return e[t]|e[t+1]<<8},Ch=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Sh=function(e,t){return Ch(e,t)+4294967296*Ch(e,t+4)};function Ah(e,t){return Th(e,t)}function Ih(e,t){return Th(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||yh(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new $m((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function wh(e,t){return Th(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&yh(6,"invalid zlib data"),32&n[1]&&yh(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Ph(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Ih(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Ah(e,t):wh(e,t)}var Oh="undefined"!=typeof TextEncoder&&new TextEncoder,Rh="undefined"!=typeof TextDecoder&&new TextDecoder;try{Rh.decode(bh,{stream:!0})}catch(e){}function Mh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Rh)return Rh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,hh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&yh(8),a}var Eh=function(e,t){return t+30+xh(e,t+26)+xh(e,t+28)},Dh=function(e,t,n){var r=xh(e,t+28),o=Mh(e.subarray(t+46,t+46+r),!(2048&xh(e,t+8))),a=t+46+r,i=Ch(e,t+20),s=n&&4294967295==i?Vh(e,a):[i,Ch(e,t+24),Ch(e,t+42)],l=s[0],c=s[1],u=s[2];return[xh(e,t+10),l,c,o,a+xh(e,t+30)+xh(e,t+32),u]},Vh=function(e,t){for(;1!=xh(e,t);t+=4+xh(e,t+2));return[Sh(e,t+12),Sh(e,t+4),Sh(e,t+20)]};function Lh(e,t){for(var n={},r=e.length-22;101010256!=Ch(e,r);--r)(!r||e.length-r>65558)&&yh(13);var o=xh(e,r+8);if(!o)return{};var a=Ch(e,r+16),i=4294967295==a;i&&(r=Ch(e,r-12),101075792!=Ch(e,r)&&yh(13),o=Ch(e,r+32),a=Ch(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Dh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Eh(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Ah(e.subarray(h,h+d),new $m(p)):yh(14,"unknown compression type "+u):n[f]=hh(e,h,h+d))}return n}function Bh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Nh=Bh(),_h=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:Fh,vtkDebugMacro:kh}=jt;let Gh=0;function Uh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const zh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Uh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(kh(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Fh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Mh(Ph(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Mh(Ph(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Uh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Ph(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};jm("http",(e=>zh));const{vtkDebugMacro:Wh}=jt;function Hh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Wh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Wh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Hi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Hi(o,[...t.position,1],n),Hi(a,[...t.focalPoint,1],n),Hi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=qi(e[0],e[1],e[2],e[3]),n=ji(),r=qi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],$i(r,t,r),$i(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=ji();Ki(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const jh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Kh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Hh(e,t)}var $h={newInstance:jt.newInstance(Kh,"vtkCamera"),extend:Kh};function qh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const Xh={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xh,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),qh(e,t)}var Zh={newInstance:jt.newInstance(Yh,"vtkLight"),extend:Yh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Qh}=jt;function Jh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Qh("call displayToView on your view instead"),e.viewToDisplay=()=>Qh("callviewtodisplay on your view instead"),e.getSize=()=>Qh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Qh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const ev={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function tv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ev,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Jh(e,t)}var nv={newInstance:jt.newInstance(tv,"vtkViewport"),extend:tv};const{vtkDebugMacro:rv,vtkErrorMacro:ov,vtkWarningMacro:av}=Kt;function iv(e){return()=>ov(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function sv(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(rv("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):ov("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=iv("allocateTime"),e.updateGeometry=iv("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{rv(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=$h.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Zh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ov("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ov("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Wi.INIT_BOUNDS[0],t.allBounds[1]=Wi.INIT_BOUNDS[1],t.allBounds[2]=Wi.INIT_BOUNDS[2],t.allBounds[3]=Wi.INIT_BOUNDS[3],t.allBounds[4]=Wi.INIT_BOUNDS[4],t.allBounds[5]=Wi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),rv("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return rv("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return ov("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&(av("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return rv("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ov("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const lv={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lv,n),nv.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),sv(e,t)}var uv={newInstance:Dt(cv,"vtkRenderer"),extend:cv};const dv=Object.create(null);function pv(e,t){dv[e]=t}function fv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dv[e]&&dv[e](t)}function gv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}const mv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers","childRenderWindows"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),gv(e,t)}var vv={newInstance:jt.newInstance(hv,"vtkRenderWindow"),extend:hv,registerViewConstructor:pv,listViewAPIs:function(){return Object.keys(dv)},newAPISpecificView:fv};const yv={Unknown:0,LeftController:1,RightController:2},Tv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var bv={Device:yv,Input:Tv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:xv,Input:Cv}=bv,{vtkWarningMacro:Sv,vtkErrorMacro:Av,normalizeWheel:Iv,vtkOnceErrorMacro:wv}=jt,Pv={ctrlKey:!1,altKey:!1,shiftKey:!1},Ov={"xr-standard":[Cv.Trigger,Cv.Grip,Cv.TrackPad,Cv.Thumbstick,Cv.A,Cv.B]},Rv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Mv(e){e.cancelable&&e.preventDefault()}function Ev(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function Dv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Av("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Sv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Mv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Mv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Mv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Sv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Mv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Av(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Sv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Av("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Sv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?xv.LeftController:xv.RightController,input:Ov[s.mapping]&&Ov[s.mapping][r]?Ov[s.mapping][r]:Cv.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?xv.LeftController:xv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Mv(n);const r={...Iv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Av(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);if(2===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Ev(o);e.recognizeGesture("TouchEnd",t);const a={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Rv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void wv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const Vv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),Rv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),Dv(e,t)}var Bv={newInstance:jt.newInstance(Lv,"vtkRenderWindowInteractor"),extend:Lv,handledEvents:Rv,...bv};const{vtkErrorMacro:Nv,VOID:_v}=jt;function Fv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Bv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):_v),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Nv("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const kv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorObserver"),extend:Gv,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},zv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Wv}=zv,Hv={Rotate:Wv.IS_ROTATE,Pan:Wv.IS_PAN,Spin:Wv.IS_SPIN,Dolly:Wv.IS_DOLLY,CameraPose:Wv.IS_CAMERA_POSE,WindowLevel:Wv.IS_WINDOW_LEVEL,Slice:Wv.IS_SLICE};function jv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Hv).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Wv.IS_NONE&&(t.state=Hv[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Hv[n]&&(t.state=Wv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Kv={state:Wv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Uv.extend(e,t,n),jt.setGet(e,t,["focusedRenderer"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkInteractorStyle"),extend:$v,...zv};const{States:Xv}=zv;function Yv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case Xv.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad?!n||n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad||t.state!==Xv.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===Xv.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case Xv.IS_DOLLY:e.endDolly();break;case Xv.IS_PAN:e.endPan();break;case Xv.IS_SPIN:e.endSpin();break;case Xv.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const Zv={motionFactor:10,zoomFactor:10};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),qv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Yv(e,t)}var Jv={newInstance:jt.newInstance(Qv,"vtkInteractorStyleTrackballCamera"),extend:Qv};function ey(e){return e}function ty(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>ty(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var ny=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?ty:ey,o=new URLSearchParams(t);return o.forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};function ry(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const oy={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),ry(e,t)}var iy={newInstance:jt.newInstance(ay,"vtkRenderPass"),extend:ay};const{Representation:sy}=ms,{vtkErrorMacro:ly}=jt;function cy(e){const t=yd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function uy(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ns.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ns.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",sy.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Kd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Kd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Kd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||ly("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||ly("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?cy:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const dy={framebuffer:null,copyShader:null,tris:null};function py(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dy,n),iy.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),jt.get(e,t,["framebuffer"]),uy(e,t)}var fy={newInstance:jt.newInstance(py,"vtkOpenGLOrderIndependentTranslucentPass"),extend:py};function gy(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=ef.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=fy.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const my={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),iy.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkForwardPass"),extend:hy},yy=n(594),Ty=n.n(yy);const by=["lastShaderProgramBound","context","_openGLRenderWindow"];function xy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=yd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=yd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=yd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=yd.substitute(l,"varying","out").result,o=yd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=yd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=yd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:yd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Ty().hash(o);if(!(a in t.shaderPrograms)){const o=yd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const Cy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,by),jt.moveToProtected(e,t,["openGLRenderWindow"]),xy(e,t)}var Ay={newInstance:jt.newInstance(Sy,"vtkShaderCache"),extend:Sy};const{vtkErrorMacro:Iy}=jt;function wy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&Iy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const Py={context:null,numberOfTextureUnits:0,textureUnits:0};function Oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),wy(e,t)}var Ry={newInstance:jt.newInstance(Oy,"vtkOpenGLTextureUnitManager"),extend:Oy};function My(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ey={size:void 0,selector:void 0};function Dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),My(e,t)}var Vy={newInstance:jt.newInstance(Dy,"vtkRenderWindowViewNode"),extend:Dy};const{vtkDebugMacro:Ly,vtkErrorMacro:By}=jt,Ny={position:"absolute",top:0,left:0,width:"100%",height:"100%"},_y=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Fy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ky=0;const Gy=[];function Uy(e){e.preventDefault()}function zy(e,t){let n;function r(){return n||(n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n}t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Uy,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const o=[0,0];let a;e.onModified((function(){t.renderable&&(t.size[0]===o[0]&&t.size[1]===o[1]||(o[0]=t.size[0],o[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ky++,Gy.forEach((e=>e(ky)))),t.textureUnitManager=Ry.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&By("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},n=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(n=t.canvas.getContext("webgl2",e),n&&(t.webgl2=!0,Ly("using webgl2"))),n||(Ly("using webgl1"),n=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(n,r())},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=iy.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?By("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case Cs.CHAR:case Cs.SIGNED_CHAR:case Cs.UNSIGNED_CHAR:return 1;case n:case r:case Cs.UNSIGNED_SHORT:case Cs.SHORT:case Cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case Cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&Cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&Cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ny,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=a)return a;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return a=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Fy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Fy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Fy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Fy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Fy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Fy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Fy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=xf.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((()=>{t.context&&(ky--,Gy.forEach((e=>e(ky)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Uy),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const i=e.setSize;e.setSize=(t,n)=>{const r=i(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null),t._graphicsResources.get(n)?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))};const s={...e};_y.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):s[n](...arguments)}}))}const Wy={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Hy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),Vy.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=xf.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.shaderCache=Ay.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=vy.newInstance(),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),jt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"imageReady"),jt.event(e,t,"windowResizeEvent"),zy(e,t)}),"vtkOpenGLRenderWindow");function jy(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}pv("WebGL",Hy),rn("vtkRenderWindow",Hy);const Ky={device:null,handle:null};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),jy(e,t)}var qy={newInstance:jt.newInstance($y,"vtkWebGPUShaderModule"),extend:$y};function Xy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=qy.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const Yy={shaderModules:null,device:null,window:null};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Xy(e,t)}var Qy={newInstance:jt.newInstance(Zy,"vtkWebGPUShaderCache"),extend:Zy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function Jy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const eT={device:null,handle:null,label:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),Jy(e,t)}var nT={newInstance:jt.newInstance(tT),extend:tT};function rT(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const oT={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function aT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oT,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),rT(e,t)}var iT={newInstance:Dt(aT,"vtkWebGPUPipeline"),extend:aT};function sT(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Qy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Qy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Qy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const lT={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),sT(e,t)}var uT={newInstance:jt.newInstance(cT,"vtkWebGPUShaderDescription"),extend:cT};const dT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var pT=function(e){return!e||e.length<6?0:e in dT==1?dT[e]:(et(`unknown format ${e}`),null)},fT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},gT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},mT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},hT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},vT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function yT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function TT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(yT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=mT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const bT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function xT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),TT(e,t)}var CT={newInstance:Dt(xT,"vtkWebGPUVertexInput"),extend:xT};const ST="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",AT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function IT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=uT.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=uT.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=iT.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const wT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=CT.newInstance(),t.bindGroup=nT.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||AT,t.vertexShaderTemplate=t.vertexShaderTemplate||ST,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),IT(e,t)}var OT={newInstance:jt.newInstance(PT,"vtkWebGPUSimpleMapper"),extend:PT};function RT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const MT={};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),OT.extend(e,t,n),RT(e,t)}var DT={newInstance:jt.newInstance(ET,"vtkWebGPUFullScreenQuad"),extend:ET};const VT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function LT(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<VT.length;n++)e[VT[n]]=function(){return t.handle[VT[n]](...arguments)}}const BT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),LT(e,t)}var _T={newInstance:Dt(NT,"vtkWebGPURenderEncoder"),extend:NT},FT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const kT=["getMappedRange","mapAsync","unmap"];function GT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<kT.length;n++)e[kT[n]]=function(){return t.handle[kT[n]](...arguments)}}const UT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function zT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,UT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),GT(e,t)}var WT={newInstance:jt.newInstance(zT),extend:zT,...FT};const{Representation:HT}=ms,{PrimitiveTypes:jT}=FT;class KT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function $T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function qT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=$T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=$T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=$T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=$T(n,o,t),n.ibo[n.iboId++]=a}function XT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let YT;const ZT=new Uint32Array(1),QT=new Uint32Array(2),JT=new Uint32Array(3),eb={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)ZT[0]=t[n+a],YT(ZT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)QT[0]=t[n+a],QT[1]=t[n+(a+1)%e],YT(QT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o);for(let a=0;a<e-2;a++)QT[0]=t[n+a],QT[1]=t[n+a+2],YT(QT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n],JT[1]=t[n+a+1],JT[2]=t[n+a+2],YT(JT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n+a],JT[1]=t[n+a+1+a%2],JT[2]=t[n+a+1+(a+1)%2],YT(JT,r,o)}};function tb(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case jT.Points:return"points";case jT.Lines:return"lines";case jT.Triangles:case jT.TriangleEdges:return"polys";case jT.TriangleStripEdges:case jT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new KT};let d=null;d=o===HT.POINTS||r===jT.Points?eb.anythingToPoints:o===HT.WIREFRAME||r===jT.Lines?eb[`${l}ToWireframe`]:eb[`${l}ToSurface`],YT=XT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),YT=qT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const nb={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nb,n),WT.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),tb(e,t)}var ob={newInstance:jt.newInstance(rb),extend:rb,...FT};const{BufferUsage:ab}=FT,{vtkErrorMacro:ib}=Kt,{VtkDataTypes:sb}=Ns;function lb(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function cb(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function ub(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===ab.Index&&(n=ob.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=WT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===ab.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===ab.PointArray){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=lb(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===ab.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=cb(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=lb(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===ab.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case sb.UNSIGNED_CHAR:t="uint8";break;case sb.FLOAT:t="float32";break;case sb.UNSIGNED_INT:t="uint32";break;case sb.INT:t="sint32";break;case sb.DOUBLE:t="float32";break;case sb.UNSIGNED_SHORT:t="uint16";break;case sb.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ib(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:ab.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=WT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const db={device:null,fullScreenQuadBuffer:null};function pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,db,n),yt(e,t),At(e,t,["device"]),ub(e,t)}var fb={newInstance:Dt(pb),extend:pb,...FT};function gb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const mb={device:null,handle:null,label:null,options:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),gb(e,t)}var vb={newInstance:jt.newInstance(hb),extend:hb};function yb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vb.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const Tb={texture:null,handle:null,sampler:null,label:null};function bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),yb(e,t)}var xb={newInstance:jt.newInstance(bb),extend:bb};const{BufferUsage:Cb}=fb;function Sb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=pT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Vd.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Pu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:Cb.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:Cb.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=pT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>pT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=xb.newInstance({label:n});return o.create(e,r),o}}const Ab={device:null,handle:null,buffer:null,ready:!1,label:null};function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ab,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),Sb(e,t)}var wb={newInstance:jt.newInstance(Ib),extend:Ib};function Pb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=wb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=_T.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const Ob={renderEncoder:null,colorTexture:null,depthTexture:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Pb(e,t)}var Mb={newInstance:jt.newInstance(Rb,"vtkWebGPUOpaquePass"),extend:Rb};function Eb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=wb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=wb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=DT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=_T.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=_T.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const Db={colorTextureView:null,depthTextureView:null};function Vb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Db,n),iy.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),Eb(e,t)}var Lb={newInstance:jt.newInstance(Vb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Vb};const{BufferUsage:Bb}=fb,{vtkErrorMacro:Nb}=jt;function _b(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Nb(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:hT(n),offset:-1,nativeType:vT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Bb.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Fb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),_b(e,t)}var Gb={newInstance:jt.newInstance(kb,"vtkWebGPUUniformBuffer"),extend:kb};const{BufferUsage:Ub}=fb,{vtkErrorMacro:zb}=jt;function Wb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void zb(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=hT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:vT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Ub.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Hb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Wb(e,t)}var Kb={newInstance:jt.newInstance(jb,"vtkWebGPUStorageBuffer"),extend:jb};const $b="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",qb=new Float64Array(16),Xb=new Float64Array(16);function Yb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===zg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Qy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Qy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Qy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===zg.COMPOSITE_BLEND?l=!0:n===zg.MAXIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.MINIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.AVERAGE_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.ADDITIVE_INTENSITY_BLEND&&(a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Qy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(qb),b(qb,qb,o);const p=n.getMatrix();m(Xb,p),h(Xb,Xb),T(qb,Xb,qb);const f=d.getWorldToIndex();T(qb,f,qb);const v=d.getDimensions();g(Xb),x(Xb,Xb,[1/v[0],1/v[1],1/v[2]]),T(qb,Xb,qb);for(let t=0;t<16;t++)a[16*e+t]=qb[t];h(qb,qb);for(let t=0;t<4;t++)i[16*e+4*t]=qb[4*t],i[16*e+4*t+1]=qb[4*t+1],i[16*e+4*t+2]=qb[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=pT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vb.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Zb={volumes:null,rowLength:1024,lastVolumeLength:0};function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zb,n),DT.extend(e,t,n),t.fragmentShaderTemplate=$b,t.UBO=Gb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Kb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Kb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),Yb(e,t)}var Jb={newInstance:jt.newInstance(Qb,"vtkWebGPUVolumePassFSQ"),extend:Qb};const{Representation:ex}=ms,{BufferUsage:tx,PrimitiveTypes:nx}=fb,rx=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],ox="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function ax(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=Jb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=DT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Gb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:tx.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:nx.Triangles,representation:ex.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:tx.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+rx[e][0],l[n++]=r+rx[e][1],l[n++]=r+rx[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=_T.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=wb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=wb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=wb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=_T.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=_T.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=_T.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const ix={colorTextureView:null,depthTextureView:null,volumes:null};function sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ix,n),iy.extend(e,t,n),t._mapper=OT.newInstance(),t._mapper.setFragmentShaderTemplate(ox),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Cu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),ax(e,t)}var lx={newInstance:jt.newInstance(sx,"vtkWebGPUVolumePass"),extend:sx};function cx(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Mb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Lb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=lx.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=_T.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vb.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=DT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=xb.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const ux={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ux,n),iy.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),cx(e,t)}var px={newInstance:jt.newInstance(dx,"vtkForwardPass"),extend:dx};const{VtkDataTypes:fx}=Ns;function gx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case fx.UNSIGNED_CHAR:e.format+="8unorm";break;case fx.FLOAT:case fx.UNSIGNED_INT:case fx.INT:case fx.DOUBLE:case fx.UNSIGNED_SHORT:case fx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=wb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const mx={handle:null,device:null};function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mx,n),jt.obj(e,t),jt.setGet(e,t,["device"]),gx(e,t)}var vx={newInstance:jt.newInstance(hx),extend:hx};class yx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function Tx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const bx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new yx,t.shaderCache=Qy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=fb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=vx.newInstance(),t.textureManager.setDevice(e),t.pipelines={},Tx(e,t)}var Cx={newInstance:Dt(xx,"vtkWebGPUDevice"),extend:xx};function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=wb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=_T.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const Ax={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelectionPass"),extend:Ix};const{SelectionContent:Px,SelectionField:Ox}=of,{FieldAssociations:Rx}=ll,{vtkErrorMacro:Mx}=jt;function Ex(e){return`${e.propID} ${e.compositeID}`}function Dx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Vx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Dx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Dx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Vx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Vx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Vx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Vx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Vx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Lx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Mx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=WT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=WT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Vx(e,[n,t],0,u);if(r){const t=Ex(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=of.newInstance();switch(i.setContentType(Px.INDICES),e){case Rx.FIELD_ASSOCIATION_CELLS:i.setFieldType(Ox.CELL);break;case Rx.FIELD_ASSOCIATION_POINTS:i.setFieldType(Ox.POINT);break;default:Mx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Bx={};function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),Yp.extend(e,t,n),t._selectionPass=wx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Lx(e,t)}var _x={newInstance:jt.newInstance(Nx,"vtkWebGPUHardwareSelector"),extend:Nx};const Fx=Object.create(null);function kx(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Gx={};function Ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gx,n),t.overrides=Fx,tn.extend(e,t,n),kx(0,t)}var zx={newInstance:jt.newInstance(Ux,"vtkWebGPUViewNodeFactory"),extend:Ux};const{vtkErrorMacro:Wx}=jt,Hx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function jx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Wx("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Wx("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=Cx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=iy.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Hx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=WT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Vd.fromHalf(r.colorValues[o]),s[n+1]=255*Vd.fromHalf(r.colorValues[o+1]),s[n+2]=255*Vd.fromHalf(r.colorValues[o+2]),s[n+3]=255*Vd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=_x.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Kx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const $x=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Vy.extend(e,t,n),t.myFactory=zx.newInstance(),t.renderPasses[0]=px.newInstance(),t.selector||(t.selector=_x.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),jx(e,t)}),"vtkWebGPURenderWindow");var qx;pv("WebGPU",$x),qx=$x,Fx.vtkRenderWindow=qx;const Xx=ny(),Yx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Zx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Qx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Jx(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Qx(t.container,t.containerStyle||Yx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=vv.newInstance(),t.renderer=uv.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Xx.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Bv.newInstance(),t.interactor.setInteractorStyle(Jv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Qx(t.controlContainer,t.controlPanelStyle||Zx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const eC={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function tC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eC,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Jx(e,t)}var nC={newInstance:jt.newInstance(tC),extend:tC},rC={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:oC,Scale:aC}=rC,{ScalarMappingTarget:iC}=El,{vtkDebugMacro:sC,vtkErrorMacro:lC,vtkWarningMacro:cC}=jt;function uC(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function dC(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function pC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];uC(o,i),uC(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=dC(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=dC(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function fC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return lC("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return lC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===aC.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Eo(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===oC.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===oC.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===oC.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===oC.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return lC("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(lC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return lC("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void lC("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):sC("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void cC("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===iC.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===iC.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===iC.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===iC.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=oC[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(lC(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=oC.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const gC={clamping:!0,colorSpace:oC.RGB,hSVWrap:!0,scale:aC.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function mC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gC,n),El.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:oC},{type:"enum",name:"scale",enum:aC}]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),fC(e,t)}var hC={newInstance:jt.newInstance(mC,"vtkColorTransferFunction"),extend:mC,...rC},vC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:yC,ScaleModes:TC}=vC,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(yC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(yC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(yC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(yC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(TC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(TC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(TC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(TC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===TC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(bC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Wi.getCorners(l,c),t.bounds[0]=Wi.INIT_BOUNDS[0],t.bounds[1]=Wi.INIT_BOUNDS[1],t.bounds[2]=Wi.INIT_BOUNDS[2],t.bounds[3]=Wi.INIT_BOUNDS[3],t.bounds[4]=Wi.INIT_BOUNDS[4],t.bounds[5]=Wi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case yC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case yC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case yC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case TC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case TC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case TC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const CC={orient:!0,orientationMode:yC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:TC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,CC,n),uc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkGlyph3DMapper"),extend:SC,...vC};const{vtkErrorMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(IC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return IC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return IC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return IC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const PC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkPiecewiseFunction"),extend:OC};const{InterpolationType:MC,OpacityMode:EC}=Ug,{vtkErrorMacro:DC}=jt;function VC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(DC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=RC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=hC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=RC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return DC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(DC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(MC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(MC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(MC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(MC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const LC={colorMixPreset:null,independentComponents:!0,interpolationType:MC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,LC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:EC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}jt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeProperty"),extend:BC,...Ug};const{vtkDebugMacro:_C}=jt;function FC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=NC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){_C("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const kC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function GC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kC,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),FC(e,t)}var UC={newInstance:jt.newInstance(GC,"vtkVolume"),extend:GC};const{BlendMode:zC,FilterMode:WC}=Wg,HC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=RC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function jC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(zC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(zC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(zC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(zC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(zC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(zC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(zC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(WC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(WC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(WC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(WC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Eo(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const KC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:zC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:WC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function $C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KC,n),zs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),jC(e,t)}var qC={newInstance:jt.newInstance($C,"vtkVolumeMapper"),extend:$C,...HC};const{InterpolationType:XC}=pg,{vtkErrorMacro:YC}=jt;function ZC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return YC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(YC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(XC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(XC.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(XC,t.interpolationType)}const QC={independentComponents:!1,interpolationType:XC.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function JC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,QC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),ZC(e,t)}var eS={newInstance:jt.newInstance(JC,"vtkImageProperty"),extend:JC};const{vtkDebugMacro:tS}=jt;function nS(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=eS.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){tS("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Wi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Wi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Wi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const rS={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...Wi.INIT_BOUNDS]};function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rS,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),jt.getArray(e,t,["bounds"],6),nS(e,t)}var aS={newInstance:jt.newInstance(oS,"vtkImageSlice"),extend:oS};function iS(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const sS={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var lS=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sS,n),zs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),iS(e,t)};function cS(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ii.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:uS,otherStaticMethods:dS}=Kl,{SlicingMode:pS}=yg;function fS(e,t){function n(){let n;switch(t.slicingMode){case pS.X:n=0;break;case pS.Y:n=1;break;case pS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case pS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case pS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case pS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case pS.I:l=Ma(a[0],i[0],i[1]);break;case pS.J:l=Ma(a[1],i[2],i[3]);break;case pS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case pS.I:case pS.J:case pS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case pS.X:e.setSlice(r[0]);break;case pS.Y:e.setSlice(r[1]);break;case pS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(pS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(pS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(pS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(pS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(pS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(pS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case pS.X:n[0]=1;break;case pS.Y:n[1]=1;break;case pS.Z:n[2]=1;break;case pS.I:ea(r,[1,0,0],n);break;case pS.J:ea(r,[0,1,0],n);break;case pS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==pS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case pS.I:r[0]=a,r[1]=a;break;case pS.J:r[2]=a,r[3]=a;break;case pS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case pS.I:a[0]=s-r,a[1]=s+r;break;case pS.J:a[2]=s-r,a[3]=s+r;break;case pS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const gS={slicingMode:pS.NONE,closestIJKAxis:{ijkMode:pS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function mS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gS,n),lS(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Kl.implementCoincidentTopologyMethods(e,t),fS(e,t)}var hS={newInstance:jt.newInstance(mS,"vtkImageMapper"),extend:mS,...uS,...dS,...yg};const{vtkErrorMacro:vS}=jt;function yS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function TS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void vS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Cu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Xs.SINGLE?s=Cs.FLOAT:t.outputPointsPrecision===Xs.DOUBLE&&(s=Cs.DOUBLE);const v=Sc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ns.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ns.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ns.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),yS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),yS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),yS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),yS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const bS={outputPointsPrecision:Xs.DEFAULT};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkAppendPolyData"),extend:xS};function SS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Kf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Cu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const AS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function IS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),SS(e,t)}var wS={newInstance:jt.newInstance(IS,"vtkConeSource"),extend:IS};function PS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ns.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ns.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Kf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Cu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const OS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function RS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),PS(e,t)}var MS={newInstance:jt.newInstance(RS,"vtkCylinderSource"),extend:RS};function ES(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=MS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();jf().rotateZ(-90).apply(a).apply(i);const s=wS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Kf().translate(1-.5*t.tipLength,0,0).apply(c);const u=CS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Kf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Kf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Kf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const DS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function VS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),ES(e,t)}var LS={newInstance:jt.newInstance(VS,"vtkArrowSource"),extend:VS};function BS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];jf().translate(...n).apply(e.getPoints().getData())}function NS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],jf().translate(...o).apply(e.getPoints().getData())}function _S(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ns.newInstance({name:"color",numberOfComponents:3,values:a}))}function FS(e,t){t.classHierarchy.push("vtkAxesActor");const n=uc.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=LS.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?BS(r):NS(r,0,e.invert),_S(r,...e.color),e={...t.config,...t.yConfig};const o=LS.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?BS(o):NS(o,1,e.invert),_S(o,...e.color),e={...t.config,...t.zConfig};const a=LS.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?BS(a):NS(a,2,e.invert),_S(a,...e.color);const i=CS.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=jt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}function kS(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}function GS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,kS(n)),jt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),FS(e,t)}var US={newInstance:jt.newInstance(GS,"vtkAxesActor"),extend:GS};const zS="resetcamera",WS="orientation",HS={MODE_RESET_CAMERA:zS,MODE_ORIENTATION:WS,MODE_SAME:"same"};function jS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===WS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===zS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const KS={mode:WS,focalPoint:[0,0,0],distance:6.8,active:!0};function $S(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),jS(e,t)}var qS={newInstance:Dt($S,"vtkCameraSynchronizer"),extend:$S,SynchronizationMode:HS};const XS={},YS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=qS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:qS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ZS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;XS[r]||(XS[r]={});const o=XS[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=qS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];YS[e.type]?o[r]=new YS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const QS={},JS=/instance:\${([^}]+)}/,eA={},tA=[],nA={},rA={vtkPoints:Sc,vtkCellArray:vc,vtkDataArray:Ns};function oA(e){return e.map((e=>JS.exec(e))).filter((e=>e)).map((e=>e[1]))}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),aA(e,t)})),t}function iA(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=QS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function sA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=QS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function lA(){Object.keys(QS).forEach((e=>{delete QS[e]}))}function cA(){Object.keys(eA).forEach((e=>{delete eA[e]}))}function uA(e){if(1===e[1].length)return-1===tA.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===tA.indexOf(e[1][n]);return t}function dA(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(nA[r]){const{key:n,value:o}=nA[r];if(!n||e.properties[n]===o)return void tA.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=sA(r,{managedInstanceId:t}),n.registerInstance(t,o)),iA(r,o,e,n)})),t.calls&&t.calls.filter(uA).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=JS.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=rA[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function pA(e,t,n){eA[t.id]||dA(e,t,n),eA[t.id]=!0}function fA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function gA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function mA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=gA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=gA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),fA(t.getPointData(),i.pointData),fA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=dA(t,s,r);return r.end(),l}}const hA=mA(["points","polys","verts","lines","strips"]),vA=mA([]);function yA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dA;sA||iA?QS[e]={build:t,update:n}:delete QS[e]}const TA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},bA={vtkAxesActor:{build:US.newInstance,update:dA},vtkRenderWindow:{build:vv.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(uA).filter((e=>"removeRenderer"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),dA(e,t,n),ZS(e,t,n)}},vtkRenderer:{build:uv.newInstance,update:function(e,t,n){dA(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=aA(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(uA).filter((e=>"removeViewProp"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:Nl.newInstance,update:dA},vtkCamera:{build:$h.newInstance,update:pA},vtkPolyData:{build:Cu.newInstance,update:hA},vtkImageData:{build:vl.newInstance,update:vA},vtkMapper:{build:uc.newInstance,update:dA},vtkGlyph3DMapper:{build:AC.newInstance,update:dA},vtkProperty:{build:ms.newInstance,update:dA},vtkActor:{build:bs.newInstance,update:dA},vtkLight:{build:Zh.newInstance,update:dA},vtkColorTransferFunction:{build:hC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Pu.newInstance,update:dA},vtkVolume:{build:UC.newInstance,update:dA},vtkVolumeMapper:{build:qC.newInstance,update:dA},vtkVolumeProperty:{build:NC.newInstance,update:dA},vtkImageSlice:{build:aS.newInstance,update:dA},vtkImageMapper:{build:hS.newInstance,update:dA},vtkImageProperty:{build:eS.newInstance,update:dA},vtkPiecewiseFunction:{build:RC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:$u.newInstance,update:dA},vtkScalarBarActor:{build:Fp.newInstance,update:dA}};function xA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&lA(),Object.keys(bA).forEach((e=>{const t=bA[e];yA(e,t.build,t.update)}))}function CA(){Object.keys(TA).forEach((e=>{TA[e].forEach((t=>{QS[t]=QS[e]}))}))}xA(),CA(),nA.vtkPVLight={};var SA={build:sA,update:iA,genericUpdater:dA,oneTimeGenericUpdater:pA,setTypeMapping:yA,clearTypeMapping:lA,getSupportedTypes:function(){return Object.keys(QS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return cA();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete eA[e]})),r},updateRenderWindow:function(e,t,n){return iA("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){nA[e]={key:t,value:n}},setDefaultMapping:xA,applyDefaultAliases:CA,alwaysUpdateCamera:function(){yA("vtkCamera",$h.newInstance),CA()}};const AA={};function IA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Wm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function wA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function PA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Et(t,n,"progressEvent"),Et(t,n,"progressDone"),t}function OA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function RA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=AA[e];return t||(t={...IA(),...wA(),...PA(),...OA()},AA[e]=t),t}function MA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),SA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){SA.clearOneTimeUpdaters(a())}}}function EA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=RA(t.synchronizerContextName));const n=MA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const DA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function VA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DA,n),vv.extend(e,t),bt(e,t,["synchronizerContext"]),EA(e,t)}var LA={newInstance:Dt(VA,"vtkSynchronizableRenderWindow"),extend:VA,getSynchronizerContext:RA,setSynchronizerContext:function(e,t){AA[e]=t},clearSynchronizerContext:function(e){if(e&&AA[e]&&delete AA[e],!e){const e=Object.keys(AA);for(let t=0;t<e.length;t++)delete AA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=MA(e,RA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:wA,createArrayHandler:IA,createProgressHandler:PA,createSceneMtimeHandler:OA,vtkObjectManager:SA};const{vtkErrorMacro:BA,vtkDebugMacro:NA}=jt;let _A=0;function FA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function kA(e){return"/"===e[0]?e.substr(1):e}const GA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=FA(kA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=FA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=kA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=FA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Mh(Ph(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Wm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(NA(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&BA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--_A&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};jm("html",(e=>GA));const{vtkErrorMacro:UA,vtkDebugMacro:zA}=jt;function WA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const HA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new $m(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Oh)return Oh.encode(e);var o=e.length,a=new $m(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new $m(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return hh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Lh(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||UA("ERROR!!! zip not ready...");const u=WA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Mh(Ph(new Uint8Array(e.buffer))):e.buffer=Ph(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Nh!==e.ref.encode&&Nh&&(zA(`Swap bytes of ${e.name}`),_h(e.buffer,xs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&UA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Mh(Ph(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Mh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Mh(Ph(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Mh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Mh(Lh(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Mh(s))},fetchImage(e,n){const a=WA(n);t||UA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=zm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Ph(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};jm("zip",(e=>HA(e)));var jA=n(892),KA=n.n(jA),$A=n(760),qA=n.n($A),XA=n(311),YA=n.n(XA),ZA=n(192),QA=n.n(ZA),JA=n(60),eI=n.n(JA),tI=n(865),nI=n.n(tI),rI=n(34),oI={};oI.styleTagTransform=nI(),oI.setAttributes=QA(),oI.insert=YA().bind(null,"head"),oI.domAPI=qA(),oI.insertStyleElement=eI(),KA()(rI.Z,oI);var aI=rI.Z&&rI.Z.locals?rI.Z.locals:void 0;let iI=!0;function sI(e){e.preventDefault(),e.stopPropagation()}function lI(e,t){iI=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=nC.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=LA.getSynchronizerContext(),a=LA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",aI.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?zh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Km("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):zh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Km("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Wm(t.base64Str),n=Km("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function cI(e){iI=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(aI.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${aI.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){sI(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];lI(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",sI)}const uI=ny();if(uI.url||uI.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(aI.fullScreen),t.style.margin="0",t.style.padding="0"),iI=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>lI(n,uI)))}setTimeout((()=>{iI&&cI()}),100),window.OfflineLocalView={initLocalFileLoader:cI,load:lI}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(819),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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/4nyI5QfofwI5Uco/wvlf6H8L5T/hfJjlB+j/Bjlxyh/h/J3KH+H8ncoP0H5CcpPUH6C8vcof4/y9yh/j/JTlJ+i/BTlpyj/G+V/o/xvlP+N8jOUn6H8DOVnKP8H5f+g/B+U/4Pyc5Sfo/wc5eco/4DyDyj/gPIPKL9A+QXKL1B+gfKPKP+I8o8o/4jyS5RfovwS5Zco/4TyTyj/hPJPKL9C+RXKr1B+hfJ/Uf4vyv9F+b8ov0b5NcqvUX6N8v9Q/h/K/0P5fyi/QfkNym9QfoPyzyj/jPLPKP+M8luU36L8FuW3KP+C8i8o/4LyLygfo7zlenzR6K8D9O8B+usA/XOA/jhA/xugvw3QvwboTwP0nwH6ywD9Y4D+MED/F6C/C9C/BejPAvRfAfqrAP1TgP4oQP8ToL8J0L8E6E8C9B8B+osA/UOA/iDA/T/A/T7A/T3A/TzA/TvA/TrA/TnA/TjA/TfA/TbA/TXA/TTA/TPA/TLA/THA/TDA/S/A/S7A/S3A/SzA/SvA/SrA/SnA/SjA/SfA/SbA/SXA/STA/SPA/SLA/SHA/SCA/wP43Yefffjfh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbh799+NuHv33424e/ffjbg389+N2Dnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg589+NmDnz342YOfPfjZg59d+NWFv13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX9d+NeFf13414V/XfjXhX8d+NOBnx341YFfHfjV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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>

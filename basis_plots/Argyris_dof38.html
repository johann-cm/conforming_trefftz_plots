<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},819:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return cI},load:function(){return lI}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return Ee},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],E=r[2],D=Math.hypot(R,M,E);return D<a?null:(R*=D=1/D,M*=D,E*=D,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,P=M*E*s-R*o,O=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),D(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,E=(1-(p+v))*C,D=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=D,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+E*I+L*w),e[14]=n[2]+w-(R*A+D*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],E=t[12],D=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-D)<=a*Math.max(1,Math.abs(h),Math.abs(D))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=Ee,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Et(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Dt(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Et,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Dt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:xt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Et,newInstance:Dt,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>{if(!t._parent)return null;return t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null)},e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=t=>{if(t&&t.length)for(let n=0;n<t.length;++n){const r=t[n];e.addMissingNode(r)}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function En(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Dn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Er=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Dr(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Dr((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Dr((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Er):kr:t instanceof dr?Er:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Eo,ceil:Do,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Ea(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Da=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Eo,ceil:Do,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Ea,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Da,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};function Wa(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{jt.vtkErrorMacro("not implemented")}}const Ha={};function ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ha,n),jt.obj(e,t),jt.setGet(e,t,["transform"]),Wa(e,t)}var Ka={newInstance:jt.newInstance(ja,"vtkImplicitFunction"),extend:ja};const $a=1e-6,qa="coincide",Xa="disjoint";function Ya(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Za(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function Qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Ja(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function ei(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*$a:s*$a,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function ti(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<$a){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=qa:o.error=Xa,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const ni={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ya,projectPoint:Za,projectVector:Qa,generalizedProjectPoint:Ja,intersectWithLine:ei,intersectWithPlane:ti,DISJOINT:Xa,COINCIDE:qa};function ri(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ya(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Za(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>Qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Ja(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>ei(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>ti(e,n,t.origin,t.normal)}const oi={normal:[0,0,1],origin:[0,0,0]};function ai(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oi,n),Ka.extend(e,t,n),jt.setGetArray(e,t,["normal","origin"],3),ri(e,t)}var ii={newInstance:jt.newInstance(ai,"vtkPlane"),extend:ai,...ni};const si=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function li(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ci(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ui(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function di(e){return ui(e,si)}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function fi(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)pi(e,...t[n]);else for(let n=0;n<t.length;n+=3)pi(e,...t.slice(n,n+3));return e}function gi(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function mi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function hi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function vi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function yi(e,t,n,r){return!!ci(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function Ti(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function bi(e,t){return e[2*t+1]-e[2*t]}function xi(e){return[bi(e,0),bi(e,1),bi(e,2)]}function Ci(e){return e.slice(0,2)}function Si(e){return e.slice(2,4)}function Ai(e){return e.slice(4,6)}function Ii(e){const t=xi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function wi(e){if(ci(e)){const t=xi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Pi(e){return[e[0],e[2],e[4]]}function Oi(e){return[e[1],e[3],e[5]]}function Ri(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Mi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Ei(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Di(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Mi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return di(n),fi(n,r)}function Vi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Li(e,t,n,r){const o=[].concat(si),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Bi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ni(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ii.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function _i(e,t){if(!ci(e)||!ci(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Fi(e,t){if(!ci(e)||!ci(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function ki(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Gi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ii.evaluate(n,t,l)}let i=2;for(;i--&&!(Ri(o[r[i][0]],o[r[i][4]])&&Ri(o[r[i][1]],o[r[i][5]])&&Ri(o[r[i][2]],o[r[i][6]])&&Ri(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ui{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(si))}getBounds(){return this.bounds}equals(e){return li(this.bounds,e)}isValid(){return ci(this.bounds)}setBounds(e){return ui(this.bounds,e)}reset(){return di(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return pi(this.bounds,...t)}addPoints(e){return fi(this.bounds,e)}addBounds(e,t,n,r,o,a){return gi(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return mi(this.bounds,e,t,n)}setMaxPoint(e,t,n){return hi(this.bounds,e,t,n)}inflate(e){return vi(this.bounds,e)}scale(e,t,n){return yi(this.bounds,e,t,n)}getCenter(){return Ti(this.bounds)}getLength(e){return bi(this.bounds,e)}getLengths(){return xi(this.bounds)}getMaxLength(){return Ii(this.bounds)}getDiagonalLength(){return wi(this.bounds)}getMinPoint(){return Pi(this.bounds)}getMaxPoint(){return Oi(this.bounds)}getXRange(){return Ci(this.bounds)}getYRange(){return Si(this.bounds)}getZRange(){return Ai(this.bounds)}getCorners(e){return Mi(this.bounds,e)}computeCornerPoints(e,t){return Ei(this.bounds,e,t)}computeLocalBounds(e,t,n){return Li(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Di(this.bounds,e,t)}computeScale3(e){return Vi(this.bounds,e)}cutWithPlane(e,t){return Gi(this.bounds,e,t)}intersectBox(e,t,n,r){return Bi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ni(this.bounds,e,t)}intersect(e){return _i(this.bounds,e)}intersects(e){return Fi(this.bounds,e)}containsPoint(e,t,n){return ki(this.bounds,e,t,n)}contains(e){return Fi(this.bounds,e)}}var zi,Wi={newInstance:function(e){const t=e&&e.bounds;return new Ui(t)},equals:li,isValid:ci,setBounds:ui,reset:di,addPoint:pi,addPoints:fi,addBounds:gi,setMinPoint:mi,setMaxPoint:hi,inflate:vi,scale:yi,scaleAboutCenter:function(e,t,n,r){if(!ci(e))return!1;const o=Ti(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],yi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:Ti,getLength:bi,getLengths:xi,getMaxLength:Ii,getDiagonalLength:wi,getMinPoint:Pi,getMaxPoint:Oi,getXRange:Ci,getYRange:Si,getZRange:Ai,getCorners:Mi,computeCornerPoints:Ei,computeLocalBounds:Li,transformBounds:Di,computeScale3:Vi,cutWithPlane:Gi,intersectBox:Bi,intersectPlane:Ni,intersect:_i,intersects:Fi,containsPoint:ki,contains:function(e,t){return!!Fi(e,t)&&!!ki(e,...Pi(t))&&!!ki(e,...Oi(t))},INIT_BOUNDS:si};function Hi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function ji(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Ki(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function $i(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}zi=new i(4),i!=Float32Array&&(zi[0]=0,zi[1]=0,zi[2]=0,zi[3]=0);var qi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),ji(),ji(),ie();var Xi={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Yi}=Xi;function Zi(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function Qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Zi("pick"),e.hasKey=Zi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Yi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Yi.DISPLAY)}const Ji={allocatedRenderTime:10,coordinateSystem:Yi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp"),extend:es,...Xi};function ns(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=ji();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return N(e,t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=ji();Ki(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);T(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>Wi.getCenter(t.bounds),e.getLength=()=>Wi.getLength(t.bounds),e.getXRange=()=>Wi.getXRange(t.bounds),e.getYRange=()=>Wi.getYRange(t.bounds),e.getZRange=()=>Wi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const rs={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function os(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rs,n),ts.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,ns(e,t)}var as={newInstance:jt.newInstance(os,"vtkProp3D"),extend:os};const is={FLAT:0,GOURAUD:1,PHONG:2},ss={POINTS:0,WIREFRAME:1,SURFACE:2};var ls={Shading:is,Representation:ss,Interpolation:is};const{Representation:cs,Interpolation:us}=ls;function ds(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ps(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ds("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ds("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(us.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(us.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(us.PHONG),e.getInterpolationAsString=()=>jt.enumToString(us,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(cs.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(cs.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(cs.POINTS),e.getRepresentationAsString=()=>jt.enumToString(cs,t.representation)}const fs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:us.GOURAUD,representation:cs.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ps(e,t)}var ms={newInstance:jt.newInstance(gs,"vtkProperty"),extend:gs,...ls};const{vtkDebugMacro:hs}=jt;function vs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ms.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){hs("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const ys={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function Ts(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),vs(e,t)}var bs={newInstance:jt.newInstance(Ts,"vtkActor"),extend:Ts};const xs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},Cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ss={DefaultDataType:Cs.FLOAT,DataTypeByteSize:xs,VtkDataTypes:Cs};const{vtkErrorMacro:As}=Kt,{DefaultDataType:Is}=Ss,ws=1e-6;function Ps(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function Os(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ps(r,0,1)}return Ps(e,t<0?0:t,n)}function Rs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function Ms(e){return Object.prototype.toString.call(e).slice(8,-1)}const Es={computeRange:Os,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ps,getDataType:Ms,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Ds(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=Os(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Rs(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ws;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=Ms(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||As("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Vs={name:"",numberOfComponents:1,dataType:Is,rangeTuple:[0,0]};function Ls(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Vs,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=Ms(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Ds(e,t)}const Bs=Dt(Ls,"vtkDataArray");var Ns={newInstance:Bs,extend:Ls,...Es,...Ss};function _s(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Fs={clippingPlanes:[]};var ks=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fs,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),_s(e,t)};function Gs(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Wi.isValid(n)?Wi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Wi.getDiagonalLength(t)}}const Us=e=>({bounds:[...Wi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var zs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Us(n)),ks(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Gs(e,t)};const{vtkErrorMacro:Ws,vtkWarningMacro:Hs}=jt;function js(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Ws("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ns.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Hs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Ws("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ns.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const Ks={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function $s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ks,n),jt.obj(e,t),js(e,t)}var qs={newInstance:jt.newInstance($s,"vtkFieldData"),extend:$s};const Xs={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ys={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Xs,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Zs,AttributeCopyOperations:Qs}=Ys,{vtkWarningMacro:Js}=jt;function el(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Zs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Js(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Js(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Qs.PASSDATA][Zs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Qs[e]]=Object.keys(Zs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Zs[t]]=!0,e)),[])})),t.copyAttributeFlags[Qs.COPYTUPLE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.INTERPOLATE][Zs.GLOBALIDS]=!1,t.copyAttributeFlags[Qs.COPYTUPLE][Zs.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ns.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const tl={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tl,n),qs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),el(e,t)}var rl={newInstance:jt.newInstance(nl,"vtkDataSetAttributes"),extend:nl,...Ys};const ol=["pointData","cellData","fieldData"];function al(e,t){t.classHierarchy.push("vtkDataSet"),ol.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=rl.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),ol.forEach((n=>{t[n]=rl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const il={};function sl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,il,n),jt.obj(e,t),jt.setGet(e,t,ol),al(e,t)}var ll={newInstance:jt.newInstance(sl,"vtkDataSet"),extend:sl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const cl={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ul={StructuredType:cl};const{StructuredType:dl}=ul;var pl={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?dl.EMPTY:3===t?dl.XYZ_GRID:2===t?e[0]===e[1]?dl.YZ_PLANE:e[2]===e[3]?dl.XZ_PLANE:dl.XY_PLANE:1===t?e[0]<e[1]?dl.X_LINE:e[2]<e[3]?dl.Y_LINE:dl.Z_LINE:dl.SINGLE_POINT},...ul};const{vtkErrorMacro:fl}=jt;function gl(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return fl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=pl.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)fl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void fl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return fl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case cl.EMPTY:return null;case cl.SINGLE_POINT:break;case cl.X_LINE:o[0]=n;break;case cl.Y_LINE:o[1]=n;break;case cl.Z_LINE:o[2]=n;break;case cl.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case cl.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case cl.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case cl.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:fl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Wi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Wi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Wi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Wi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Wi.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Ea(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ea(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return fl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return fl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const ml={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:cl.EMPTY};function hl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ml,n),ll.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),gl(e,t)}var vl={newInstance:jt.newInstance(hl,"vtkImageData"),extend:hl};const yl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Tl={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:yl},bl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:xl,VectorMode:Cl}=Tl,{VtkDataTypes:Sl}=Ns,{ColorMode:Al}=bl,{vtkErrorMacro:Il}=jt;function wl(e){return e}function Pl(e){return Math.floor(255*e+.5)}function Ol(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Cl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Cl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Cl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)Il("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===Al.DEFAULT&&(t.getDataType()===Sl.UNSIGNED_CHAR||t.getDataType()===Sl.UNSIGNED_CHAR_CLAMPED)||n===Al.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Sl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ns.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,xl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,xl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Cl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Cl.MAGNITUDE||1!==c&&1!==s||(i=Cl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Cl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Cl.RGBCOLORS:break;case Cl.MAGNITUDE:default:{const o=Ns.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Pl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Sl.UNSIGNED_CHAR)return n;const i=Ns.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Sl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=wl;switch(n.getDataType()!==Sl.FLOAT&&n.getDataType()!==Sl.DOUBLE||(s=Pl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return Il("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==Al.DEFAULT||n.getDataType()!==Sl.UNSIGNED_CHAR)&&r!==Al.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Rl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Cl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function Ml(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rl,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Ol(e,t)}var El={newInstance:jt.newInstance(Ml,"vtkScalarsToColors"),extend:Ml,...Tl};const{vtkErrorMacro:Dl}=jt;function Vl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===yl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Dl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==Cs.UNSIGNED_CHAR)return Dl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Bl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ll,n),El.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Vl(e,t)}var Nl={newInstance:jt.newInstance(Bl,"vtkLookupTable"),extend:Bl};const _l={Off:0,PolygonOffset:1};let Fl=_l.PolygonOffset,kl=_l.Off;const Gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Ul(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=kl===e;return kl=e,t}var zl={Resolve:_l,getResolveCoincidentTopologyAsString:function(){return Gl[kl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Fl},getResolveCoincidentTopology:function(){return kl},setResolveCoincidentTopology:Ul,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=Fl===e;return Fl=e,t},setResolveCoincidentTopologyToDefault:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToOff:function(){return Ul(_l.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Ul(_l.PolygonOffset)}};function Wl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=jt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Hl=["Polygon","Line","Point"],jl={modified:()=>{}};Wl(jl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Hl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Kl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(zl).forEach((t=>{e[t]=zl[t]})),Object.keys(jl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=jl[t]})),Wl(e,t.topologyOffset,Hl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=jl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=jl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:jl,otherStaticMethods:zl,CATEGORIES:Hl,Resolve:_l};const $l={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var ql={PassTypes:$l};const{FieldAssociations:Xl}=ll,{staticOffsetAPI:Yl,otherStaticMethods:Zl}=Kl,{ColorMode:Ql,ScalarMode:Jl,GetArray:ec}=bl,{VectorMode:tc}=Tl,{VtkDataTypes:nc}=Ns;function rc(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function oc(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function ac(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const ic=new WeakMap;function sc(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(Ql,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(Jl,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Jl.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Jl.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Jl.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Jl.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Jl.USE_FIELD_DATA){const t=e.getFieldData();i=r===ec.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale();i&&Nl.getLogRange(a,a);const s=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,u=n**3-3,d=4094,p=2,f=r?u:d;t.numberOfColorsInRange=Math.min(Math.max(e,p),f);const g=t.numberOfColorsInRange+3,m=t.numberOfColorsInRange+2,h=r?[Math.min(Math.ceil(g/n**0),n),Math.min(Math.ceil(g/n**1),n),Math.min(Math.ceil(g/n**2),n)]:[m,2,1],v=h[0]*h[1]*h[2],y=new Float64Array(v);y.fill(NaN);const T=t.numberOfColorsInRange,b=T+2,x=[0,0,0],C=a[0],S=a[1]-a[0];for(let e=0;e<b;++e){const t=C+S*(e-1)/(T-1);y[(c=h,(l=x)[0]+c[0]*(l[1]+c[1]*l[2]))]=i?10**t:t,oc(x,h)}const A=Ns.newInstance({numberOfComponents:1,values:y}),I=t.lookupTable.mapScalars(A,t.colorMode,0);t.colorTextureMap=vl.newInstance(),t.colorTextureMap.setDimensions(h),t.colorTextureMap.getPointData().setScalars(I),t.lookupTable.setAlpha(s)}var l,c;const u=t.lookupTable.getVectorMode()===tc.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=ic.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(r-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(r+1)/(p-d),v=e.getData(),y=e.getNumberOfTuples(),T=e.getNumberOfComponents(),b=t<0||t>=T,x=o[2]<=1?2:3,C=Ns.newInstance({numberOfComponents:x,values:new Float32Array(y*x)}),S=C.getData(),A=[0,0,0];ac(A,r+2,o);let I=0,w=0;const P=[.5,.5,.5];for(let e=0;e<y;++e){let e;if(b){let t=0;for(let e=0;e<T;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(I+=T,a&&(e=Nl.applyLogScale(e,n,n)),_a(e))P[0]=A[0],P[1]=A[1],P[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>r&&(t=r+1),ac(P,t,o)}else{P[1]=.49;const t=(e-f)*g;P[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=P[e]}return ic.set(e,{stringHash:l,textureCoordinates:C}),C}(n,u,a,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),i,r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Ql.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Ql.DEFAULT&&e.getDataType()===nc.UNSIGNED_CHAR||t.colorMode===Ql.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=rc("AcquireInvertibleLookupTable"),e.valueToColor=rc("ValueToColor"),e.colorToValue=rc("ColorToValue"),e.useInvertibleColorFor=rc("UseInvertibleColorFor"),e.clearInvertibleColor=rc("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer($l.ID_LOW24),o=e.getRawPixelBuffer($l.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Xl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Xl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===$l.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer($l.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===$l.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer($l.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const lc={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lc,n),zs(e,t,n),jt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Kl.implementCoincidentTopologyMethods(e,t),sc(e,t)}var uc={newInstance:jt.newInstance(cc,"vtkMapper"),extend:cc,...Yl,...Zl,...bl};function dc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function pc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const fc={extractCellSizes:dc,getNumberOfCells:pc};function gc(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=pc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=dc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function mc(e){return{empty:!0,numberOfComponents:1,dataType:Cs.UNSIGNED_INT,...e}}function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ns.extend(e,t,mc(n)),gc(e,t)}var vc={newInstance:jt.newInstance(hc,"vtkCellArray"),extend:hc,...fc};const{vtkErrorMacro:yc}=jt,Tc=[1,-1,1,-1,1,-1];function bc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return yc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Tc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const xc={empty:!0,numberOfComponents:3,dataType:Cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),Ns.extend(e,t,n),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkPoints"),extend:Cc};function Ac(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const Ic={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),jt.obj(e,t),t.points||(t.points=Sc.newInstance()),jt.get(e,t,["points","pointsIds"]),Ac(e,t)}var Pc={newInstance:jt.newInstance(wc,"vtkCell"),extend:wc};function Oc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Pc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Pc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const Rc={array:null,maxId:0,extend:0};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),jt.obj(e,t),Oc(e,t)}var Ec={newInstance:jt.newInstance(Mc,"vtkCellLinks"),extend:Mc};const Dc=0,Vc=1,Lc=2,Bc=3,Nc=4,_c=5,Fc=6,kc=7,Gc=9,Uc=21,zc=41,Wc=42,Hc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],jc={getClassNameFromTypeId:function(e){return e<Hc.length?Hc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Hc.findIndex(e)},isLinear:function(e){return e<Uc||e===zc||e===Wc},hasSubCells:function(e){return e===Fc||e===Nc||e===Lc}};function Kc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Dc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const $c={size:0,maxId:-1,extend:1e3};function qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$c,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Kc(e,t)}var Xc={newInstance:jt.newInstance(qc,"vtkCellTypes"),extend:qc,...jc},Yc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Zc}=Yc;function Qc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function Jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Qc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Zc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Zc.YES_INTERSECTION:Zc.NO_INTERSECTION}const eu={distanceToLine:Qc,intersection:Jc};function tu(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Zc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Qc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Qc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Qc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Qc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const nu={orientations:null};function ru(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nu,n),Pc.extend(e,t,n),jt.setGet(e,t,["orientations"]),tu(e,t)}var ou={newInstance:jt.newInstance(ru,"vtkLine"),extend:ru,...eu,...Yc};function au(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=Sc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=Sc.newInstance(),t.points.shallowCopy(e.getPoints())}}const iu={};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),ll.extend(e,t,n),jt.setGet(e,t,["points"]),au(e,t)}var lu={newInstance:jt.newInstance(su,"vtkPointSet"),extend:su};function cu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function uu(e,t,n,r){cu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const du={computeNormalDirection:cu,computeNormal:uu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];uu(e,t,n,d),uu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ii.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ii.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[E],P[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function pu(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(uu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ii.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=ou.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),cu(l,c,u,d),ii.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=ou.distanceToLine(e,l,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=ou.distanceToLine(e,c,u,t,S),x=ou.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=ou.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=ou.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=ou.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const fu={};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Pc.extend(e,t,n),pu(e,t)}var mu={newInstance:jt.newInstance(gu,"vtkTriangle"),extend:gu,...du};const hu=["verts","lines","polys","strips"],{vtkWarningMacro:vu}=jt,yu={[Bc]:ou,[Nc]:ou,[_c]:mu};function Tu(e,t){t.classHierarchy.push("vtkPolyData"),hu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=vc.newInstance()})),e.getNumberOfCells=()=>hu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),hu.forEach((n=>{t[n]=vc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?Lc:Vc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Nc:Bc,1===t&&vu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=_c;break;case 4:l[n]=Gc;break;default:l[n]=kc}t<3&&vu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Fc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Xc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Vc:case Lc:o=t.verts;break;case Bc:case Nc:o=t.lines;break;case _c:case Gc:case kc:o=t.polys;break;case Fc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||yu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const bu={};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),lu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),Tu(e,t)}var Cu={newInstance:jt.newInstance(xu,"vtkPolyData"),extend:xu};function Su(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const Au={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),Su(e,t)}const wu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Pu={newInstance:jt.newInstance(Iu,"vtkTexture"),extend:Iu,...wu};const Ou=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Ru=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Mu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Eu=[0,1,0,1,0,1,0,1,2,2,2,2],Du=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Vu=new Float64Array(3),Lu=new Float64Array(3),Bu=new Float64Array(3),Nu=new Float64Array(3),_u=new Float64Array(3),Fu=new Float64Array(3),ku=new Float64Array(16);function Gu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Uu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=go().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}function zu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],Vn(Bu,Vu,r),Bu[0]+=.1,Vn(Lu,Bu,o),Pn(_u,Lu,Vu),Bu[0]-=.1,Bu[1]+=.1,Vn(Lu,Bu,o),Pn(Fu,Lu,Vu);for(let e=0;e<3;e++)_u[e]/=.05*u[0],Fu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Vu[0]=c[3*n],Vu[1]=c[3*n+1],Vu[2]=c[3*n+2],a[0]<-.5?On(Bu,_u,a[0]*i-l.width):a[0]>.5?On(Bu,_u,a[0]*i):On(Bu,_u,a[0]*i-l.width/2),wn(Vu,Vu,Bu),On(Bu,Fu,a[1]*i-l.height/2),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Bu,_u,l.width),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Bu,Fu,l.height),wn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Bu,_u,l.width),Pn(Vu,Vu,Bu),s.points[3*d]=Vu[0],s.points[3*d+1]=Vu[1],s.points[3*d+2]=Vu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(ku,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Vu[0]=f[3*u],Vu[1]=f[3*u+1],Vu[2]=f[3*u+2],Vn(Bu,Vu,n),Vu[0]=f[3*u+3],Vu[1]=f[3*u+4],Vu[2]=f[3*u+5],Vn(Nu,Vu,n),Pn(Bu,Bu,Nu);const r=[Bu[0],Bu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,ku,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Wu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],zu(e,t)}),"vtkCubeAxesActorHelper");function Hu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Wi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Vu[s]=t.dataBounds[a]-.1*r*Ou[a][s],Vu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Vu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Bu,Vu,e),Vu[s]=t.dataBounds[a],Vn(Nu,Vu,e),Pn(Bu,Nu,Bu),Mn(Bu,Bu),i=Bu[2]>o,t.camera.getParallelProjection()||(Mn(Nu,Nu),i=En(Nu,Bu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Du[t][0]].length+2*r[Du[t][1]].length,a+=r[Du[t][0]].length+r[Du[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Mu[e][0],l[3*u+2]=Mu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Du[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][0]]=o[r],s[3*c+Du[n][1]]=t.dataBounds[2*Du[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Du[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Du[n][1]]=o[r],s[3*c+Du[n][0]]=t.dataBounds[2*Du[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Eu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Ru[a][e];if(1===n[d]){const e=Eu[d],n=3*Mu[d][0],p=3*Mu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Du[a][0]]=.5*(t.dataBounds[2*Du[a][0]]+t.dataBounds[2*Du[a][0]+1]),s[3*l+Du[a][1]]=.5*(t.dataBounds[2*Du[a][1]]+t.dataBounds[2*Du[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Ru[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Gu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Gu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Gu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Wi.setBounds(t.bounds,t.gridActor.getBounds()),Wi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function ju(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Wi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Uu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,ju(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=uc.newInstance(),t.polyData=Cu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=bs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Cu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Hu(e,t)}var $u={newInstance:jt.newInstance(Ku,"vtkCubeAxesActor"),extend:Ku,newCubeAxesActorHelper:Wu,defaultGenerateTicks:Uu};function qu(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Xu={};const Yu=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=$u.newCubeAxesActorHelper(),qu(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Yu);const Zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Qu={ObjectType:Zu};const{ObjectType:Ju}=Qu;function ed(e,t){function n(e){switch(e){case Ju.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Ju.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Ju.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const td={objectType:Ju.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function nd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,td,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ed(e,t)}var rd={newInstance:jt.newInstance(nd),extend:nd,...Qu};const{vtkErrorMacro:od}=jt;function ad(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=rd.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===ss.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===ss.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,E=0,D=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];E+=n*n;const r=.5*(t[1]+t[0]);D+=r*r}const V=E>0&&(Math.abs(D)/E>1e6||Math.abs(Math.log10(E))>3||0===E&&D>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,T++)C(A[e],A,e+1,T+a.cellOffset);return t.elementCount=w,e.upload(O,Zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,Zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,ji(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):od("Wrong type for coordScale, expected vec3 or null"):od("Wrong type for coordShift, expected vec3 or null")}}const id={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),rd.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),ad(e,t)}var ld={newInstance:jt.newInstance(sd),extend:sd};const{vtkErrorMacro:cd}=jt;function ud(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return cd(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const dd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkShader"),extend:pd};const{vtkErrorMacro:gd}=jt;function md(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(gd(`Links failed: ${t.error}`),0):(gd(t.error),0):(gd(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.fragmentShader.getError()),0):(gd(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),gd(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return gd(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(gd("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return gd("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const hd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=fd.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=fd.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=fd.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),md(e,t)}var yd={newInstance:jt.newInstance(vd,"vtkShaderProgram"),extend:vd,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function Td(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const bd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function xd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),Td(e,t)}var Cd={newInstance:jt.newInstance(xd,"vtkOpenGLVertexArrayObject"),extend:xd};const Sd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function Ad(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===ss.POINTS||n===Sd.Points?t.context.POINTS:e===ss.WIREFRAME||n===Sd.Lines||n===Sd.TrisEdges||n===Sd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Sd.Points||r.getProperty().getRepresentation()===ss.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=yd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Sd.Points?2:t.primitiveType===Sd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const Id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=yd.newInstance(),t.VAO=Cd.newInstance(),t.CABO=ld.newInstance(),Ad(e,t)}var Pd={newInstance:jt.newInstance(wd),extend:wd,primTypes:Sd};const Od={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Rd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Md={Wrap:Od,Filter:Rd};const Ed=new Float32Array(1),Dd=new Int32Array(Ed.buffer);var Vd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Ed[0]=e;const t=Dd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Ld;const{Wrap:Bd,Filter:Nd}=Md,{VtkDataTypes:_d}=Ns,{vtkDebugMacro:Fd,vtkErrorMacro:kd,vtkWarningMacro:Gd}=Kt,{toHalf:Ud}=Vd;function zd(e,t){t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Nd.LINEAR),e.setMagnificationFilter(Nd.LINEAR)):(e.setMinificationFilter(Nd.NEAREST),e.setMagnificationFilter(Nd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Bd.REPEAT),e.setWrapS(Bd.REPEAT),e.setWrapT(Bd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,_d.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Nd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const n=()=>{if(t.minificationFilter!==Nd.LINEAR&&t.magnificationFilter!==Nd.LINEAR||(void 0===Ld&&(Ld=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,y=i.getExtension("WEBGL_lose_context");return y&&y.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Ld))return t.oglNorm16Ext};function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Vd.toHalf(Vd.fromHalf(e[u][l+s+t])*h*(1-v)+Vd.fromHalf(e[u][l+p+t])*h*v+Vd.fromHalf(e[u][c+s+t])*m*(1-v)+Vd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&n())||e!==_d.UNSIGNED_SHORT&&e!==_d.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Gd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Fd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Gd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(r,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(r,o,n(),e.useHalfFloat()),a||(a||(Fd("Unsupported internal texture type!"),Fd(`Unable to find suitable internal format for T=${r} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=r=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case n()&&!o&&_d.SHORT:return t.context.SHORT;case n()&&!o&&_d.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&_d.SHORT:case o&&_d.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case _d.FLOAT:case _d.VOID:default:return t.context.FLOAT}switch(r){case _d.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case _d.FLOAT:case _d.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Nd.NEAREST:return t.context.NEAREST;case Nd.LINEAR:return t.context.LINEAR;case Nd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Nd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Nd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Nd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Bd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Bd.REPEAT:return t.context.REPEAT;case Bd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==_d.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==_d.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Ud(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=e.updateArrayDataTypeForGL(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(e.updateArrayDataTypeForGL(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,n(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=(r,a,i,s)=>(e.getOpenGLDataType(i),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?i===_d.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=r,t.height=a,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(i,n(),e.useHalfFloat()),e.deactivate(),!0):(kd("Failed to determine texture parameters."),!1)),e.create2DFromImage=r=>{if(e.getOpenGLDataType(_d.UNSIGNED_CHAR),e.getInternalFormat(_d.UNSIGNED_CHAR,4),e.getFormat(_d.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const a=!(t._openGLRenderWindow.getWebgl2()||Fo(r.width)&&Fo(r.height)),i=document.createElement("canvas");i.width=a?_o(r.width):r.width,i.height=a?_o(r.height):r.height,t.width=i.width,t.height=i.height;const s=i.getContext("2d");s.translate(0,i.height),s.scale(1,-1),s.drawImage(r,0,0,r.width,r.height,0,0,i.width,i.height);const l=i;return o(_d.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=l&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,l)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,l),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(_d.UNSIGNED_CHAR,n(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Ns.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.updateVolumeInfoForGL=(r,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(n()&&!i&&r===_d.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(n()&&!i&&r===_d.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(r===_d.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(r===_d.FLOAT||i&&(r===_d.SHORT||r===_d.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=(a,i,s,l,c,u)=>{let d=c,p=u;if(!e.updateVolumeInfoForGL(d,l)&&p){const e=a*i*s,n=structuredClone(t.volumeInfo),r=new Float32Array(e*l);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const c=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<l;e++)r[o]=(p[o]-n.offset[e])*c[e],o++;d=_d.FLOAT,p=r}if(e.getOpenGLDataType(d),e.getInternalFormat(d,l),e.getFormat(d,l),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const f=[p],g=r(e.updateArrayDataTypeForGL(d,f,!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(d)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=g[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,g[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,g[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(d,n(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Ns.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=[],g=[];for(let e=0;e<c;++e)f[e]=0,g[e]=1;if(t.volumeInfo={scale:g,offset:f,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw(n,r,i,c,u,d);const m=n*r*i,h=structuredClone(p);let v=(e,t,n,r,o)=>{e[t]=n},y=_d.UNSIGNED_CHAR;if(u===_d.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=_d.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=_d.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return kd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===_d.FLOAT||c>=3)&&(T=4096);let b=1,x=1;m>T*T&&(b=Math.ceil(Math.sqrt(m/(T*T))),x=b);let C=Math.sqrt(m)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===_d.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Wd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Bd.CLAMP_TO_EDGE,wrapT:Bd.CLAMP_TO_EDGE,wrapR:Bd.CLAMP_TO_EDGE,minificationFilter:Nd.NEAREST,magnificationFilter:Nd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),zd(e,t)}const jd=Dt(Hd,"vtkOpenGLTexture");var Kd={newInstance:jd,extend:Hd,...Md};rn("vtkTexture",jd);var $d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",qd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Xd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=yd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=yd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=yd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Yd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=yd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Zd}=ll,{primTypes:Qd}=Pd,{Representation:Jd,Shading:ep}=ms,{ScalarMode:tp}=uc,{Filter:np,Wrap:rp}=Kd,{vtkErrorMacro:op}=Kt,ap={type:"StartEvent"},ip={type:"EndEvent"},{CoordinateSystem:sp}=ts;function lp(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=yd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=yd.substitute(i,"//VTK::Color::Impl",c).result):i=yd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=yd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=yd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=yd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=yd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=yd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:op("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=yd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=yd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=yd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=yd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=yd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=yd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=yd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=yd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=yd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=yd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=yd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=yd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=yd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=yd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=yd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Jd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Qd.Points||o.getRepresentation()===Jd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Qd.Lines||o.getRepresentation()===Jd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Qd.Tris&&e!==Qd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Qd.TrisEdges&&e!==Qd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=yd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==$l.ID_LOW24&&t.lastSelectionState!==$l.ID_HIGH24||(a=yd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=yd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=yd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=yd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case $l.ID_LOW24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case $l.ID_HIGH24:o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=yd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=yd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===ep.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||op("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||op(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||op("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||op("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===sp.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():$l.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Jd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Zd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===$l.ID_LOW24||t.lastSelectionState===$l.ID_HIGH24);for(let i=Qd.Start;i<Qd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Qd.TrisEdges||i===Qd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ip),!t.currentInput)return void op("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==tp.USE_CELL_DATA&&a!==tp.USE_CELL_FIELD_DATA&&a!==tp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===tp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==ep.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Kd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(np.NEAREST),e.setMagnificationFilter(np.NEAREST),e.setWrapS(rp.CLAMP_TO_EDGE),e.setWrapT(rp.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Jd.SURFACE;for(let n=Qd.Start;n<Qd.End;n++)n!==Qd.TrisEdges&&n!==Qd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Jd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const cp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:$l.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=Qd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=Qd.Start;e<Qd.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),lp(e,t)}const dp=Dt(up,"vtkOpenGLPolyDataMapper");var pp={newInstance:dp,extend:up};rn("vtkMapper",dp);const{ColorMode:fp,ScalarMode:gp,GetArray:mp}=bl;function hp(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=Nl.newInstance()},e.getColorModeAsString=()=>jt.enumToString(fp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(gp,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===gp.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===gp.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===gp.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===gp.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===gp.USE_FIELD_DATA){const t=e.getFieldData();i=r===mp.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const vp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),ks(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),hp(e,t)}var Tp={newInstance:jt.newInstance(yp,"vtkMapper2D"),extend:yp};const bp=1,{primTypes:xp}=Pd,{ScalarMode:Cp}=Tp,{vtkErrorMacro:Sp}=Kt,Ap={type:"StartEvent"},Ip={type:"EndEvent"};function wp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=xp.Start;e<xp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Ap),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Ip),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Sp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Cp.USE_CELL_DATA&&a!==Cp.USE_CELL_FIELD_DATA&&a!==Cp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Cp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Sc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[xp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[xp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[xp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[xp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=xp.Start;a<xp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=yd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=yd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=yd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=yd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=yd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=yd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=yd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=yd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=yd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=yd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=yd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=yd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=yd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=yd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=yd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=yd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=yd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Sp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Sp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Sp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===bp?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Pp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Op=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pp,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.primitives=[],t.primTypes=xp,t.tmpMat4=g(new Float64Array(16));for(let e=xp.Start;e<xp.End;e++)t.primitives[e]=Pd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),wp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",Op);const{VectorMode:Rp}=El;function Mp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Ep(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Vp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Mp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Mp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Mp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Ns.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Rp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ns.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Lp=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=uc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Cu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=bs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Cu.newInstance(),t.tmMapper=uc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Pu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=bs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Vp(e,t)}),"vtkScalarBarActorHelper");function Bp(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Ep(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dp())}}function Np(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Np(n)),t.autoLayout||(t.autoLayout=Ep(0,t)),t.generateTicks||(t.generateTicks=Dp()),bs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Bp(e,t)}var Fp={newInstance:jt.newInstance(_p,"vtkScalarBarActor"),extend:_p,newScalarBarActorHelper:Lp};function kp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gp={};const Up=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Fp.newScalarBarActorHelper(),kp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Up);const{vtkErrorMacro:zp}=Kt;function Wp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ns.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Hp={context:null};const jp=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Zt.extend(e,t,n),t.openGLTexture=Kd.newInstance(),t.tris=Pd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Wp(e,t)}));rn("vtkSkybox",jp);const{FieldAssociations:Kp}=ll;function $p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const qp={fieldAssociation:Kp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),$p(e,t)}var Yp={newInstance:jt.newInstance(Xp,"vtkHardwareSelector"),extend:Xp};function Zp(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Kd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Rd.LINEAR),r.setMagnificationFilter(Rd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,Cs.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const Qp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Zp(e,t)}var ef={newInstance:Dt(Jp,"vtkFramebuffer"),extend:Jp};function tf(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const nf={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function rf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nf,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),tf(e,t)}var of={newInstance:jt.newInstance(rf,"vtkSelectionNode"),extend:rf,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:af}=ql,{SelectionContent:sf,SelectionField:lf}=of,{FieldAssociations:cf}=ll,{vtkErrorMacro:uf}=jt;function df(e){return`${e.propID} ${e.compositeID}`}function pf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ff(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function gf(e,t){let n=t;return n<<=24,n|=e,n}function mf(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ff(n[0],n[1],e.pixBuffer[af.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ff(n[0],n[1],e.pixBuffer[af.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[af.ID_LOW24]&&0===pf(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area))return a;const s=ff(n[0],n[1],e.pixBuffer[af.ID_LOW24],e.area),l=ff(n[0],n[1],e.pixBuffer[af.ID_HIGH24],e.area);return a.attributeID=gf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=mf(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=mf(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=mf(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=mf(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function hf(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=of.newInstance();switch(l.setContentType(sf.INDICES),e){case cf.FIELD_ASSOCIATION_CELLS:l.setFieldType(lf.CELL);break;case cf.FIELD_ASSOCIATION_POINTS:l.setFieldType(lf.POINT);break;default:uf("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function vf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=mf(e,[n,t],0,u);if(r&&r.valid){const t=df(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return hf(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function yf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return vf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return uf("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=af.MIN_KNOWN_PASS;t.currentPass<=af.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===af.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=af.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===af.ID_HIGH24){if(t.fieldAssociation===cf.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===cf.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===af.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ff(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===af.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===af.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(af,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ff(e[0],e[1],t.pixBuffer[af.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ff(e[0],e[1],t.pixBuffer[af.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[af.ID_LOW24]&&0===pf(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area))return a;const s=ff(e[0],e[1],t.pixBuffer[af.ID_LOW24],t.area),l=ff(e[0],e[1],t.pixBuffer[af.ID_HIGH24],t.area);return a.attributeID=gf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=df(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return hf(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const Tf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Yp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),yf(e,t)}var xf={newInstance:jt.newInstance(bf,"vtkOpenGLHardwareSelector"),extend:bf,...ql};const{vtkErrorMacro:Cf}=Kt,{Representation:Sf}=ms,{ObjectType:Af}=rd,{PassTypes:If}=xf,wf={type:"StartEvent"},Pf={type:"EndEvent"};function Of(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(wf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Pf),!t.currentInput)return void Cf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=yd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=yd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=yd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=yd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=yd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=yd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=yd.substitute(o,"//VTK::Color::Impl",s).result,o=yd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=yd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=yd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=yd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=yd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=yd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=yd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===Sf.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===If.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Cf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Cf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Cf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=rd.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=rd.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=rd.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=rd.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,Af.ARRAY_BUFFER),t.normalBuffer.upload(n,Af.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),Af.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Af.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Rf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Mf=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),pp.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),Of(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",Mf);const{vtkErrorMacro:Ef}=jt;class Df{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Vf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Ef("Invalid or missing input");const r=Cu.newInstance();r.shallowCopy(n);const o=new Df,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(vc.newInstance({values:c,name:"faces"})),t[0]=r}}const Lf={};function Bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),jt.obj(e,t),jt.algo(e,t,1,1),Vf(e,t)}var Nf={newInstance:jt.newInstance(Bf,"vtkClosedPolyLineToSurfaceFilter"),extend:Bf};const{vtkErrorMacro:_f}=Kt;function Ff(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void _f("Invalid or missing input");if(!t.cutFunction)return void _f("Missing cut function");const o=Cu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const kf={cutFunction:null,cutScalars:null,cutValue:0};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Ff(e,t)}var Uf={newInstance:Dt(Gf,"vtkCutter"),extend:Gf};const zf=e=>e,Wf=1e-6;class Hf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:zf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=En(n,r);return a>=1||(Dn(this.tmp,n,r),Sn(this.tmp)<Wf&&(Dn(this.tmp,[1,0,0],e),Sn(this.tmp)<Wf&&Dn(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var jf=function(){return new Hf(!0)},Kf=function(){return new Hf(!1)};const $f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],qf=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function Xf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Cu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Ns.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Ns.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&jf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Kf().translate(...t.center).apply(o),t.matrix){Kf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Kf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Yf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=vc.newInstance({values:Uint16Array.from(qf)}),t._lineCells=vc.newInstance({values:Uint16Array.from($f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),Xf(e,t)}var Qf={newInstance:jt.newInstance(Zf,"vtkCubeSource"),extend:Zf};const{vtkErrorMacro:Jf}=jt;function eg(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Jf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Jf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const tg={};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=Qf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),eg(e,t)}var rg={newInstance:jt.newInstance(ng,"vtkImageDataOutlineFilter"),extend:ng};let og;function ag(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>og({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const ig={preMultiplyFlag:!1,matrix:[...vo]};function sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),ag(e,t)}og=jt.newInstance(sg,"vtkTransform");var lg={newInstance:og,extend:sg};function cg(e,t,n){return e?`${e.getMTime()}-${t}-${n}`:"0"}function ug(e,t){return`${e.getMTime()}A${t.getMTime()}`}const dg={NEAREST:0,LINEAR:1};var pg={InterpolationType:dg};const{vtkErrorMacro:fg}=Kt;function gg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function mg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera());const o=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),o&&!o.isDeleted()&&o!==t._openGLRenderWindow&&n(o),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):fg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.openGLTexture.setMinificationFilter(Rd.LINEAR),t.openGLTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()?.getScalars();if(!a)return;const i=a.getNumberOfComponents();let s=ug(o,a);const l=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(l?.oglObject?.getHandle()&&l?.hash===s)t.openGLTexture=l.oglObject;else{t.openGLTexture=Kd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a),t._openGLRenderWindow.setGraphicsResourceForObject(a,t.openGLTexture,s),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a}const c=r.getProperty(),u=c.getIndependentComponents(),d=u?i:1,p=u?2*d:1,f=c.getRGBTransferFunction();s=cg(f,u,d);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===s)t.colorTexture=g.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*p*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=c.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,s),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const m=c.getPiecewiseFunction();s=cg(m,u,d);const h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===s)t.pwfTexture=h.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),m){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=c.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.pwfTexture,s),m!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=m)}const v=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==v){const e=Ns.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ns.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:fg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",ss.SURFACE,r)}t.VBOBuildString=v,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||fg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",gg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",gg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=yd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=yd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=yd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=yd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:fg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=yd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:fg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=yd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=yd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=yd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ii.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();za.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Cu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ns.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Cu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ns.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else fg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const hg={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1};const vg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=rg.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Cu.newInstance(),t.cutter=Uf.newInstance(),t.lineToSurfaceFilter=Nf.newInstance(),t.transform=lg.newInstance(),bt(e,t,["openGLTexture"]),mg(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",vg);var yg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Tg}=Kt,{SlicingMode:bg}=yg;function xg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function Cg(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=yd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=yd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Tg("Unsupported number of independent coordinates.")}}if(i=yd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=yd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=yd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Tg("Unsupported number of independent coordinates.")}i=yd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=yd.substitute(i,"//VTK::TCoord::Impl",[...xg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=yd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Tg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Tg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===bg.NONE&&(i=bg.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Tg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=cg(f,u,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.oglObject?.getHandle()&&m?.hash===g)t.colorTexture=m.oglObject;else{t.colorTexture=Kd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(n*p*3);if(c===dg.NEAREST?(t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST)):(t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR)),f){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,p,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,g),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}const h=l.getPiecewiseFunction(),v=cg(h,u,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.oglObject?.getHandle()&&y?.hash===v)t.pwfTexture=y.oglObject;else{const n=1024,r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===dg.NEAREST?(t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR)),h){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,p,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);h&&(t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,v),h!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(h,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=h)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===bg.I&&(S=x-C[0]),T===bg.J&&(S=x-C[2]),T!==bg.K&&T!==bg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Kd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===dg.NEAREST?(new Set([1,3,4]).has(s)&&i===Cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.NEAREST)):t.openGLTexture.setMinificationFilter(Rd.NEAREST),t.openGLTexture.setMagnificationFilter(Rd.NEAREST)):(4!==s||i!==Cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Rd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Rd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Rd.LINEAR)),t.openGLTexture.setWrapS(Od.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Od.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[bg.X,bg.Y,bg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===bg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===bg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===bg.K||T===bg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Tg("Reformat slicing not yet supported.");t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const m=Ns.newInstance({numberOfComponents:3,values:r});m.setName("points");const h=Ns.newInstance({numberOfComponents:2,values:l});h.setName("tcoords");const v=new Uint16Array(8);v[0]=3,v[1]=0,v[2]=1,v[3]=3,v[4]=3,v[5]=0,v[6]=3,v[7]=2;const y=Ns.newInstance({numberOfComponents:1,values:v});t.tris.getCABO().createVBO(y,"polys",ss.SURFACE,{points:m,tcoords:h,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Kd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Sg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const Ag=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sg,n),Zt.extend(e,t,n),Xd(e,t,n),Yd(e,t,n),t.tris=Pd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),Cg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",Ag);const Ig=0,wg=1,Pg=2,{vtkErrorMacro:Og}=jt;function Rg(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===_l.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===dg.NEAREST?(t.volumeTexture.setMinificationFilter(Rd.NEAREST),t.volumeTexture.setMagnificationFilter(Rd.NEAREST),t.colorTexture.setMinificationFilter(Rd.NEAREST),t.colorTexture.setMagnificationFilter(Rd.NEAREST),t.pwfTexture.setMinificationFilter(Rd.NEAREST),t.pwfTexture.setMagnificationFilter(Rd.NEAREST)):(t.volumeTexture.setMinificationFilter(Rd.LINEAR),t.volumeTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.pwfTexture.setMinificationFilter(Rd.LINEAR),t.pwfTexture.setMagnificationFilter(Rd.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=o?.getPointData()?.getScalars();if(!i)return;const s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=ug(o,i);if(s?.oglObject?.getHandle()&&s?.hash===l)t.volumeTexture=s.oglObject;else{t.volumeTexture=Kd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],i,t.renderable.getPreferSizeOverAccuracy()),t._openGLRenderWindow.setGraphicsResourceForObject(i,t.volumeTexture,l),i!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(i,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=i}const c=i.getNumberOfComponents(),u=r.getProperty(),d=u.getIndependentComponents(),p=d?c:1,f=d?2*p:1,g=u.getRGBTransferFunction(),m=cg(g,d,p),h=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(h?.oglObject?.getHandle()&&h?.hash===m)t.colorTexture=h.oglObject;else{const n=1024,r=new Uint8ClampedArray(n*f*3);if(t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),g){const e=new Float32Array(3*n);for(let t=0;t<p;t++){const o=u.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),d)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,f,3,Cs.UNSIGNED_CHAR,r)}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(n,1,3,Cs.UNSIGNED_CHAR,r)}g&&(t._openGLRenderWindow.setGraphicsResourceForObject(g,t.colorTexture,m),g!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(g,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=g)}const v=u.getPiecewiseFunction(),y=cg(v,d,p),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===y)t.pwfTexture=T.oglObject;else{const n=1024,r=n*f,o=new Uint8ClampedArray(r);if(t.pwfTexture=Kd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),v){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<p;++t){const r=u.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),d)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,f,1,Cs.FLOAT,e)}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(n,1,1,Cs.UNSIGNED_CHAR,o);v&&(t._openGLRenderWindow.setGraphicsResourceForObject(v,t.pwfTexture,y),v!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(v,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=v)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ns.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ns.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ns.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Ns.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ns.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ns.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",ss.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=yd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=yd.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Og("Unsupported number of independent coordinates.")}}i=yd.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===wg?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Ig:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case wg:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===Pg&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Og("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=yd.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=yd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=yd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=yd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=yd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=$d,e.Fragment=qd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Og("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Og(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),Rn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),T(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=jt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}const Mg={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Eg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mg,n),Zt.extend(e,t,n),Xd(e,t,n),jt.algo(e,t,2,0),t.tris=Pd.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),Rg(e,t)}),"vtkOpenGLImageCPRMapper");function Dg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Eg);const Vg={context:null,keyMatrixTime:null,keyMatrices:null};const Lg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),Dg(e,t)}),"vtkOpenGLImageSlice");function Bg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Lg);const Ng={};const _g=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Bg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",_g);const Fg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},kg={FRACTIONAL:0,PROPORTIONAL:1},Gg={CUSTOM:0,ADDITIVE:1,COLORIZE:2};var Ug={InterpolationType:Fg,OpacityMode:kg,ColorMixPreset:Gg};const zg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Wg={BlendMode:zg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Hg,vtkErrorMacro:jg}=Kt;function Kg(e,t){function n(n){[t._scalars,t._scalarOpacityFunc,t._colorTransferFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(r,o)=>{if(r){const r=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const o=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const a=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(a.getActiveCamera()),e.renderPiece(a,o)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.useIndependentComponents=e=>{const n=e.getIndependentComponents(),r=t.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(),o=e.getColorMixPreset();return n&&r>=2||!!o},e.replaceShaderValues=(n,r,o)=>{const a=o.getProperty();let i=n.Fragment;a.getInterpolationType()===Fg.LINEAR&&(i=yd.substitute(i,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===e.isLabelmapOutlineRequired(o)&&(i=yd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result),t.renderable.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND&&(i=yd.substitute(i,"//VTK::LabelEdgeProjectionOn","#define vtkLabelEdgeProjectionOn").result);const s=t.scalarTexture.getComponents();i=yd.substitute(i,"//VTK::NumComponents",`#define vtkNumComponents ${s}`).result;const l=e.useIndependentComponents(a);l&&(i=yd.substitute(i,"//VTK::IndependentComponentsOn","#define UseIndependentComponents").result);const c=[],u=[];for(let e=0;e<s;e++)a.getOpacityMode(e)===kg.PROPORTIONAL&&c.push(`#define vtkComponent${e}Proportional`),a.getForceNearestInterpolation(e)&&u.push(`#define vtkComponent${e}ForceNearest`);i=yd.substitute(i,"//VTK::vtkProportionalComponents",c.join("\n")).result,i=yd.substitute(i,"//VTK::vtkForceNearestComponents",u.join("\n")).result;const d=function(e){switch(e){case Gg.CUSTOM:return"//VTK::CustomColorMix";case Gg.ADDITIVE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n\n          vec3 scalarInterp1[2];\n          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);\n          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;\n          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;\n          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n          vec4 normalLight1 = normalMat[1];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        float opacity1 = pwfValue1;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          opacity1 *= gof1;\n        #endif\n        float opacitySum = opacity0 + opacity1;\n        if (opacitySum <= 0.0) {\n          return vec4(0.0);\n        }\n\n        // mix the colors and opacities\n        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);\n        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);\n        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;\n        return vec4(mixedColor, min(1.0, opacitySum));\n";case Gg.COLORIZE:return"\n        // compute normals\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)\n          vec3 scalarInterp0[2];\n          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);\n          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;\n          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;\n          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);\n        #else\n          vec4 normalLight0 = normalMat[0];\n        #endif\n\n        // compute opacities\n        float opacity0 = pwfValue0;\n        #ifdef vtkGradientOpacityOn\n          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n          opacity0 *= gof0;\n        #endif\n\n        // mix the colors and opacities\n        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);\n        color = applyAllLightning(color, opacity0, posIS, normalLight0);\n        return vec4(color, opacity0);\n";default:return null}}(a.getColorMixPreset());d&&(i=yd.substitute(i,"//VTK::CustomComponentsColorMixOn","#define vtkCustomComponentsColorMix").result,i=yd.substitute(i,"//VTK::CustomComponentsColorMix::Impl",d).result);const p=t.currentInput.getSpatialExtent(),f=t.currentInput.getSpacing(),g=new Float64Array(3);In(g,(p[1]-p[0])*f[0],(p[3]-p[2])*f[1],(p[5]-p[4])*f[2]);const m=Sn(g)/e.getCurrentSampleDistance(r);i=yd.substitute(i,"//VTK::MaximumSamplesValue",`${Math.ceil(m)}`).result,i=yd.substitute(i,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lightComplexity}`).result,t.lightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(i=yd.substitute(i,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(i=yd.substitute(i,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&a.getAmbient()>0&&(i=yd.substitute(i,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result));const h=l?s:1;t.gopacity=!1;for(let e=0;!t.gopacity&&e<h;++e)t.gopacity||=a.getUseGradientOpacity(e);t.gopacity&&(i=yd.substitute(i,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(i=yd.substitute(i,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(i=yd.substitute(i,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,i=yd.substitute(i,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),i=yd.substitute(i,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=i,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=yd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lightComplexity&&(o=yd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=yd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=yd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=yd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=yd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{const a=o.getProperty();((n,r)=>{let o=0;n.getProperty().getShade()&&t.renderable.getBlendMode()===zg.COMPOSITE_BLEND&&(o=0,t.numberOfLights=0,r.forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===o&&(o=1)),1===o&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(o=2),o<3&&e.getPositional()&&(o=3)}))),o!==t.lightComplexity&&(t.lightComplexity=o,e.modified())})(o,r.getLights());const i=t.scalarTexture.getComponents(),s=[],l=[];for(let e=0;e<i;e++)s.push(a.getOpacityMode(e)),l.push(a.getForceNearestInterpolation(e));const c=t.currentInput.getSpatialExtent(),u=t.currentInput.getSpacing(),d=new Float64Array(3);In(d,(c[1]-c[0])*u[0],(c[3]-c[2])*u[1],(c[5]-c[4])*u[2]);const p=Sn(d)/e.getCurrentSampleDistance(r),f=!!t.zBufferTexture,g={iComps:a.getIndependentComponents(),colorMixPreset:a.getColorMixPreset(),interpolationType:a.getInterpolationType(),useLabelOutline:e.isLabelmapOutlineRequired(o),numComp:i,maxSamples:p,useGradientOpacity:a.getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),hasZBufferTexture:f,opacityModes:s,forceNearestInterps:l};return(0===n.getProgram()?.getHandle()||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime()||!t.previousState||!ke()(t.previousState,g))&&(t.previousState=g,!0)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange();if(i?.dataComputedScale?.length){const e=[],t=[];for(let n=0;n<4;n++)e[n]=s[0]*i.dataComputedScale[n]+i.dataComputedOffset[n],t[n]=s[1]*i.dataComputedScale[n]+i.dataComputedOffset[n],e[n]=(e[n]-i.offset[n])/i.scale[n],t[n]=(t[n]-i.offset[n])/i.scale[n];a.setUniform4f("ipScalarRangeMin",e[0],e[1],e[2],e[3]),a.setUniform4f("ipScalarRangeMax",t[0],t[1],t[2],t[3])}if(null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Hg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),s.setUniform3f("volumeSpacings",x[0],x[1],x[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*En(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(e.isLabelmapOutlineRequired(o)){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lightComplexity)return;let O=0;const R=[],M=[],E=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],E[0+3*O]=-.5*w[0],E[1+3*O]=-.5*w[1],E[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",E),3===t.lightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(n,r,o)=>{const a=n.getProgram();a.setUniformi("ctexture",t.colorTexture.getTextureUnit()),a.setUniformi("otexture",t.opacityTexture.getTextureUnit()),a.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),a.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const i=t.scalarTexture.getVolumeInfo(),s=o.getProperty(),l=t.scalarTexture.getComponents(),c=e.useIndependentComponents(s);if(c)for(let e=0;e<l;e++)a.setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));for(let e=0;e<l;e++){const t=c?e:0,n=i.scale[e],r=s.getScalarOpacity(t).getRange(),o=n/(r[1]-r[0]),l=(i.offset[e]-r[0])/(r[1]-r[0]);a.setUniformf(`oshift${e}`,l),a.setUniformf(`oscale${e}`,o);const u=s.getRGBTransferFunction(t).getRange(),d=(i.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);a.setUniformf(`cshift${e}`,d),a.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(c)for(let e=0;e<l;++e){const t=i.scale[e];if(s.getUseGradientOpacity(e)){const n=s.getGradientOpacityMinimumOpacity(e),r=s.getGradientOpacityMaximumOpacity(e);a.setUniformf(`gomin${e}`,n),a.setUniformf(`gomax${e}`,r);const o=[s.getGradientOpacityMinimumValue(e),s.getGradientOpacityMaximumValue(e)];a.setUniformf(`goscale${e}`,t*(r-n)/(o[1]-o[0])),a.setUniformf(`goshift${e}`,-o[0]*(r-n)/(o[1]-o[0])+n)}else a.setUniformf(`gomin${e}`,1),a.setUniformf(`gomax${e}`,1),a.setUniformf(`goscale${e}`,0),a.setUniformf(`goshift${e}`,1)}else{const e=i.scale[l-1],t=s.getGradientOpacityMinimumOpacity(0),n=s.getGradientOpacityMaximumOpacity(0);a.setUniformf("gomin0",t),a.setUniformf("gomax0",n);const r=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];a.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),a.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===e.isLabelmapOutlineRequired(o)){const e=o.getProperty().getLabelOutlineOpacity();a.setUniformf("outlineOpacity",e)}t.lightComplexity>0&&(a.setUniformf("vAmbient",s.getAmbient()),a.setUniformf("vDiffuse",s.getDiffuse()),a.setUniformf("vSpecular",s.getSpecular()),a.setUniformf("vSpecularPower",s.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*En(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Fg.NEAREST?(t.scalarTexture.setMinificationFilter(Rd.NEAREST),t.scalarTexture.setMagnificationFilter(Rd.NEAREST)):(t.scalarTexture.setMinificationFilter(Rd.LINEAR),t.scalarTexture.setMagnificationFilter(Rd.LINEAR)),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||jg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):jg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.scalarTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(Rd.LINEAR),t.jitterTexture.setMagnificationFilter(Rd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,Cs.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=e.useIndependentComponents(i),c=l?s:1,u=i.getScalarOpacity(),d=t._openGLRenderWindow.getGraphicsResourceForObject(u);let p=cg(u,l,c);if(d?.oglObject&&d.hash===p)t.opacityTexture=d.oglObject;else{t.opacityTexture=Kd.newInstance(),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const r=1024,o=2*r*c,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<c;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(Rd.LINEAR),t.opacityTexture.setMagnificationFilter(Rd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*c,1,Cs.UNSIGNED_CHAR,e)}u&&(t._openGLRenderWindow.setGraphicsResourceForObject(u,t.opacityTexture,p),u!==t._scalarOpacityFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(u,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalarOpacityFunc,e)),t._scalarOpacityFunc=u)}const f=i.getRGBTransferFunction();p=cg(f,l,c);const g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g?.hash===p)t.colorTexture=g.oglObject;else{t.colorTexture=Kd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,r=new Uint8ClampedArray(2*n*c*3),o=new Float32Array(3*n);for(let e=0;e<c;++e){const t=i.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(Rd.LINEAR),t.colorTexture.setMagnificationFilter(Rd.LINEAR),t.colorTexture.create2DFromRaw(n,2*c,3,Cs.UNSIGNED_CHAR,r),f&&(t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,p),f!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(f,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=f)}e.updateLabelOutlineThicknessTexture(r);const m=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(p=ug(o,a),m?.oglObject?.getHandle()&&m?.hash===p)t.scalarTexture=m.oglObject;else{t.scalarTexture=Kd.newInstance(),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(n[0],n[1],n[2],a,t.renderable.getPreferSizeOverAccuracy()),a&&(t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,p),a!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(a,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=a)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ns.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ns.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",ss.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThickness(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{t.labelOutlineThicknessTexture=Kd.newInstance(),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=1024,o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Rd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(n,o,1,Cs.UNSIGNED_CHAR,i),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.isLabelmapOutlineRequired=e=>{const n=e.getProperty(),r=t.renderable;return n.getUseLabelOutline()||r.getBlendMode()===zg.LABELMAP_EDGE_PROJECTION_BLEND}}const $g={context:null,VBOBuildTime:null,scalarTexture:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$g,n),Zt.extend(e,t,n),Yd(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),t.jitterTexture=Kd.newInstance(),t.jitterTexture.setWrapS(Od.REPEAT),t.jitterTexture.setWrapT(Od.REPEAT),t.framebuffer=ef.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Kg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",qg);const{vtkDebugMacro:Xg}=Kt;function Yg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Xg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const Zg={};const Qg=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zg,n),Zt.extend(e,t,n),Yg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Qg);var Jg="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:em}=ms;function tm(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Kd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function nm(e,t){return tm(e,t,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE)}function rm(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",em.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=nm(t._openGLRenderWindow,t.size),t.seedTexture0=nm(t._openGLRenderWindow,t.size),t.licTexture1=nm(t._openGLRenderWindow,t.size),t.seedTexture1=nm(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?tm(t._openGLRenderWindow,t.size,Kd.Filter.NEAREST,Kd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return tm(e,t,Kd.Filter.LINEAR,Kd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const om={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,om,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),rm(e,t)}var im={newInstance:jt.newInstance(am,"vtkLICPingPongBufferManager"),extend:am};const sm=0,lm=1,cm=2,um=3,dm=1;function pm(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=ef.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=yd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=ef.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=im.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],y=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;y.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:T}=t;y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",0),T.setUniformf("uMaskThreshold",t.maskThreshold),T.setUniform2f("uNoiseBoundsPt1",...m),T.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),T.setUniformi("texLIC",t.bufs.getLICTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,T);const{LICIShaderProgram:b}=t;y.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),y.readyShaderProgram(T),T.setUniformi("uStepNo",0),T.setUniformi("uPassNo",1),n(T,t.bufs),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);y.readyShaderProgram(T),T.setUniformi("uStepNo",1),n(T,t.bufs),r(t.bufs,o,T),y.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),y.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;y.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;y.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)y.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),y.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==lm&&t.enhanceContrast!==um||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const fm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),pm(e,t)}var mm={newInstance:jt.newInstance(gm,"vtkLineIntegralConvolution2D"),extend:gm};function hm(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const vm={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:sm,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:dm,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vm,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),hm(0,t)}var Tm={newInstance:jt.newInstance(ym,"vtkSurfaceLICInterface"),extend:ym};const{Representation:bm}=ms;function xm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Cd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===dm?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Kd.newInstance({wrapS:Kd.Wrap.REPEAT,wrapT:Kd.Wrap.REPEAT,minificationFilter:Kd.Filter.NEAREST,magnificationFilter:Kd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Jg,e,""),e.allocateTextures=()=>{const n=Kd.Filter.NEAREST,r=Kd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Kd.newInstance({wrapS:Kd.Wrap.CLAMP_TO_EDGE,wrapT:Kd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Kd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=ef.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Pd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ns.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ns.newInstance({numberOfComponents:1,values:o}),s=Ns.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",bm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=mm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===cm||u===um){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const Cm={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Sm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cm,n),Tm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),xm(e,t)}var Am={newInstance:jt.newInstance(Sm,"vtkSurfaceLICInterface"),extend:Sm};const{vtkErrorMacro:Im}=Kt;function wm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=yd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=yd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=yd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=yd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=yd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Im("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Im("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Im("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Tm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Am.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Im("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const Pm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Om=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pm,n),pp.extend(e,t,n),wm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",Om);const{vtkErrorMacro:Rm}=Kt;function Mm(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Rm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,Zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Em={};const Dm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Em,n),pp.extend(e,t,n),Mm(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",Dm);const{vtkErrorMacro:Vm}=Kt;function Lm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=qd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=yd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=yd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=yd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=yd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=yd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=yd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=yd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||Vm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||Vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||Vm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(rd.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():Vm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,Zu.ARRAY_BUFFER),a.getColorBO().upload(g,Zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Bm={};const Nm=Dt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bm,n),pp.extend(e,t,n),Lm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Nm);const _m=[];_m["-".charCodeAt(0)]=62,_m["_".charCodeAt(0)]=63;const Fm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<Fm.length;e++)_m[Fm.charCodeAt(e)]=e;function km(e){return void 0!==_m[e.charCodeAt(0)]}function Gm(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<18;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<12;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<6;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<10;!km(e[l]);)l++;for(c|=_m[e.charCodeAt(l++)]<<4;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!km(e[l]);)l++;for(c=_m[e.charCodeAt(l++)]<<2;!km(e[l]);)l++;c|=_m[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Um(e,t,n){const r=(e<<16)+(t<<8)+n;return Fm[r>>18]+Fm[r>>12&63]+Fm[r>>6&63]+Fm[63&r]}function zm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Um(t[n],t[n+1],t[n+2])}if(n>0){const e=Um(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Wm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)km(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Gm(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Hm={};function jm(e,t){Hm[e]=t}var Km=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Hm[e](t)},$m=Uint8Array,qm=Uint16Array,Xm=Uint32Array,Ym=new $m([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Zm=new $m([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Qm=new $m([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Jm=function(e,t){for(var n=new qm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Xm(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},eh=Jm(Ym,2),th=eh[0],nh=eh[1];th[28]=258,nh[258]=28;for(var rh=Jm(Zm,0),oh=rh[0],ah=(rh[1],new qm(32768)),ih=0;ih<32768;++ih){var sh=(43690&ih)>>>1|(21845&ih)<<1;sh=(61680&(sh=(52428&sh)>>>2|(13107&sh)<<2))>>>4|(3855&sh)<<4,ah[ih]=((65280&sh)>>>8|(255&sh)<<8)>>>1}var lh=function(e,t,n){for(var r=e.length,o=0,a=new qm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new qm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new qm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[ah[d]>>>l]=c}else for(i=new qm(r),o=0;o<r;++o)e[o]&&(i[o]=ah[s[e[o]-1]++]>>>15-e[o]);return i},ch=new $m(288);for(ih=0;ih<144;++ih)ch[ih]=8;for(ih=144;ih<256;++ih)ch[ih]=9;for(ih=256;ih<280;++ih)ch[ih]=7;for(ih=280;ih<288;++ih)ch[ih]=8;var uh=new $m(32);for(ih=0;ih<32;++ih)uh[ih]=5;var dh=lh(ch,9,1),ph=lh(uh,5,1),fh=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},gh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},mh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},hh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?qm:4==e.BYTES_PER_ELEMENT?Xm:$m)(n-t);return r.set(e.subarray(t,n)),r},vh=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],yh=function(e,t,n){var r=new Error(t||vh[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,yh),!n)throw r;return r},Th=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new $m(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new $m(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new $m(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=gh(e,c,1);var h=gh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&yh(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=dh,p=ph,f=9,g=5;else if(2==h){var T=gh(e,c,31)+257,b=gh(e,c+10,15)+4,x=T+gh(e,c+5,31)+1;c+=14;for(var C=new $m(x),S=new $m(19),A=0;A<b;++A)S[Qm[A]]=gh(e,c+3*A,7);c+=3*b;var I=fh(S),w=(1<<I)-1,P=lh(S,I,1);for(A=0;A<x;){var O,R=P[gh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,E=0;for(16==O?(E=3+gh(e,c,3),c+=2,M=C[A-1]):17==O?(E=3+gh(e,c,7),c+=3):18==O&&(E=11+gh(e,c,127),c+=7);E--;)C[A++]=M}}var D=C.subarray(0,T),V=C.subarray(T);f=fh(D),g=fh(V),d=lh(D,f,1),p=lh(V,g,1)}else yh(1);if(c>m){a&&yh(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[mh(e,c)&L])>>>4;if((c+=15&M)>m){a&&yh(0);break}if(M||yh(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Ym[A=_-257];F=gh(e,c,(1<<k)-1)+th[A],c+=k}var G=p[mh(e,c)&B],U=G>>>4;if(G||yh(3),c+=15&G,V=oh[U],U>3&&(k=Zm[U],V+=mh(e,c)&(1<<k)-1,c+=k),c>m){a&&yh(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:hh(t,0,u)},bh=new $m(0),xh=function(e,t){return e[t]|e[t+1]<<8},Ch=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Sh=function(e,t){return Ch(e,t)+4294967296*Ch(e,t+4)};function Ah(e,t){return Th(e,t)}function Ih(e,t){return Th(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||yh(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new $m((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function wh(e,t){return Th(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&yh(6,"invalid zlib data"),32&n[1]&&yh(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Ph(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Ih(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Ah(e,t):wh(e,t)}var Oh="undefined"!=typeof TextEncoder&&new TextEncoder,Rh="undefined"!=typeof TextDecoder&&new TextDecoder;try{Rh.decode(bh,{stream:!0})}catch(e){}function Mh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Rh)return Rh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,hh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&yh(8),a}var Eh=function(e,t){return t+30+xh(e,t+26)+xh(e,t+28)},Dh=function(e,t,n){var r=xh(e,t+28),o=Mh(e.subarray(t+46,t+46+r),!(2048&xh(e,t+8))),a=t+46+r,i=Ch(e,t+20),s=n&&4294967295==i?Vh(e,a):[i,Ch(e,t+24),Ch(e,t+42)],l=s[0],c=s[1],u=s[2];return[xh(e,t+10),l,c,o,a+xh(e,t+30)+xh(e,t+32),u]},Vh=function(e,t){for(;1!=xh(e,t);t+=4+xh(e,t+2));return[Sh(e,t+12),Sh(e,t+4),Sh(e,t+20)]};function Lh(e,t){for(var n={},r=e.length-22;101010256!=Ch(e,r);--r)(!r||e.length-r>65558)&&yh(13);var o=xh(e,r+8);if(!o)return{};var a=Ch(e,r+16),i=4294967295==a;i&&(r=Ch(e,r-12),101075792!=Ch(e,r)&&yh(13),o=Ch(e,r+32),a=Ch(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Dh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Eh(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Ah(e.subarray(h,h+d),new $m(p)):yh(14,"unknown compression type "+u):n[f]=hh(e,h,h+d))}return n}function Bh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Nh=Bh(),_h=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:Fh,vtkDebugMacro:kh}=jt;let Gh=0;function Uh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const zh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Uh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(kh(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Fh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Mh(Ph(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Uh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Gh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Gh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Mh(Ph(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(Fh("Supported algorithms are: [gz]"),Fh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Uh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Ph(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};jm("http",(e=>zh));const{vtkDebugMacro:Wh}=jt;function Hh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Wh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Wh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Hi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Hi(o,[...t.position,1],n),Hi(a,[...t.focalPoint,1],n),Hi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Wh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=qi(e[0],e[1],e[2],e[3]),n=ji(),r=qi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],$i(r,t,r),$i(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=ji();Ki(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const jh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Kh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Hh(e,t)}var $h={newInstance:jt.newInstance(Kh,"vtkCamera"),extend:Kh};function qh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const Xh={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xh,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),qh(e,t)}var Zh={newInstance:jt.newInstance(Yh,"vtkLight"),extend:Yh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Qh}=jt;function Jh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Qh("call displayToView on your view instead"),e.viewToDisplay=()=>Qh("callviewtodisplay on your view instead"),e.getSize=()=>Qh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Qh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const ev={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function tv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ev,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Jh(e,t)}var nv={newInstance:jt.newInstance(tv,"vtkViewport"),extend:tv};const{vtkDebugMacro:rv,vtkErrorMacro:ov,vtkWarningMacro:av}=Kt;function iv(e){return()=>ov(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function sv(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(rv("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):ov("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=iv("allocateTime"),e.updateGeometry=iv("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{rv(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=$h.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Zh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ov("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ov("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ov("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Wi.INIT_BOUNDS[0],t.allBounds[1]=Wi.INIT_BOUNDS[1],t.allBounds[2]=Wi.INIT_BOUNDS[2],t.allBounds[3]=Wi.INIT_BOUNDS[3],t.allBounds[4]=Wi.INIT_BOUNDS[4],t.allBounds[5]=Wi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),rv("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return rv("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return ov("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&(av("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return rv("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ov("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const lv={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lv,n),nv.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),sv(e,t)}var uv={newInstance:Dt(cv,"vtkRenderer"),extend:cv};const dv=Object.create(null);function pv(e,t){dv[e]=t}function fv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dv[e]&&dv[e](t)}function gv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}const mv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers","childRenderWindows"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),gv(e,t)}var vv={newInstance:jt.newInstance(hv,"vtkRenderWindow"),extend:hv,registerViewConstructor:pv,listViewAPIs:function(){return Object.keys(dv)},newAPISpecificView:fv};const yv={Unknown:0,LeftController:1,RightController:2},Tv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var bv={Device:yv,Input:Tv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:xv,Input:Cv}=bv,{vtkWarningMacro:Sv,vtkErrorMacro:Av,normalizeWheel:Iv,vtkOnceErrorMacro:wv}=jt,Pv={ctrlKey:!1,altKey:!1,shiftKey:!1},Ov={"xr-standard":[Cv.Trigger,Cv.Grip,Cv.TrackPad,Cv.Thumbstick,Cv.A,Cv.B]},Rv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Mv(e){e.cancelable&&e.preventDefault()}function Ev(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function Dv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Av("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Sv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Mv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Mv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Mv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Sv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Mv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Av(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Sv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Av("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Sv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?xv.LeftController:xv.RightController,input:Ov[s.mapping]&&Ov[s.mapping][r]?Ov[s.mapping][r]:Cv.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?xv.LeftController:xv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Mv(n);const r={...Iv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Av(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);if(2===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Pv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Ev(o);e.recognizeGesture("TouchEnd",t);const a={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Ev(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Pv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Rv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void wv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const Vv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),Rv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),Dv(e,t)}var Bv={newInstance:jt.newInstance(Lv,"vtkRenderWindowInteractor"),extend:Lv,handledEvents:Rv,...bv};const{vtkErrorMacro:Nv,VOID:_v}=jt;function Fv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Bv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):_v),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Nv("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const kv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorObserver"),extend:Gv,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},zv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Wv}=zv,Hv={Rotate:Wv.IS_ROTATE,Pan:Wv.IS_PAN,Spin:Wv.IS_SPIN,Dolly:Wv.IS_DOLLY,CameraPose:Wv.IS_CAMERA_POSE,WindowLevel:Wv.IS_WINDOW_LEVEL,Slice:Wv.IS_SLICE};function jv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Hv).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Wv.IS_NONE&&(t.state=Hv[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Hv[n]&&(t.state=Wv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Kv={state:Wv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Uv.extend(e,t,n),jt.setGet(e,t,["focusedRenderer"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkInteractorStyle"),extend:$v,...zv};const{States:Xv}=zv;function Yv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case Xv.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case Xv.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad?!n||n.pressed||n.device!==yv.RightController||n.input!==Tv.Trigger&&n.input!==Tv.TrackPad||t.state!==Xv.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===Xv.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case Xv.IS_DOLLY:e.endDolly();break;case Xv.IS_PAN:e.endPan();break;case Xv.IS_SPIN:e.endSpin();break;case Xv.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const Zv={motionFactor:10,zoomFactor:10};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),qv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Yv(e,t)}var Jv={newInstance:jt.newInstance(Qv,"vtkInteractorStyleTrackballCamera"),extend:Qv};function ey(e){return e}function ty(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>ty(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var ny=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?ty:ey,o=new URLSearchParams(t);return o.forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};function ry(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const oy={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),ry(e,t)}var iy={newInstance:jt.newInstance(ay,"vtkRenderPass"),extend:ay};const{Representation:sy}=ms,{vtkErrorMacro:ly}=jt;function cy(e){const t=yd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function uy(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ns.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ns.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ns.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",sy.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=ef.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Kd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Kd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Kd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||ly("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||ly("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Cd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?cy:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const dy={framebuffer:null,copyShader:null,tris:null};function py(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dy,n),iy.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=Pd.newInstance(),jt.get(e,t,["framebuffer"]),uy(e,t)}var fy={newInstance:jt.newInstance(py,"vtkOpenGLOrderIndependentTranslucentPass"),extend:py};function gy(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=ef.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=fy.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const my={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),iy.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkForwardPass"),extend:hy},yy=n(594),Ty=n.n(yy);const by=["lastShaderProgramBound","context","_openGLRenderWindow"];function xy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=yd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=yd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=yd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=yd.substitute(l,"varying","out").result,o=yd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=yd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=yd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:yd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Ty().hash(o);if(!(a in t.shaderPrograms)){const o=yd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const Cy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,by),jt.moveToProtected(e,t,["openGLRenderWindow"]),xy(e,t)}var Ay={newInstance:jt.newInstance(Sy,"vtkShaderCache"),extend:Sy};const{vtkErrorMacro:Iy}=jt;function wy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&Iy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const Py={context:null,numberOfTextureUnits:0,textureUnits:0};function Oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),wy(e,t)}var Ry={newInstance:jt.newInstance(Oy,"vtkOpenGLTextureUnitManager"),extend:Oy};function My(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ey={size:void 0,selector:void 0};function Dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),My(e,t)}var Vy={newInstance:jt.newInstance(Dy,"vtkRenderWindowViewNode"),extend:Dy};const{vtkDebugMacro:Ly,vtkErrorMacro:By}=jt,Ny={position:"absolute",top:0,left:0,width:"100%",height:"100%"},_y=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Fy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ky=0;const Gy=[];function Uy(e){e.preventDefault()}function zy(e,t){let n;function r(){return n||(n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n}t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Uy,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const o=[0,0];let a;e.onModified((function(){t.renderable&&(t.size[0]===o[0]&&t.size[1]===o[1]||(o[0]=t.size[0],o[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ky++,Gy.forEach((e=>e(ky)))),t.textureUnitManager=Ry.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&By("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},n=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(n=t.canvas.getContext("webgl2",e),n&&(t.webgl2=!0,Ly("using webgl2"))),n||(Ly("using webgl1"),n=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(n,r())},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=iy.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?By("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case Cs.CHAR:case Cs.SIGNED_CHAR:case Cs.UNSIGNED_CHAR:return 1;case n:case r:case Cs.UNSIGNED_SHORT:case Cs.SHORT:case Cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case Cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&Cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&Cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ny,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=a)return a;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return a=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Fy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Fy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Fy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Fy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Fy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Fy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Fy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Fy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Fy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Fy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Fy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=xf.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((()=>{t.context&&(ky--,Gy.forEach((e=>e(ky)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Uy),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const i=e.setSize;e.setSize=(t,n)=>{const r=i(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null),t._graphicsResources.get(n)?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))};const s={...e};_y.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):s[n](...arguments)}}))}const Wy={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Hy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),Vy.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=xf.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.shaderCache=Ay.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=vy.newInstance(),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),jt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"imageReady"),jt.event(e,t,"windowResizeEvent"),zy(e,t)}),"vtkOpenGLRenderWindow");function jy(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}pv("WebGL",Hy),rn("vtkRenderWindow",Hy);const Ky={device:null,handle:null};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),jy(e,t)}var qy={newInstance:jt.newInstance($y,"vtkWebGPUShaderModule"),extend:$y};function Xy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=qy.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const Yy={shaderModules:null,device:null,window:null};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Xy(e,t)}var Qy={newInstance:jt.newInstance(Zy,"vtkWebGPUShaderCache"),extend:Zy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function Jy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const eT={device:null,handle:null,label:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),Jy(e,t)}var nT={newInstance:jt.newInstance(tT),extend:tT};function rT(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const oT={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function aT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oT,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),rT(e,t)}var iT={newInstance:Dt(aT,"vtkWebGPUPipeline"),extend:aT};function sT(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Qy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Qy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Qy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const lT={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),sT(e,t)}var uT={newInstance:jt.newInstance(cT,"vtkWebGPUShaderDescription"),extend:cT};const dT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var pT=function(e){return!e||e.length<6?0:e in dT==1?dT[e]:(et(`unknown format ${e}`),null)},fT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},gT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},mT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},hT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},vT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function yT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function TT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(yT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=mT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const bT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function xT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),TT(e,t)}var CT={newInstance:Dt(xT,"vtkWebGPUVertexInput"),extend:xT};const ST="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",AT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function IT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=uT.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=uT.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Qy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Qy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=iT.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const wT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=CT.newInstance(),t.bindGroup=nT.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||AT,t.vertexShaderTemplate=t.vertexShaderTemplate||ST,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),IT(e,t)}var OT={newInstance:jt.newInstance(PT,"vtkWebGPUSimpleMapper"),extend:PT};function RT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const MT={};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),OT.extend(e,t,n),RT(e,t)}var DT={newInstance:jt.newInstance(ET,"vtkWebGPUFullScreenQuad"),extend:ET};const VT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function LT(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<VT.length;n++)e[VT[n]]=function(){return t.handle[VT[n]](...arguments)}}const BT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),LT(e,t)}var _T={newInstance:Dt(NT,"vtkWebGPURenderEncoder"),extend:NT},FT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const kT=["getMappedRange","mapAsync","unmap"];function GT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<kT.length;n++)e[kT[n]]=function(){return t.handle[kT[n]](...arguments)}}const UT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function zT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,UT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),GT(e,t)}var WT={newInstance:jt.newInstance(zT),extend:zT,...FT};const{Representation:HT}=ms,{PrimitiveTypes:jT}=FT;class KT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function $T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function qT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=$T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=$T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=$T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=$T(n,o,t),n.ibo[n.iboId++]=a}function XT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let YT;const ZT=new Uint32Array(1),QT=new Uint32Array(2),JT=new Uint32Array(3),eb={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)ZT[0]=t[n+a],YT(ZT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)QT[0]=t[n+a],QT[1]=t[n+(a+1)%e],YT(QT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)QT[0]=t[n+a],QT[1]=t[n+a+1],YT(QT,r,o);for(let a=0;a<e-2;a++)QT[0]=t[n+a],QT[1]=t[n+a+2],YT(QT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n],JT[1]=t[n+a+1],JT[2]=t[n+a+2],YT(JT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)JT[0]=t[n+a],JT[1]=t[n+a+1+a%2],JT[2]=t[n+a+1+(a+1)%2],YT(JT,r,o)}};function tb(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case jT.Points:return"points";case jT.Lines:return"lines";case jT.Triangles:case jT.TriangleEdges:return"polys";case jT.TriangleStripEdges:case jT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new KT};let d=null;d=o===HT.POINTS||r===jT.Points?eb.anythingToPoints:o===HT.WIREFRAME||r===jT.Lines?eb[`${l}ToWireframe`]:eb[`${l}ToSurface`],YT=XT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),YT=qT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const nb={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nb,n),WT.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),tb(e,t)}var ob={newInstance:jt.newInstance(rb),extend:rb,...FT};const{BufferUsage:ab}=FT,{vtkErrorMacro:ib}=Kt,{VtkDataTypes:sb}=Ns;function lb(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function cb(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function ub(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===ab.Index&&(n=ob.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=WT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===ab.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===ab.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===ab.PointArray){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=lb(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===ab.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=gT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=cb(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=lb(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===ab.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(fT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case sb.UNSIGNED_CHAR:t="uint8";break;case sb.FLOAT:t="float32";break;case sb.UNSIGNED_INT:t="uint32";break;case sb.INT:t="sint32";break;case sb.DOUBLE:t="float32";break;case sb.UNSIGNED_SHORT:t="uint16";break;case sb.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ib(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:ab.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=WT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const db={device:null,fullScreenQuadBuffer:null};function pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,db,n),yt(e,t),At(e,t,["device"]),ub(e,t)}var fb={newInstance:Dt(pb),extend:pb,...FT};function gb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const mb={device:null,handle:null,label:null,options:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),gb(e,t)}var vb={newInstance:jt.newInstance(hb),extend:hb};function yb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=pT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vb.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const Tb={texture:null,handle:null,sampler:null,label:null};function bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),yb(e,t)}var xb={newInstance:jt.newInstance(bb),extend:bb};const{BufferUsage:Cb}=fb;function Sb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=pT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Vd.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Pu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:Cb.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:Cb.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=pT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>pT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=xb.newInstance({label:n});return o.create(e,r),o}}const Ab={device:null,handle:null,buffer:null,ready:!1,label:null};function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ab,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),Sb(e,t)}var wb={newInstance:jt.newInstance(Ib),extend:Ib};function Pb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=wb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=_T.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const Ob={renderEncoder:null,colorTexture:null,depthTexture:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Pb(e,t)}var Mb={newInstance:jt.newInstance(Rb,"vtkWebGPUOpaquePass"),extend:Rb};function Eb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=wb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=wb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=DT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=_T.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=_T.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const Db={colorTextureView:null,depthTextureView:null};function Vb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Db,n),iy.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),Eb(e,t)}var Lb={newInstance:jt.newInstance(Vb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Vb};const{BufferUsage:Bb}=fb,{vtkErrorMacro:Nb}=jt;function _b(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Nb(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:hT(n),offset:-1,nativeType:vT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Bb.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Nb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Fb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),_b(e,t)}var Gb={newInstance:jt.newInstance(kb,"vtkWebGPUUniformBuffer"),extend:kb};const{BufferUsage:Ub}=fb,{vtkErrorMacro:zb}=jt;function Wb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void zb(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=hT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:vT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Ub.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void zb(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void zb(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Hb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Wb(e,t)}var Kb={newInstance:jt.newInstance(jb,"vtkWebGPUStorageBuffer"),extend:jb};const $b="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",qb=new Float64Array(16),Xb=new Float64Array(16);function Yb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Qy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===zg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Qy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Qy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Qy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===zg.COMPOSITE_BLEND?l=!0:n===zg.MAXIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.MINIMUM_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.AVERAGE_INTENSITY_BLEND?a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===zg.ADDITIVE_INTENSITY_BLEND&&(a=Qy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Qy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(qb),b(qb,qb,o);const p=n.getMatrix();m(Xb,p),h(Xb,Xb),T(qb,Xb,qb);const f=d.getWorldToIndex();T(qb,f,qb);const v=d.getDimensions();g(Xb),x(Xb,Xb,[1/v[0],1/v[1],1/v[2]]),T(qb,Xb,qb);for(let t=0;t<16;t++)a[16*e+t]=qb[t];h(qb,qb);for(let t=0;t<4;t++)i[16*e+4*t]=qb[4*t],i[16*e+4*t+1]=qb[4*t+1],i[16*e+4*t+2]=qb[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=pT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vb.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Zb={volumes:null,rowLength:1024,lastVolumeLength:0};function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zb,n),DT.extend(e,t,n),t.fragmentShaderTemplate=$b,t.UBO=Gb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Kb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Kb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),Yb(e,t)}var Jb={newInstance:jt.newInstance(Qb,"vtkWebGPUVolumePassFSQ"),extend:Qb};const{Representation:ex}=ms,{BufferUsage:tx,PrimitiveTypes:nx}=fb,rx=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],ox="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function ax(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=Jb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=DT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Gb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:tx.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:nx.Triangles,representation:ex.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:tx.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+rx[e][0],l[n++]=r+rx[e][1],l[n++]=r+rx[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=_T.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=wb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=wb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=wb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=_T.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=_T.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=_T.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const ix={colorTextureView:null,depthTextureView:null,volumes:null};function sx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ix,n),iy.extend(e,t,n),t._mapper=OT.newInstance(),t._mapper.setFragmentShaderTemplate(ox),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Cu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),ax(e,t)}var lx={newInstance:jt.newInstance(sx,"vtkWebGPUVolumePass"),extend:sx};function cx(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Mb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Lb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=lx.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=_T.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vb.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=DT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=xb.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const ux={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ux,n),iy.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),cx(e,t)}var px={newInstance:jt.newInstance(dx,"vtkForwardPass"),extend:dx};const{VtkDataTypes:fx}=Ns;function gx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case fx.UNSIGNED_CHAR:e.format+="8unorm";break;case fx.FLOAT:case fx.UNSIGNED_INT:case fx.INT:case fx.DOUBLE:case fx.UNSIGNED_SHORT:case fx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=wb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const mx={handle:null,device:null};function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mx,n),jt.obj(e,t),jt.setGet(e,t,["device"]),gx(e,t)}var vx={newInstance:jt.newInstance(hx),extend:hx};class yx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function Tx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const bx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new yx,t.shaderCache=Qy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=fb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=vx.newInstance(),t.textureManager.setDevice(e),t.pipelines={},Tx(e,t)}var Cx={newInstance:Dt(xx,"vtkWebGPUDevice"),extend:xx};function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=wb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=wb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=_T.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Qy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const Ax={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),iy.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelectionPass"),extend:Ix};const{SelectionContent:Px,SelectionField:Ox}=of,{FieldAssociations:Rx}=ll,{vtkErrorMacro:Mx}=jt;function Ex(e){return`${e.propID} ${e.compositeID}`}function Dx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Vx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Dx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Dx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Vx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Vx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Vx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Vx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Vx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Lx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Mx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=WT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=WT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Vx(e,[n,t],0,u);if(r){const t=Ex(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=of.newInstance();switch(i.setContentType(Px.INDICES),e){case Rx.FIELD_ASSOCIATION_CELLS:i.setFieldType(Ox.CELL);break;case Rx.FIELD_ASSOCIATION_POINTS:i.setFieldType(Ox.POINT);break;default:Mx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Bx={};function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),Yp.extend(e,t,n),t._selectionPass=wx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Lx(e,t)}var _x={newInstance:jt.newInstance(Nx,"vtkWebGPUHardwareSelector"),extend:Nx};const Fx=Object.create(null);function kx(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Gx={};function Ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gx,n),t.overrides=Fx,tn.extend(e,t,n),kx(0,t)}var zx={newInstance:jt.newInstance(Ux,"vtkWebGPUViewNodeFactory"),extend:Ux};const{vtkErrorMacro:Wx}=jt,Hx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function jx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Wx("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Wx("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=Cx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=iy.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Hx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=WT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Vd.fromHalf(r.colorValues[o]),s[n+1]=255*Vd.fromHalf(r.colorValues[o+1]),s[n+2]=255*Vd.fromHalf(r.colorValues[o+2]),s[n+3]=255*Vd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=_x.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Kx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const $x=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Vy.extend(e,t,n),t.myFactory=zx.newInstance(),t.renderPasses[0]=px.newInstance(),t.selector||(t.selector=_x.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),jx(e,t)}),"vtkWebGPURenderWindow");var qx;pv("WebGPU",$x),qx=$x,Fx.vtkRenderWindow=qx;const Xx=ny(),Yx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Zx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Qx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Jx(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Qx(t.container,t.containerStyle||Yx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=vv.newInstance(),t.renderer=uv.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Xx.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Bv.newInstance(),t.interactor.setInteractorStyle(Jv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Qx(t.controlContainer,t.controlPanelStyle||Zx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const eC={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function tC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eC,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Jx(e,t)}var nC={newInstance:jt.newInstance(tC),extend:tC},rC={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:oC,Scale:aC}=rC,{ScalarMappingTarget:iC}=El,{vtkDebugMacro:sC,vtkErrorMacro:lC,vtkWarningMacro:cC}=jt;function uC(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function dC(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function pC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];uC(o,i),uC(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=dC(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=dC(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function fC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return lC("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return lC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===aC.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Eo(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===oC.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===oC.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===oC.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===oC.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===oC.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===oC.DIVERGING?(pC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):lC("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return lC("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(lC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return lC("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void lC("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):sC("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void cC("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===iC.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===iC.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===iC.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===iC.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=oC[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(lC(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=oC.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const gC={clamping:!0,colorSpace:oC.RGB,hSVWrap:!0,scale:aC.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function mC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gC,n),El.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:oC},{type:"enum",name:"scale",enum:aC}]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),fC(e,t)}var hC={newInstance:jt.newInstance(mC,"vtkColorTransferFunction"),extend:mC,...rC},vC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:yC,ScaleModes:TC}=vC,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(yC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(yC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(yC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(yC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(TC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(TC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(TC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(TC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===TC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(bC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Wi.getCorners(l,c),t.bounds[0]=Wi.INIT_BOUNDS[0],t.bounds[1]=Wi.INIT_BOUNDS[1],t.bounds[2]=Wi.INIT_BOUNDS[2],t.bounds[3]=Wi.INIT_BOUNDS[3],t.bounds[4]=Wi.INIT_BOUNDS[4],t.bounds[5]=Wi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case yC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case yC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case yC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case TC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case TC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case TC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const CC={orient:!0,orientationMode:yC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:TC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,CC,n),uc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkGlyph3DMapper"),extend:SC,...vC};const{vtkErrorMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(IC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return IC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return IC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return IC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const PC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkPiecewiseFunction"),extend:OC};const{InterpolationType:MC,OpacityMode:EC}=Ug,{vtkErrorMacro:DC}=jt;function VC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(DC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=RC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=hC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=RC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return DC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(DC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(MC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(MC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(MC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(MC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const LC={colorMixPreset:null,independentComponents:!0,interpolationType:MC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,LC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:EC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}jt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeProperty"),extend:BC,...Ug};const{vtkDebugMacro:_C}=jt;function FC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=NC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){_C("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];Wi.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const kC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function GC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kC,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),FC(e,t)}var UC={newInstance:jt.newInstance(GC,"vtkVolume"),extend:GC};const{BlendMode:zC,FilterMode:WC}=Wg,HC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=RC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function jC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(zC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(zC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(zC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(zC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(zC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(zC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(zC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(WC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(WC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(WC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(WC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Eo(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const KC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:zC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:WC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function $C(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KC,n),zs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),jC(e,t)}var qC={newInstance:jt.newInstance($C,"vtkVolumeMapper"),extend:$C,...HC};const{InterpolationType:XC}=pg,{vtkErrorMacro:YC}=jt;function ZC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return YC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(YC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(XC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(XC.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(XC,t.interpolationType)}const QC={independentComponents:!1,interpolationType:XC.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function JC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,QC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),ZC(e,t)}var eS={newInstance:jt.newInstance(JC,"vtkImageProperty"),extend:JC};const{vtkDebugMacro:tS}=jt;function nS(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=eS.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){tS("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Wi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Wi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Wi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const rS={mapper:null,property:null,forceOpaque:!1,forceTranslucent:!1,bounds:[...Wi.INIT_BOUNDS]};function oS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rS,n),as.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),jt.getArray(e,t,["bounds"],6),nS(e,t)}var aS={newInstance:jt.newInstance(oS,"vtkImageSlice"),extend:oS};function iS(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const sS={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var lS=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sS,n),zs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),iS(e,t)};function cS(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ii.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:uS,otherStaticMethods:dS}=Kl,{SlicingMode:pS}=yg;function fS(e,t){function n(){let n;switch(t.slicingMode){case pS.X:n=0;break;case pS.Y:n=1;break;case pS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case pS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case pS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case pS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case pS.I:l=Ma(a[0],i[0],i[1]);break;case pS.J:l=Ma(a[1],i[2],i[3]);break;case pS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case pS.I:case pS.J:case pS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case pS.X:e.setSlice(r[0]);break;case pS.Y:e.setSlice(r[1]);break;case pS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(pS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(pS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(pS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(pS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(pS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(pS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case pS.X:n[0]=1;break;case pS.Y:n[1]=1;break;case pS.Z:n[2]=1;break;case pS.I:ea(r,[1,0,0],n);break;case pS.J:ea(r,[0,1,0],n);break;case pS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==pS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case pS.I:r[0]=a,r[1]=a;break;case pS.J:r[2]=a,r[3]=a;break;case pS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case pS.I:a[0]=s-r,a[1]=s+r;break;case pS.J:a[2]=s-r,a[3]=s+r;break;case pS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=cS(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const gS={slicingMode:pS.NONE,closestIJKAxis:{ijkMode:pS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function mS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gS,n),lS(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Kl.implementCoincidentTopologyMethods(e,t),fS(e,t)}var hS={newInstance:jt.newInstance(mS,"vtkImageMapper"),extend:mS,...uS,...dS,...yg};const{vtkErrorMacro:vS}=jt;function yS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function TS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void vS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Cu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Xs.SINGLE?s=Cs.FLOAT:t.outputPointsPrecision===Xs.DOUBLE&&(s=Cs.DOUBLE);const v=Sc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ns.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ns.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ns.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),yS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),yS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),yS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),yS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const bS={outputPointsPrecision:Xs.DEFAULT};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkAppendPolyData"),extend:xS};function SS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Kf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Cu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const AS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function IS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),SS(e,t)}var wS={newInstance:jt.newInstance(IS,"vtkConeSource"),extend:IS};function PS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ns.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ns.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Kf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Cu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const OS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function RS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),PS(e,t)}var MS={newInstance:jt.newInstance(RS,"vtkCylinderSource"),extend:RS};function ES(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=MS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();jf().rotateZ(-90).apply(a).apply(i);const s=wS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Kf().translate(1-.5*t.tipLength,0,0).apply(c);const u=CS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Kf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Kf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Kf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const DS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function VS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),ES(e,t)}var LS={newInstance:jt.newInstance(VS,"vtkArrowSource"),extend:VS};function BS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];jf().translate(...n).apply(e.getPoints().getData())}function NS(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],jf().translate(...o).apply(e.getPoints().getData())}function _S(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ns.newInstance({name:"color",numberOfComponents:3,values:a}))}function FS(e,t){t.classHierarchy.push("vtkAxesActor");const n=uc.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=LS.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?BS(r):NS(r,0,e.invert),_S(r,...e.color),e={...t.config,...t.yConfig};const o=LS.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?BS(o):NS(o,1,e.invert),_S(o,...e.color),e={...t.config,...t.zConfig};const a=LS.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?BS(a):NS(a,2,e.invert),_S(a,...e.color);const i=CS.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=jt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}function kS(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}function GS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};bs.extend(e,t,kS(n)),jt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),FS(e,t)}var US={newInstance:jt.newInstance(GS,"vtkAxesActor"),extend:GS};const zS="resetcamera",WS="orientation",HS={MODE_RESET_CAMERA:zS,MODE_ORIENTATION:WS,MODE_SAME:"same"};function jS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===WS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===zS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const KS={mode:WS,focalPoint:[0,0,0],distance:6.8,active:!0};function $S(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),jS(e,t)}var qS={newInstance:Dt($S,"vtkCameraSynchronizer"),extend:$S,SynchronizationMode:HS};const XS={},YS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=qS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:qS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ZS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;XS[r]||(XS[r]={});const o=XS[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=qS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];YS[e.type]?o[r]=new YS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const QS={},JS=/instance:\${([^}]+)}/,eA={},tA=[],nA={},rA={vtkPoints:Sc,vtkCellArray:vc,vtkDataArray:Ns};function oA(e){return e.map((e=>JS.exec(e))).filter((e=>e)).map((e=>e[1]))}function aA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),aA(e,t)})),t}function iA(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=QS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function sA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=QS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function lA(){Object.keys(QS).forEach((e=>{delete QS[e]}))}function cA(){Object.keys(eA).forEach((e=>{delete eA[e]}))}function uA(e){if(1===e[1].length)return-1===tA.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===tA.indexOf(e[1][n]);return t}function dA(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(nA[r]){const{key:n,value:o}=nA[r];if(!n||e.properties[n]===o)return void tA.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=sA(r,{managedInstanceId:t}),n.registerInstance(t,o)),iA(r,o,e,n)})),t.calls&&t.calls.filter(uA).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=JS.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=rA[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function pA(e,t,n){eA[t.id]||dA(e,t,n),eA[t.id]=!0}function fA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function gA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function mA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=gA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=gA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),fA(t.getPointData(),i.pointData),fA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=dA(t,s,r);return r.end(),l}}const hA=mA(["points","polys","verts","lines","strips"]),vA=mA([]);function yA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dA;sA||iA?QS[e]={build:t,update:n}:delete QS[e]}const TA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},bA={vtkAxesActor:{build:US.newInstance,update:dA},vtkRenderWindow:{build:vv.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(uA).filter((e=>"removeRenderer"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),dA(e,t,n),ZS(e,t,n)}},vtkRenderer:{build:uv.newInstance,update:function(e,t,n){dA(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=aA(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(uA).filter((e=>"removeViewProp"===e[0])).forEach((e=>{oA(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:Nl.newInstance,update:dA},vtkCamera:{build:$h.newInstance,update:pA},vtkPolyData:{build:Cu.newInstance,update:hA},vtkImageData:{build:vl.newInstance,update:vA},vtkMapper:{build:uc.newInstance,update:dA},vtkGlyph3DMapper:{build:AC.newInstance,update:dA},vtkProperty:{build:ms.newInstance,update:dA},vtkActor:{build:bs.newInstance,update:dA},vtkLight:{build:Zh.newInstance,update:dA},vtkColorTransferFunction:{build:hC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Pu.newInstance,update:dA},vtkVolume:{build:UC.newInstance,update:dA},vtkVolumeMapper:{build:qC.newInstance,update:dA},vtkVolumeProperty:{build:NC.newInstance,update:dA},vtkImageSlice:{build:aS.newInstance,update:dA},vtkImageMapper:{build:hS.newInstance,update:dA},vtkImageProperty:{build:eS.newInstance,update:dA},vtkPiecewiseFunction:{build:RC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:$u.newInstance,update:dA},vtkScalarBarActor:{build:Fp.newInstance,update:dA}};function xA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&lA(),Object.keys(bA).forEach((e=>{const t=bA[e];yA(e,t.build,t.update)}))}function CA(){Object.keys(TA).forEach((e=>{TA[e].forEach((t=>{QS[t]=QS[e]}))}))}xA(),CA(),nA.vtkPVLight={};var SA={build:sA,update:iA,genericUpdater:dA,oneTimeGenericUpdater:pA,setTypeMapping:yA,clearTypeMapping:lA,getSupportedTypes:function(){return Object.keys(QS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return cA();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete eA[e]})),r},updateRenderWindow:function(e,t,n){return iA("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){nA[e]={key:t,value:n}},setDefaultMapping:xA,applyDefaultAliases:CA,alwaysUpdateCamera:function(){yA("vtkCamera",$h.newInstance),CA()}};const AA={};function IA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Wm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function wA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function PA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Et(t,n,"progressEvent"),Et(t,n,"progressDone"),t}function OA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function RA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=AA[e];return t||(t={...IA(),...wA(),...PA(),...OA()},AA[e]=t),t}function MA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),SA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){SA.clearOneTimeUpdaters(a())}}}function EA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=RA(t.synchronizerContextName));const n=MA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const DA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function VA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,DA,n),vv.extend(e,t),bt(e,t,["synchronizerContext"]),EA(e,t)}var LA={newInstance:Dt(VA,"vtkSynchronizableRenderWindow"),extend:VA,getSynchronizerContext:RA,setSynchronizerContext:function(e,t){AA[e]=t},clearSynchronizerContext:function(e){if(e&&AA[e]&&delete AA[e],!e){const e=Object.keys(AA);for(let t=0;t<e.length;t++)delete AA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=MA(e,RA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:wA,createArrayHandler:IA,createProgressHandler:PA,createSceneMtimeHandler:OA,vtkObjectManager:SA};const{vtkErrorMacro:BA,vtkDebugMacro:NA}=jt;let _A=0;function FA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function kA(e){return"/"===e[0]?e.substr(1):e}const GA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=FA(kA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=FA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=kA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=FA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Mh(Ph(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Wm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Mh(Ph(new Uint8Array(n.buffer))):n.buffer=Ph(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Nh!==n.ref.encode&&Nh&&(NA(`Swap bytes of ${n.name}`),_h(n.buffer,xs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&BA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--_A&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};jm("html",(e=>GA));const{vtkErrorMacro:UA,vtkDebugMacro:zA}=jt;function WA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const HA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new $m(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Oh)return Oh.encode(e);var o=e.length,a=new $m(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new $m(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return hh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Lh(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||UA("ERROR!!! zip not ready...");const u=WA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Mh(Ph(new Uint8Array(e.buffer))):e.buffer=Ph(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Nh!==e.ref.encode&&Nh&&(zA(`Swap bytes of ${e.name}`),_h(e.buffer,xs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&UA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Mh(Ph(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Mh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Mh(Ph(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Mh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Mh(Lh(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Mh(s))},fetchImage(e,n){const a=WA(n);t||UA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=zm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=WA(n);t||UA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Ph(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};jm("zip",(e=>HA(e)));var jA=n(892),KA=n.n(jA),$A=n(760),qA=n.n($A),XA=n(311),YA=n.n(XA),ZA=n(192),QA=n.n(ZA),JA=n(60),eI=n.n(JA),tI=n(865),nI=n.n(tI),rI=n(34),oI={};oI.styleTagTransform=nI(),oI.setAttributes=QA(),oI.insert=YA().bind(null,"head"),oI.domAPI=qA(),oI.insertStyleElement=eI(),KA()(rI.Z,oI);var aI=rI.Z&&rI.Z.locals?rI.Z.locals:void 0;let iI=!0;function sI(e){e.preventDefault(),e.stopPropagation()}function lI(e,t){iI=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=nC.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=LA.getSynchronizerContext(),a=LA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",aI.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?zh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Km("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):zh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Km("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Wm(t.base64Str),n=Km("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function cI(e){iI=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(aI.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${aI.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){sI(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];lI(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",sI)}const uI=ny();if(uI.url||uI.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(aI.fullScreen),t.style.margin="0",t.style.padding="0"),iI=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>lI(n,uI)))}setTimeout((()=>{iI&&cI()}),100),window.OfflineLocalView={initLocalFileLoader:cI,load:lI}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(819),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
